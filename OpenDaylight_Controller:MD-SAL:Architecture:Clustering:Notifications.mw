=Overview=
There are 2 kinds of messaging exchange pattern supported by MD-SAL
# Request/Reply
# Publish/Subscribe

Request/Reply pattern is implemented by rpc module. Publish/Subscribe functionality is provided by notification module. The implementation details are provided on this page: [[OpenDaylight_Controller:MD-SAL:Explained:Messaging_Patterns]]

This wiki only focuses on Publish/Subscribe implementation. Pre-helium implementation assumes a single vm deployment of controller. The message exchange happens only within a VM in memory. The requirement for helium is to enable these notifications across nodes in the cluster.

There are 2 kinds of Publish/Subscribe notifications:
#Data Change events
#Yang notifications

In both cases, the notifications are broadcasted to all "listeners".

=Requirement=

A lot has been discussed on the thread [https://lists.opendaylight.org/pipermail/controller-dev/2014-July/005923.html here]

*We should be able to publish notifications to any subscriber in the cluster. 

*Subscribers should be able to specify delivery policy
**1 of N - Deliver the notification to any one of N instances of application running in the cluster
** N of N - Broadcase
** Local only - The events generated on the same node as the application instance
** Load Balance - Round robin, least loaded etc
** Content Based or any other application specified custom logic

*Publisher should be able to attach properties to the message
**Message priority
**Delivery guarantee ?

*Ability to plug-in external systems such as AMQP based systems ? Not sure if this is a requirement but was discussed on the mailing thread.

=Proposal for helium=
Based on the requirement, a change in API has been proposed.

<code>
  publish(Notification notification, ''MessageProperties props'');
  registerNotificationListener(org.opendaylight.yangtools.yang.binding.NotificationListener.NotificationListener listener, ''Selector selector'');
  registerNotificationListener(Class notificationType, org.opendaylight.controller.sal.binding.api.NotificationListener listener, ''Selector selector'');
</code>

<code>
 public interface MessageProperties{
  public Priority priority();
  ...[add more properties]
 }
</code>

<code>
 public enum Priority { HIGH, NORMAL, LOW};
</code>

<code>
 public interface Selector {
  public List<InstanceLocator> select(Notification event, List<InstanceLocator> instances);
 }
</code>

<code>'Selector"</code> and <code>"MessageProperties"<code> are new additions.

Now the question is about the behavior of current APIs without <code>'Selector"</code> and <code>"MessageProperties"<code>. As far as message priority goes, its easy, we assign <code>normal</code>. The tricky one is deliver policy. Should the message be delivered to all instances of the application in the cluster or just one. While there is no consensus on this yet, the proposal is:

==Issue==
When controller is deployed in a cluster with ''n'' nodes, there will be "n" instances of an application running in the cluster. All these instances would subscribe to the same event and will receive notification. This may lead to data corruption as all instances would react to the notification and do their processing. An overly simple example could be thought as maintaining counter in database. All instances of application may end up incrementing the counter for the same event.
