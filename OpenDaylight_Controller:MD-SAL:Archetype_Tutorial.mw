= Developing YANG applications in Java Using OpenDaylight =

== Introduction ==

This purpose of this tutorial is to provide a quick jump start for developing YANG applications based on Java and using OpenDaylight YangTools, the MD-SAL and the Restconf infrastructure.

We will explore the application generator, which sets up your application development environment for use with OpenDaylight and generates a skeleton application that consists of:

* '''A YANG model''' - that defines a '''task''' service, which provides an RPC to enter a new task entry (the '''saveEntry''' RPC) into the service and an operational data that lists all saved task entries. The '''task''' service's operational data is grafted into  OpeDaylight's Operational Data Tree
* Two '''Java applications''':
** '''A Provider''' - An application that implements the that task service; it provides the implentation for the the '''saveEntry''' RPC builds the task services operational data in ODL's Operational Data Tree.  Note that out of the box the task service provider '''does not store''' operational data in Operational Data Tree - we will build that functionality in course of this tutorial.
** '''A Consumer''' - An application that uses the generated Java Binding classes to invoke the '''saveEntry''' RPC.
* A '''Web application''' that  uses Restconf to put new entries into the '''task''' service (via the '''saveEntry''' RPC ) and read the task service's operational data.

== Prerequisities ==

* Java 7<br />
* Maven 3.0+<br />
* Eclipse

== Step-by-Step Tutorial ==

=== 1. Generating the Application Skeleton ===

Run the following commands to start the generation of the application skeleton:

<pre>git clone https://git.opendaylight.org/gerrit/p/toolkit.git && cd toolkit && mvn clean install -D skipTests</pre>

This will compile the extensions for maven that will be used to generate the base applications.

Next, go to the directory where you want your application code to live, and run:

<pre>mvn archetype:generate -DarchetypeGroupId=org.opendaylight.toolkit  -DarchetypeArtifactId=md-sal-app-simple</pre>

This command is longer, but will download all the necessary dependencies and bootstrap your OpenDaylight development environment.

The command will ask a few questions about a few properties in your application:

# '''groupId''' - the group ID for your application; usually it is the reverse DNS for your app, eg. '''com.example.yangapp'''<br />
# '''artifactId''' - the name of your application component; usually it is separated with dashes and must be unique within the groupId. Let's use '''yang-demo-app''' for artifactId. This is also the name of the folder in which your application code will reside.<br />
# '''version''' - the version of your application. the '-SNAPSHOT' suffix means a development version. Press enter to use the default version.<br />
# '''package''' - the package name which will be used for generated sources. Press enter to use the default.<br />
# For all additional details, press enter to continue with defaults.

The archetype will generate the initial structure required to generate the project.

Next, go into the '''generate''' directory which is inside the folder named after your artifacId, and run '''mvn clean install -Dgen''' there, to finish the code generation:

<pre>cd yang-demo-app/generate
mvn clean install -Dgen</pre>

This will generate the following additional sources:
* '''yang-demo-app/model''' - YANG Model, project is configured to generate<br /> Java sources describing data structures from YANG models located in<br /> yang-demo-app/model/src/main/yang.<br />
* '''yang-demo-app/provider''' - Component responsible for implementing RPC in model,<br />and exporting operational state of component using MD-SAL.<br />
* '''yang-demo-app/consumer''' - Sample app which uses MD-SAL to invoke RPCs<br />
* '''yang-demo-app/web''' - Sample web app which uses RESTCONF to invoke RPCs<br /> described in YANG Model and retrieving operational state.

After that you may delete whole generate folder.

<pre>cd ..
rm generate</pre>

=== 2. Compiling your Application from the Command Line ===

In order to compile your skeleton application, you need to go to the root folder of your project ('''yang-demo-app''') and run the following maven command:
<pre>mvn clean install</pre>
This will parse the YANG model, generate all sources from YANG files and compile the initial sample code for you. It will also prepare your application project for import into Eclipse (see the next step).

=== 3. Importing the Application Project into Eclipse ===

# Start Eclipse<br />
# Go to File-&gt;Import<br />
# Select General-&gt;Existing Maven Projects<br />
# Click Browse and select directory with sources of your app<br />
# Eclipse will scan folder and provide you with list of projects<br />
# Click Finish

=== 4. Exploring the YANG to Java Mapping ===

The model that defines the RPC and the data tree is present in

<pre>yang-demo-app/model/src/main/yang/task.yang </pre>

The OpenDaylight YANG Tools will parse this YANG file and generate various Java classes that represent data structures and RPCs defined in the YANG model.

For example, the RPC  statement '''saveEntry''' in the YANG model

<pre>rpc saveEntry {
    description &quot; Method to add a new entry into datastore.&quot;;
    input {
    ...</pre>

is mappedointo the following Java method call in the '''TaskService''' interface:

<pre>/**
   Method to add a new entry into datastore.
**/
Future&lt;RpcResult&lt;java.lang.Void&gt;&gt; saveEntry(SaveEntryInput input);
</pre>

A call to the '''saveEntry''' Java method represents an invocation of the Yang '''saveEntry''' RPC.

The YANG '''input''' statement (i.e. the payload of the RPC) is mapped onto the '''SaveEntryInput''' interface. The tools also generate the '''SaveEntryInputBuilder''' and '''SaveEntryInputImpl''' helper classes, which can be used to create or parse the input of the '''saveEntry''' RPC. '''SaveEntryInputImpl''' is the implementation of the '''SaveEntryInput''' interface, '''SaveEntryInputBuilder''' is to create instances of '''SaveEntryInputImpl'''. 

As a rule of thumb, YANG Tools generate an Interface/Builder pair for each container, list, case and augmentation statement in the YANG file(s) defining YANG-modeled payload.

For following data tree statements

<pre>container task {
      description
        &quot;Top-level container for all application database objects.&quot;;
      list entry {</pre>

YANGTools generated the Java interfaces '''Task''' and '''Entry''' for the container '''task''' and list '''entry'''. Builders for the data tree were also generated.

=== 5. Implementing the Provider ===

The implementation of our provider is in '''TaskProvider.java''' (if you named your app yang-demo-app, the file is in the app yang-demo-app-provider project). This class implements the generated '''TaskService''' interface. To provide the RPC service, it must implement the '''saveEntry''' method in order to provide RPC. We will explore the RPC implementation later in the tutorial, let's explore first how to store data in the operational tree in the MD-SAL Data Store.

==== 5.1. Writing Data to the Operational Data Tree====
===== 5.1.1 Constructing Data =====

In this example, when the Provider is first started, we want it to write the first entry into the top level container task in the operational data tree. This will basically provide some test data for Restconf clients right when the app is started, without having to enter data via RPC.

For that we will create an entry in the task list maintained in the modify the TaskProvider implementation. We want to do this at startup so we will modify the '''setDataService''' method  in '''TaskProvider.java''', which is called only once when the app gets access to the data store service (basically, when MD-SAL tells the app that "the data store is ready to use").

First, we are going to construct the entry in the Task Service, which will be:

<code>
      // Construct the builder of item of entry list
      EntryBuilder entryBuilder = new EntryBuilder();
      // Set the key of list item to hello-ietf
      entryBuilder.setEntryId(new EntryId("hello-ietf"));
      // Set the title leaf to Hello IETF: Java
      entryBuilder.setTitle("Hello IETF: Java");
      // Set the decription of entry
      entryBuilder.setDesc("Entry written from Java code.");
      // We build our first entry
      Entry firstEntry = entryBuilder.build();
</code>

Now we have our first entry . The yang model specifies that the entry is encapsulated by in the container '''task'''. So lets construct the container:

<pre>
      // Construct builder for the task container
      TaskBuilder taskBuilder = new TaskBuilder();
      // We create the list of entries
      List<Entry> entryList = Collections.singletonList(firstEntry);
      // Sets entry list in task builder to the one that we created in the previous step
      taskBuilder.setEntry(entryList);
      // We build the task container
      Task task = taskBuilder.build();
</pre>

We built task container, which contains our first entry, using classes generated by YANG Tools. This object is equivalent to the following XML:

<pre>
&lt;task&gt;
  &lt;entry&gt;
    &lt;entry-id&gt;hello-ietf&lt;/entry-id&gt;
    &lt;title&gt;Hello IETF from Java&lt;/title&gt;
    &lt;desc&gt;Entry written from java code&lt;/desc&gt;
  &lt;/entry&gt;
&lt;/task&gt;
</pre>

In order to actually write data into the operational tree in the Data Store and make it readable by others, we need to allocate a WriteTransaction, write the data, and commit the transaction.

===== 5.1.2 Writing Data to the Operational Data Tree =====

In order to write data to data store provided by MD-SAL and used by others such as
Restconf and other applications, we need to allocate transaction, write data to data tree
and commit  it.

Transaction could be allocated by invoking method new(Transaction Type)Transaction() methods
on DataBroker instance. 
Generated skeleton of application provided us already with access to data broker, so  lets
use it to allocate new WriteOnlyTransaction since we are going only to write data.

<pre>
      // Allocates our first write only transaction
      WriteTransaction firstTx = dataService.newWriteOnlyTransaction();
</pre>

All data operations are done by transaction and allways takes at least two arguments: logical data store type and instance identifier
identifying location in data tree, which we are manipulating or reading.

Classes generated from YANG model could be used to construct an instance identifier (think of it as restconf URI)
in type safe way using generated classes, which will issue a compile time error if your path is incorrect according to YANG model.
Since we are going to write our top container task, path is relativelly simple.

<pre>
      // We create Instance Identifier path to task container
      // This is equivalent of restconf path /task:task
      InstanceIdentifier<Task> path = InstanceIdentifier.create(Task.class);
</pre>

Now we could proceed to actual write of data, we will do a PUT operation for task container.

<pre>
      // We put top container into OPERATIONAL store on path /task:task
      firstTx.put(LogicalDatastoreType.OPERATIONAL, path, task);
</pre>

You could see, that we specified OPERATIONAL data store, used path and task object, which we created before.

Only last missing step to actually write data is to commit transaction. Your data are not visible to others
before you commit transaction and that transaction is processed by data store.

<pre>
      // We submit transaction to be commited to datastore
      firstTx.commit();
</pre>

===== 5.1.3 Summary =====

We modified method body setDataService for learning purposes to write initial Hello IETF entry into operational 
data store.

Resulting method body should be:
<pre>
    public void setDataService(DataBroker dataService) {
      this.dataService = dataService;

      // Construct builder of item of entry list
      EntryBuilder entryBuilder = new EntryBuilder();
      // Set key of list item to  hello-ietf
      entryBuilder.setEntryId(new EntryId("hello-ietf"));
      // Set title leaf to Hello IETF: Java
      entryBuilder.setTitle("Hello IETF: Java");
      // Set decription of entry
      entryBuilder.setDesc("Entry written from Java code.");
      
      // We build our first entry
      Entry firstEntry = entryBuilder.build();

      // Construct builder for task container
      TaskBuilder taskBuilder = new TaskBuilder();
      // We create list of entries
      List<Entry> entryList = Collections.singletonList(firstEntry);
      // Sets entry list in task builder to one, we previously created
      taskBuilder.setEntry(entryList);
      // We build task container
      Task task = taskBuilder.build();

      // Allocates our first write only transaction
      WriteTransaction firstTx = dataService.newWriteOnlyTransaction();

      // We create Instance Identifier path to task container
      // This is equivalent of restconf path /task:task
      InstanceIdentifier<Task> path = InstanceIdentifier.create(Task.class);
      
      // We put top container into OPERATIONAL store on path /task:task
      firstTx.put(LogicalDatastoreType.OPERATIONAL, path, task);
      // We submit transaction to be commited to datastore
      firstTx.commit();
    }
</pre>

==== 5.2 Implementation of RPC saveEntry ====

Notice that our generated skeleton of TaskProvider is s implementing '''TaskService''' interface<br />which requires it to implement method '''saveEntry'''.
This method is actually implementation of saveEntry RPC. User supplied input will be available via provided instance of '''SaveEntryInput'''.

This method will be invoked if someone invokes saveEntry RPC  using Restconf or generated TaskService java interface. invokes or using ,<br />this method '''saveEntry''' is called, 

<pre>
@Override
public Future&lt;RpcResult&lt;Void&gt;&gt; saveEntry(SaveEntryInput input) {
    log.debug(&quot;Saving the entry&quot;);
    if(input == null || input.getEntryId() == null) {
    ...
</pre>

Generated skeleton of application provided us with base implementation of saveEntry which translates SaveEntryInput into Entry object and creates SaveEntry task,
which is scheduled to be executed asynchronously using executor, but skeleton implementation of SaveEntry task does not store data to operational data tree.

We are going to modify SaveEntry task to store data into operational data tree, so these tasks could be accessible for others by reading data tree
using Java APIs and Restconf.

===== 5.1 Registering RPC implementation =====

RPC implementation must be registered with MD-SAL in order to exposed to Restconf or other Java skeletons, generated skeleton of application
has already did that for us in '''TaskProviderModule''', by invoking addRpcImplementation method on RpcProviderRegistry, with specifying
that we are implementing RPCs defined in '''TaskService''' interface.

<pre>
        RpcProviderRegistry rpcRegistryDependency = getRpcRegistryDependency();
        final BindingAwareBroker.RpcRegistration<TaskService> rpcRegistration =
                                rpcRegistryDependency
                                    .addRpcImplementation(TaskService.class, appProvider);
</pre>

Invoking close() on returned rpcRegistration, unregister our implementation from MD-SAL. After closing registration, no one will
be able to invoke our RPC using MD-SAL or Restconf.

===== 5.2 Modifying RPC to store entries to task:task data tree =====

In order to modify SaveEntry task we need to modify method '''call()''', which is invoked once that task is processed by executor.

First you could notice there is some code in call method, but we will not need it in this tutorial so for start delete everything
inside call method except return statement.

<pre>
      @Override
      public RpcResult<Void> call() throws InterruptedException {
          return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
      }
</pre>

This return statement returns successful RPC result with no data and errors associated with it.

As we learned before in order to write data, we need write transaction, which we will use to modify data tree.

<pre>
      @Override
      public RpcResult<Void> call() throws InterruptedException {
         WriteTransaction tx = dataService.newReadWriteTransaction();

</pre>


To write data, we need construct instance identifier for entry, which we are going to add. Notice that generated skeleton
already constructed entry for us, so we need only to construct instance identifier, which will be equivalent
of restconf path /task:task/entry/(entry-id)

<pre>
        // Each entry will be identifiable by a unique key, we have to create that identifier
        InstanceIdentifier<Entry> path = InstanceIdentifier.create(Task.class).child(Entry.class, entry.getKey());
</pre>

You could see we used same pattern as before, but we added '''.child(Entry.class, entry.getKey())''' part. 
This means that we are referencing list item entry in task container with key from our builded entry.
Next we need to PUT this entry to data tree and commit transaction.
<pre>
        tx.put(LogicalDatastoreType.OPERATIONAL, path, entry);
        tx.commit();
</pre>

We should end-up with call() method like this:
<pre>
      @Override
      public RpcResult<Void> call() throws InterruptedException {
         WriteTransaction tx = dataService.newReadWriteTransaction();
        // Each entry will be identifiable by a unique key, we have to create that identifier
        InstanceIdentifier<Entry> path = InstanceIdentifier.create(Task.class).child(Entry.class, entry.getKey());
        tx.merge(LogicalDatastoreType.OPERATIONAL, InstanceIdentifier.create(Task.class), new TaskBuilder().build());
        tx.put(LogicalDatastoreType.OPERATIONAL, path, entry);
        tx.commit();
        return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
      }
</pre>

So our implementation of '''saveEntry''' RPC takes and SaveEntryInput translated it into item of list entry
and writes that to operational data store using path pointing directly to write place.

So now is part to compile our code, install is into controller and give it a test ride.

=== 6. Recompiling application with our changes ===

For compilation of our application, we will use command line. Go to root folder of
your application (yang-demo-app) and run following:

<pre>
mvn clean install
</pre>

=== 7. Downloading Opendaylight Distribution ===

This archetype is targeted for Helium release, you could download latest development snapshot from:

<pre>
https://jenkins.opendaylight.org/integration/view/Integration%20jobs/job/integration-master-project-centralized-integration/lastSuccessfulBuild/artifact/distributions/base/target/distributions-base-0.2.0-SNAPSHOT-osgipackage.zip
</pre>
After downloading distribution unzip it to folder of your choice.

=== 8. Installing application ===

Copy all compiled JAR files from your project to plugins folder of Opendaylight distribution.<br />In case of our sample application this files are:

<pre>
./provider/target/yang-demo-app-provider-1.0-SNAPSHOT.jar
./consumer/target/yang-demo-app-consumer-1.0-SNAPSHOT.jar
./model/target/yang-demo-app-model-1.0-SNAPSHOT.jar
./web/target/yang-demo-app-web-1.0-SNAPSHOT.jar</pre>
E.g.

<pre> cp ./provider/target/yang-demo-app-provider-1.0-SNAPSHOT.jar ./consumer/target/yang-demo-app-consumer-1.0-SNAPSHOT.jar ./model/target/yang-demo-app-model-1.0-SNAPSHOT.jar ./web/target/yang-demo-app-web-1.0-SNAPSHOT.jar ../opendaylight/plugins</pre>

You need also copy configuration for your sample provider application to configuration/initial folder of Opendaylight Distribution.

<pre>./provider/src/main/resources/configuration/initial/05-provider-task-sample.xml</pre>

For example:

<pre>cp ./provider/src/main/resources/configuration/initial/05-provider-task-sample.xml ../opendaylight/configuration/initial</pre>
You have all setup to run your sample application.

For consumer configuration is located in 
<pre>
./provider/src/main/resources/configuration/initial/06-consumer-task-sample.xml
</pre>

These configuration tells Config Subsystem how to start your application and enumerates which services from MD-SAL your application needs
to use.

=== 9. Run of application ===

Go to your Opendaylight installation folder and run '''./run.sh''' (on Linux / MAC)<br />or '''./run.bat''' on Windows to start Opendaylight.

During startup your components will be picked-up by Opendaylight infrastructure<br />and registered to system:

* YANG models are discovered by MD-SAL, which updates datastore and restconf to support<br /> your model<br />
* Provider, Consumer bundle and configuration are discovered by Config Subsystem,<br /> which starts them based on Configuration.<br />
* Provider registers itself to MD-SAL as implementation of RPC<br />
* Web Bundle is picked up by Webserver (Tomcat) and is available via browser (this<br /> is for UI, Restconf integration is provided by MD-SAL).

In log you should see something like

<pre>15:31:06.395 CEST [config-pusher] INFO  o.o.c.c.y.c.t.i.TaskProviderModule - TaskProvider (...) initialized</pre>
This means your application is started.

=== 10. Using application via Web User interface ===

Go to:

<pre>http://localhost:8080/controller/web/yang-demo-app/view</pre>

User interface is pretty self explanatory, you may add data using Add Entry button and it displays a list of all entries stored by your provider.

You should be able to see our hello-ietf entry, which we created and stored from Java code of provider.

Note that Add Entry issues and RPC in background using Restconf to your provider and also uses Restconf to retrieve all data which were stored by provider.

=== 11. Using application via Restconf ===

==== Retrieving Operational Data for task provider ====

To retrieve all tasks from restconf you simply issue GET request<br />for URL

<pre>http://localhost:8080/restconf/operational/task:task</pre>

If your provider already started you should be able to see our initial entry, which we wrote using Java code.


===== Retrieving data in JSON =====

If you change '''Accept''' header to '''application/json''' or '''application/yang.data+json''' you will retrieve JSON representation of stored data.

<pre>{
    &quot;task&quot;: {
        &quot;entry&quot;: [
            {
                &quot;title&quot;: &quot;test&quot;,
                &quot;entry-id&quot;: &quot;34701633593067530&quot;,
                &quot;desc&quot;: &quot;description&quot;
            }
        ]
    }
}</pre>
==== Invoking RPC on provider ====

===== Invoking RPC using XML payload =====

In order to invoke '''saveEntry''' RPC from our initial sample model using Restconf<br />we need to make '''POST''' request for saveEntry RPC URL

<pre>POST /restconf/operations/task:saveEntry HTTP/1.1
Content-Type: application/xml
Accept: application/xml

&lt;input&gt;
  &lt;entryId&gt;10&lt;/entryId&gt;
  &lt;entryField&gt;
    &lt;key&gt;title&lt;/key&gt;
    &lt;value&gt;From IETF&lt;/value&gt;
  &lt;/entryField&gt;
  &lt;entryField&gt;
    &lt;key&gt;desc&lt;/key&gt;
    &lt;value&gt;Example Demonstrated on IETF&lt;/value&gt;
  &lt;/entryField&gt;
&lt;/input&gt;</pre>
This RPC is then delivered to our provider in form of Java generated classes,<br />which it stores into operational data store.

If you issue following GET for http://localhost:8080/restconf/operational/task:task<br />you will see your entry added there.

===== Invoking RPC using JSON Payload =====

For JSON URL is same, you need only to change Content-Type and Accept headers<br />to '''application/json''' or corresponding ones as per Restconf draft.

<pre>POST /restconf/operations/task:saveEntry HTTP/1.1
Content-Type: application/json
Accept: application/json

{  
   &quot;input&quot;:{  
      &quot;entryField&quot;:[  
         {  
            &quot;key&quot;:&quot;title&quot;,
            &quot;value&quot;:&quot;From IETF&quot;
         },
         {  
            &quot;key&quot;:&quot;desc&quot;,
            &quot;value&quot;:&quot;Payload in JSON&quot;
         }
      ],
      &quot;entryId&quot;:&quot;12&quot;
   }
}</pre>

=== 11. Invoking RPC via Java ===

'''TaskConsumerImpl''' shows how RPCs are invoked from Java Code.

In order to invoke any RPC from YANG module, user code must obtain implementation<br />from MD-SAL using RpcConsumerRegistry:

<pre>TaskService service = getRpcRegistryDependency().getRpcService(TaskService.class);</pre>
Returned service is not our provider, but implementation provided by MD-SAL,<br />which makes sure reference to actual implementation is never leaked and<br />may translate data to different payload format if necessary (e.g. Netconf XML).

In order to construct input consumer uses '''SaveEntryInputBuilder'''<br />to construct RPC input.

<pre>SaveEntryInputBuilder inputbuilder = new SaveEntryInputBuilder();
...
inputbuilder.setEntryField(fields);</pre>
Finally we are invoking RPC and blocking for result to be delivered:

<pre>RpcResult&lt;Void&gt; result = service.saveEntry(inputbuilder.build()).get();</pre>

== Summary ==

This tutorial showed up how to use archetype and Opendaylight to create<br />simple YANG-modeled application, install it into system and use it via<br />Restconf and Java.

== Further Reading ==

* [https://www.youtube.com/watch?v=IMKFMJ-toGA Original Presentation of Archetype]<br />
* [https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL#Tutorials Other MD-SAL Tutorials]
