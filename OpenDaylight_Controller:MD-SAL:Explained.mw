This document provides an introduction to the Model-Driven Service Adaptation Layer (MD-SAL), detailing where it comes from, what its goals and non-goals are and how its design works to fulfill these goals. 

== Introduction ==

=== History ===

In our previous attempts at programmable systems, we have seen an attempt to abstract the entire system out. While this works when the technology set is known beforehand, failure to account for a technology typically incurs either a major slowdown while the technology is retrofitted into the existing APIs, or a fork of those APIs with the need to reintegrate. In both cases the progress becomes limited by the throughput of a single team which maintains the abstraction APIs, as that team needs to have a domain expert in the technology being integrated to ensure the abstractions and interactions are cohesive and do the right thing from both the technology and the API style perspective.
 
MD-SAL grew out of realization, that this extensibility problem should not exist, as anyone should be able to at least prototype their APIs and the "SAL" layer should just work, even if the prototype code will remain an island within the larger system. This effectively splits the "SAL problem" into a few architectural components:
* The choice of a Data Definition Languange (DDL)
* The choice of a set of data access patterns
* The implementation of a core runtime environment (RTE) supporting the combination of the two
* The implementation of technology-independent services on top of the RTE
* The definition of a core set of technology-specific data models
 
During early evaluation we came across YANG as an emerging standard in the area of network element management and it proved to be a very sound base for the use-cases we were able to throw at it. Some of the key features considered important were:
* decentralized extension mechanism ("augment")
* data vs. document structure validation ("when")
* extensible language ("extension")
* pre-composed objects ("grouping")
* extensible data type hierarchy
* inclusion of basic interactions (RPC and notification)
* existing tools and community (yang-central, NETCONF/NETMOD IETF WGs, ...)

=== In-Scope ===
 
* Design of YANG based Model-Driven Service Adaptation Layer and development of reference implementations of MD-SAL components (runtime)
:* Support for multiple Bindings and adaptation (serialization / deserialization) for these bindings
::* Java YANG Binding
::* Java YANG DOM
::* RESTCONF
:* Utility components for developing MD-SAL based applications
:* Development of YANG models describing the MD-SAL itself and its infrastructure  services; this includes MD-SAL-specific YANG extensions
:* Development of a Technology Compatibility Kit (TCK) for MD-SAL components to qualify reference and custom implementations
:* Development of remoting components for MD-SAL: remote clients and clustering components
 
=== Out-of-Scope ===

:* Design and development of apllication-specific  models, (device, service, and network function abstraction models
:* Design and development of apllication-specific ODL components that implement APIs defined by the device, service and network function abstraction models.

====
The Model-Driven SAL (MD-SAL) is an infrastructure component that provides messaging and data storage functionality for based on user-defined (application developers) data and interface models.

MD-SAL has two main objectives:

* Provide a '''common-layer''', '''concepts''', '''data''' model '''building blocks''' and '''patterns''' which serves as building blocks  applications
* support of multiple transport and payload formats, serialization/adaptation them.

This objectives are achieved by using YANG as modeling language for interface
and data definition and providing runtime for services using YANG modeling.

== [[OpenDaylight Controller:MD-SAL:Explained:Modeling Concepts|Basic Modeling Concepts]] ==

Basic concepts are building blocks, from which MD-SAL derives its services,
behavior based on mapping of basic concepts to developer-supplied YANG models.

{{:OpenDaylight Controller:MD-SAL:Explained:Include:Basic Concepts}}

== [[OpenDaylight Controller:MD-SAL:Explained:Messaging Patterns|Messaging Patterns]] ==

{{:OpenDaylight Controller:MD-SAL:Explained:Include:Messaging Patterns}}

== Supported API, Transport, Payload variations ==

One of the target objective of MD-SAL is to expose functionality of providers
via various transport/payload formats, without any coding required on provider
side.

MD-SAL currently exposes following transport/payload formats (Hydrogen):

* [[OpenDaylight Controller:MD-SAL:Explained:Java YANG Binding|'''intra-JVM''' communication using '''generated DTOs''']] (Java YANG Binding)
* [[OpenDaylight Controller:MD-SAL:Explained:Java YANG DOM|'''intra-JVM''' communication using '''YANG DOM Model''']]
* '''HTTP''' consumer-only APIs using [[OpenDaylight Controller:MD-SAL:Restconf|'''Restconf''', '''XML''' and '''JSON''']] as payload

Experimental transport/payload formats (Hydrogen):

* '''Cross-process''' APIs using '''ZeroMQ''' and '''XML''' as payload

Planned transport/payload format (Helium):

* [[OpenDaylight Controller:MD-SAL:Architecture:Clustering|'''Cross-JVM''' communication using '''Akka''']]
