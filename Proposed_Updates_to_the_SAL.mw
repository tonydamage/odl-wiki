== Summary ==
This page is a work in progress that tries to document plans to improve the SAL, specifically that have come out of merging the two controllers.  Some of these updates are more short-term lower hanging fruit and some of these updates are longer term and will require more discussion.  Hopefully the community will contributes to this page and it will serve as a check list of current discussion about the SAL and be updated as discussion points change.

Because understanding the SAL and its capabilities and implications is itself a work in progress, it is entirely possible that this page contains errors.  Hopefully the community can work together to identify, confirm, and work around any issues in the SAL.

== Short Term Updates ==


=== Missing abstractions to be added === 
* Packet processing pipeline (e.g., that a packet goes to module A, *then* B, then C)
* TTL decrement action
* 6 of the 12 OpenFlow 1.0 match fields (e.g., in_port, outer vlan tag, vlan_pcp, IP protocol, IP ToS, etc.) 
* no NextHop action needed for routing protocols like BGP
* Multiple tables
* Master/Slave notifications between controller and node for HA
* Master/Slave notifications inside the controller (for Apps in the slave node to wake up)

=== Existing abstractions to be updated ===
* The Host.java does not allow for hosts with multiple IPs or duplicate MACs needed for multi-tenancy
* The topology service does not have the notion of SDN vs. non-SDN islands and the current code implicitly assumes a pure SDN network


== Longer Term Updates ==
=== Consistency Assumptions===
It appears that that SAL makes a number of implicit assumptions about having strong consistency in the semantics of many of its APIs.  While this assumption may be fine for some deployments (e.g., with a redundant management network) it is not right for all deployments (e.g., over a wide area network).  

==== Event Ordering ====
Event ordering is a thorny problem.  If an applications receives a list of events, e.g., Link DOWN, Link UP, Link DOWN, the application cannot reliably determine if the final state of the link is DOWN or UP unless it assumes that the order of events is preserved.  Various consistency assumptions (e.g., eventual consistency) and even the threading model local to the machine may reorder cause events.  For these ordering sensitive events, we will likely need to re-write parts of the SAL to use different mechanism to detect event reordering (e.g., vector clocks) and provide APIs that alert the higher level application that re-ordering has occurred.

* IListenTopoUpdates
* IDiscoveryService
* IListenInventoryUpdates
* IfHostListener (technically not part of the SAL, but apps seem to depend on it and tightly coupled with Host.java)
* More?  Work in progress



==== Partition Recovery ====
Partition recovery is another thorny problem and is correlated with event re-ordering.  The SAL seems to be written under the assumption that partitions in the management plane do not happen, but this may not be a valid assumption in all deployments.  Particularly with transactions, maintaining the precise transaction boundaries during a partition and ensuring that the recovered state after the partition is resolved accurately reflects those tranaction boundaries is complicated.  For example, using the SAL Property.java properties, imagine application A on controller X sets properties Foo=1 and Bar=1 on a Link, but a partition happens, and application A on controller X sets Foo=1 and application B on controller Y sets Bar=2 for the same Link.  After the partition is resolved, what are the correct values for Foo and Bar?  Application A expects "Foo=2 and Bar=1" and Application B expects "Foo=1 and Bar=2" -- what is the partition resolver supposed to do?  One might assume the right thing is to set both  "Foo=2 and Bar=2", but that might violate the semantics of the state (e.g., if Foo and Bar were being used as mutually exclusive locks).  We need to be very careful that the semantics and assumptions of the SAL are well understood and documented.

=== Extensibility Requirements ===
In order for the SAL to be successful, it seems that being modular and extensible are important.  More specifically, if the SAL lives in the one project, another project should be able to extend the SAL's interface without modifying the code in the SAL's project.  While such a mechanism does not yet exist, proposals are starting to emerge:
* Model-driven SAL : [[https://linuxfoundation.webex.com/linuxfoundation/lsr.php?AT=pb&SP=EC&rID=6781737&rKey=259ae7e837db1b87]]
