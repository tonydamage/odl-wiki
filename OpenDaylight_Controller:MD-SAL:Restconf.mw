== How to use Restconf ==
==== Overview before operations ====
Restconf allows access to datastores locating in controller. There are two datastores: 
* '''Config''' – contains data inserted via controller
* '''Operational''' – contains other data
<br />
; Each request must start with URI '''/restconf'''
; Restconf listens on port '''8080''' for '''HTTP''' requests
<br />
Restconf supports '''OPTIONS, GET, PUT, POST, DELETE''' operations. Request and response '''data can be in XML or JSON''' format. XML has structure according to yang by [http://tools.ietf.org/html/rfc6020 XML-YANG] and JSON by [http://tools.ietf.org/html/draft-lhotka-netmod-yang-json-02 JSON-YANG]. Data in request must have correctly set “'''Content-Type'''” field in http header with allowed value of media type and media type of requested data has to be set in “'''Accept'''” field. Media types for each resource can be got by calling OPTIONS operation.
<br />
Most of the Restconf endpoints path uses [[OpenDaylight Controller:MD-SAL:Concepts#Instance_Identifier|Instance Identifier]]. We will use <tt><identifier></tt> in explanation of operations.
<br />
: <tt><identifier></tt>
::* must start with '''<tt><moduleName></tt>:<tt><nodeName></tt>''' where '''<tt><moduleName></tt>''' is a name of module and '''<tt><nodeName></tt>''' is a name of node in the module. It is sufficient use just '''<tt><nodeName></tt>''' after '''<tt><moduleName></tt>:<tt><nodeName></tt>'''. Each '''<tt><nodeName></tt>''' has to be separated by '''/'''
::* '''<tt><nodeName></tt>''' can represent data node which is list or container yang build-in type. If data node is list there must be defined keys of the list behind the data node name e.g. '''<tt><nodeName>/<valueOfKey1>/<valueOfKey2></tt>'''
::* Format '''<tt><moduleName></tt>:<tt><nodeName></tt>''' has to be used in this case as well:
::: Module A has node A1. Module B augments node A1 by adding node X. Module C augments node A1 by adding node X. Then for clarification there has to be known which node X is thought (e.g. C:X).
::: For more details about encoding please see: [http://tools.ietf.org/html/draft-bierman-netconf-restconf-02#section-5.3.1 Restconf 02 - Encoding YANG Instance Identifiers in the Request URI]
: '''Mount point'''
::* Node can be behind mount point. In this case URI has to be in format '''<tt><identifier></tt>/yang-ext:mount/<tt><identifier></tt>'''. The first '''<tt><identifier></tt>''' is path to a mount point and the second '''<tt><identifier></tt>''' is path to a node behind the mount point. URI can end in mount point itself by using '''<tt><identifier></tt>/yang-ext:mount'''
<br />
<br />

==== OPTIONS /restconf ====
:* returns XML description of resources with required request and response media types in Web Application Description Language (WADL)
<br />
==== GET /restconf/config/<tt><identifier></tt> ====
:* returns a data node from Config datastore
:* <tt><identifier></tt> points to a data node which should be retrieved
<br />
==== GET /restconf/operational/<tt><identifier></tt> ====
:* returns value of data node from Operational datastore
:* <tt><identifier></tt> points to a data node which should be retrieved
<br />
==== PUT /restconf/config/<tt><identifier></tt> ====
:* updates or creates data in Config datastore and returns state about success
:* <tt><identifier></tt> points to a data node which should be stored
: Example:
<pre>
PUT http://<controllerIP>:8080/restconf/config/module1:foo/bar
Content-Type: applicaton/xml
<bar>
  …
</bar>
</pre>
: Example with mount point: 
<pre>
PUT http://<controllerIP>:8080/restconf/config/module1:foo1/foo2/yang-ext:mount/module2:foo/bar
Content-Type: applicaton/xml
<bar>
  …
</bar>
</pre>
<br />
==== POST /restconf/config/<tt><identifier></tt> ====
:* creates data if they do not exist in Config datastore and returns state about success
:* <tt><identifier></tt> points to a data node where data should be stored
:* root element of data must have namespace (data are in XML) or module name (data are in JSON)
: Example:
<pre>
POST http://<controllerIP>:8080/restconf/config/module1:foo
Content-Type: applicaton/xml/
<bar xmlns=“module1namespace”>
  …
</bar>
</pre>
: Example with mount point:
<pre>
http://<controllerIP>:8080/restconf/config/module1:foo1/foo2/yang-ext:mount/module2:foo
Content-Type: applicaton/xml
<bar xmlns=“module2namespace”>
  …
</bar>
</pre>
<br />

==== POST /restconf/operations/<tt><moduleName></tt>:<tt><rpcName></tt> ====
:* invokes RPC
:* <tt><moduleName></tt>:<tt><rpcName></tt> - <tt><moduleName></tt> is name of module and <tt><rpcName></tt> is name of RPC in this module
:* Root element of data sent to RPC must have name “input”
:* Result can be status code or retrieved data having root element “output”
: Example:
<pre>
POST http://<controllerIP>:8080/restconf/operations/module1:fooRpc
Content-Type: applicaton/xml
Accept: applicaton/xml
<input>
  …
</input>

Answer from server could be:
<output>
  …
</output>
</pre>
<br />

==== DELETE /restconf/config/<identifier> ====
:* removes data node in the Config datastore and returns state about success
:* <tt><identifier></tt> points to a data node which should be removed
<br />
<br />
For further information read [http://tools.ietf.org/html/draft-bierman-netconf-restconf-02 RESTCONF RFC]

== How it works ==
Restconf uses these base classes:
* '''InstanceIdentifier''' represents path in data tree.
* '''ConsumerSession''' is used for invoking RPCs.
* '''DataBrokerService''' offers manipulation with transactions and reading data from datastores. 
* '''SchemaContext''' holds information about yang modules. 
* '''MountService''' returns MountInstance based on InstanceIdentifier pointing to a mount point.
* '''MountInstace''' contains SchemaContext behind mount point.
* '''DataSchemaNode''' is information about schema node.
* '''SimpleNode''' has name as schema node and contains value representing data node value
* '''CompositeNode''' can contains CompositeNode-s and SimpleNode-s
<br />
==== GET in action ====
The first picture shows GET operation with URI restconf/config/M:N where M is module name and N is node name.
<br />
[[Image:Get.png|GET operation with URI restconf/config/M:N where M is module name and N is node name.]]
<br />
# Requested URI is translated into InstanceIdentifier which points to data node. During this translations DataSchemaNode conform to the data node is obtained. If data node is behind mount point the MountInstance is obtained as well.
# Restconf asks for value of data node from DataBrokerService based on InstanceIdentifier.
# DataBrokerService returns CompositeNode as data.
# StructuredDataToXmlProvider or StructuredDataToJsonProvider is called based on Accept field from http request. These two providers can transform CompositeNode regarding to DataSchemaNode to XML or JSON document.
# XML or JSON is returned as answer on the client's request.
<br />

==== PUT in action ====
The second picture shows PUT operation with URI restconf/config/M:N where M is module name and N is node name. Data are sent in request either in XML or JSON format.
[[Image:Put.png|PUT operation with URI restconf/config/M:N where M is module name and N is node name. Data are sent in request either in XML or JSON format.]]
# Input data are sent to JsonToCompositeNodeProvider or XmlToCompositeNodeProvider. Correct provider is selected based on Content-Type field from http request. These two providers can transform input data to CompositeNode. However this CompositeNode does not contain enough information for transaction.
# Requested URI is translated into InstanceIdentifier which points to data node. During this translations is obtained DataSchemaNode conform to the data node. If data node is behind mount point the MountInstance is obtained as well.
# CompositeNode can be normalized by adding additional information from DataSchemaNode.
# Restconf begins transaction and puts CompositeNode with InstanceIdentifier into it. Response on client's request is status code which depends on result from transaction.
<br />
<br />
== Something from real world ==
'''1. Create new flow on switch ''openflow:1'' in ''table 2'''''
* HTTP request
<pre>
Operation: POST
URI: http://192.168.11.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:1/table/2
Content-Type: application/xml
</pre>
<syntaxhighlight lang="xml">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<flow 
    xmlns="urn:opendaylight:flow:inventory">
    <strict>false</strict>
    <instructions>
        <instruction>
          	<order>1</order>
            <apply-actions>
                <action>
                  <order>1</order>
                    <flood-all-action/>
                </action>
            </apply-actions>
        </instruction>
    </instructions>
    <table_id>2</table_id>
    <id>111</id>
    <cookie_mask>10</cookie_mask>
    <out_port>10</out_port>
    <installHw>false</installHw>
    <out_group>2</out_group>
    <match>
        <ethernet-match>
            <ethernet-type>
                <type>2048</type>
            </ethernet-type>
        </ethernet-match>
        <ipv4-destination>10.0.0.1/24</ipv4-destination>
    </match>
    <hard-timeout>0</hard-timeout>
    <cookie>10</cookie>
    <idle-timeout>0</idle-timeout>
    <flow-name>FooXf22</flow-name>
    <priority>2</priority>
    <barrier>false</barrier>
</flow>
</syntaxhighlight>
<br />
* HTTP response
<pre>
Status: 204 No Content
</pre>
<br />
'''2. Change ''strict'' to ''true'' in previous flow'''
* HTTP request
<pre>
Operation: PUT
URI: http://192.168.11.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:1/table/2/flow/111
Content-Type: application/xml
</pre>
<syntaxhighlight lang="xml">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<flow 
    xmlns="urn:opendaylight:flow:inventory">
    <strict>true</strict>
    <instructions>
        <instruction>
          	<order>1</order>
            <apply-actions>
                <action>
                  <order>1</order>
                    <flood-all-action/>
                </action>
            </apply-actions>
        </instruction>
    </instructions>
    <table_id>2</table_id>
    <id>111</id>
    <cookie_mask>10</cookie_mask>
    <out_port>10</out_port>
    <installHw>false</installHw>
    <out_group>2</out_group>
    <match>
        <ethernet-match>
            <ethernet-type>
                <type>2048</type>
            </ethernet-type>
        </ethernet-match>
        <ipv4-destination>10.0.0.1/24</ipv4-destination>
    </match>
    <hard-timeout>0</hard-timeout>
    <cookie>10</cookie>
    <idle-timeout>0</idle-timeout>
    <flow-name>FooXf22</flow-name>
    <priority>2</priority>
    <barrier>false</barrier>
</flow>
</syntaxhighlight>
<br />
* HTTP response
<pre>
Status: 200 OK
</pre>
<br />
'''3. Show flow - check that ''strict'' is ''true'''''
* HTTP request
<pre>
Operation: GET
URI: http://192.168.11.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:1/table/2/flow/111
Accept: application/xml
</pre>
<br />
* HTTP response
<pre>
Status: 200 OK
</pre>
<syntaxhighlight lang="xml">
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<flow 
    xmlns="urn:opendaylight:flow:inventory">
    <strict>true</strict>
    <instructions>
        <instruction>
          	<order>1</order>
            <apply-actions>
                <action>
                  <order>1</order>
                    <flood-all-action/>
                </action>
            </apply-actions>
        </instruction>
    </instructions>
    <table_id>2</table_id>
    <id>111</id>
    <cookie_mask>10</cookie_mask>
    <out_port>10</out_port>
    <installHw>false</installHw>
    <out_group>2</out_group>
    <match>
        <ethernet-match>
            <ethernet-type>
                <type>2048</type>
            </ethernet-type>
        </ethernet-match>
        <ipv4-destination>10.0.0.1/24</ipv4-destination>
    </match>
    <hard-timeout>0</hard-timeout>
    <cookie>10</cookie>
    <idle-timeout>0</idle-timeout>
    <flow-name>FooXf22</flow-name>
    <priority>2</priority>
    <barrier>false</barrier>
</flow>
</syntaxhighlight>
<br />
'''4. Delete created flow'''
* HTTP request
<pre>
Operation: DELETE
URI: http://192.168.11.1:8080/restconf/config/opendaylight-inventory:nodes/node/openflow:1/table/2/flow/111
</pre>
<br />
* HTTP response
<pre>
Status: 200 OK
</pre>
