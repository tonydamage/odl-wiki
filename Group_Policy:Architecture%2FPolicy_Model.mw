== Overview ==
<onlyinclude>
The policy model is built around the idea of placing endpoints into groups that share the same semantics, and then defining what other groups those endpoints need to communicate, and then finally defining how these endpoints need to communicate.  In this way, we represent the requirements of the application and then force the infrastructure to figure out how to meet these requirements, rather than defining the policy in terms of the underlying infrastructure.
</onlyinclude>
== Policy Concepts ==
This section describes some of the most important concepts in the policy model.  See the next section on [[Group Policy:Architecture/Policy Model#Policy Resolution|Policy Resolution]] for a description of how these fit together to determine how to apply the policy to the network.

; Endpoint
: An ''endpoint'' is a specific device in the network.  It could be a VM interface, a physical interface, or other network device.  Endpoints are defined and assigned to endpoint groups though mechanisms that are not specified by the policy model (See [[Group Policy:Architecture/Endpoint Registry|Endpoint Registry]] for more information).  Endpoints can have associated ''conditions'' that are just labels that represent some potentially-transient status information about an endpoint.
; Endpoint Group
: ''Endpoint groups'' are sets of endpoints that share a common set of policies.  Endpoint can participate in ''contracts'' that determine the kind of communication that is allowed.  They also expose both ''requirements'' and ''capabilities'', which are labels that help to determine how contracts will be applied.  An endpoint group is allowed to specify a parent endpoint group from which it inherits.
; Contract
: ''Contracts'' determine which endpoints can communicate and in what way.  Contracts between pairs of endpoint groups are selected by the contract selectors defined by the endpoint group.  Contracts expose ''qualities,'' which are labels that can help endpoint groups to select contracts.  Once the contract is selected, contracts have ''clauses'' that can match against requirements and capabilities exposed by endpoint groups, as well as any conditions that may be set on endpoints, in order to activate ''subjects'' that can allow specific kinds of communication.  A contracts is allowed to specify a parent contract from which it inherits.
; Clause
: ''Clauses'' are defined as part of a ''contract''.  ''Clauses'' determine how a contract should be applied to particular endpoints and endpoint groups.  Clauses can match against requirements and capabilities  exposed by endpoint groups, as well as any conditions that may be set on endpoints.  Matching clauses define some set of ''subjects'' which can be applied to the communication between the pairs of endpoints.
; Subject
: ''Subjects'' describe some aspect of how two endpoints are allowed to communicate.  Subjects define an ordered list of rules that will match against the traffic and perform any necessary actions on that traffic.  No communication is allowed unless a subject allows that communication.

== Policy Resolution ==
There are a lot of concepts to unpack and it can be difficult to see how this all fits together.  Let's imagine that we want to analyze a particular flow of traffic in the network and walk through the policy resolution process for that flow.

The key here is that the policy resolution process happens logically in multiple phases.  First, we need to select the contracts that are in scope for the endpoint groups of the endpoints of the flow.  Next, we select the set of subjects that apply to the endpoints of the flow.  Finally, we apply the rules from the applicable subjects to the actual network traffic in the flow.

=== Contract Selection ===
The first step in policy resolution is to select the contracts that are in scope.  For a particular flow, we look up the endpoint groups for each of the endpoints involved in the flow.

Endpoint groups participate in contracts either as a ''provider'' or as a ''consumer.''  Each endpoint group can participate in many contracts at the same time, but for each contract it can be in only one role at a time.  In addition, there are two ways for an endpoint group to select a contract: either with a ''named selector'' or with a ''target selector.''  Named selectors simply select a specific contract by its contract ID.  Target selectors allow for additional flexibility be matching against ''qualities'' of the contract's ''target.''

Thus, there are a total of 4 kinds of contract selector:
; provider named selector 
: Select a contract by contract ID, and participate as a provider.
; provider target selector
: Match against a contract's target with a quality matcher, and participate as a provider.
; consumer named selector
: Select a contract by contract ID, and participate as a consumer.
; consumer target selector
: Match against a contract's target with a quality matcher, and participate as a consumer.

So to determine which contracts are in scope for our flow, we must find contracts where either the source endpoint group selects a contract as either a provider or consumer, while the destination endpoint group matches against the same contract in the corresponding role.  So if endpoint ''x'' in endpoint group ''X'' is communicating with endpoint ''y'' in endpoint group ''Y'', a contract ''C'' is in scope if either ''X'' selects ''C'' as a provider and ''Y'' selects ''C'' as a consumer, or ''X'' selects ''C'' as a consumer and ''Y'' selects ''C'' as a provider.

==== Quality Matchers ====

==== Inheritance ====

=== Subject Selection ===
When acting as a provider, endpoint groups expose ''capabilities,'' which are specific pieces of functionality that can be exposed to other endpoint groups that may meet functional requirements of those endpoint groups.  When acting as a consumer, endpoint groups expose ''requirements''

==== Requirements and Capabilities ====

==== Conditions ====

==== Inheritance ====

=== Rule Application ===

==== Classifiers ====

==== Actions ====

==== Inheritance and Priority Resolution ====
