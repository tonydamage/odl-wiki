== Overview ==
<onlyinclude>
The policy model is built around the idea of placing endpoints into groups that share the same semantics, and then defining what other groups those endpoints need to communicate, and then finally defining how these endpoints need to communicate.  In this way, we represent the requirements of the application and then force the infrastructure to figure out how to meet these requirements, rather than defining the policy in terms of the underlying infrastructure.
</onlyinclude>
== Policy Concepts ==
This section describes some of the most important concepts in the policy model.  See the next section on [[Group Policy:Architecture/Policy Model#Policy Resolution|Policy Resolution]] for a description of how these fit together to determine how to apply the policy to the network.

; Endpoint
: An ''endpoint'' is a specific device in the network.  It could be a VM interface, a physical interface, or other network device.  Endpoints are defined and assigned to endpoint groups though mechanisms that are not specified by the policy model (See [[Group Policy:Architecture/Endpoint Registry|Endpoint Registry]] for more information).  Endpoints can have associated ''conditions'' that are just labels that represent some potentially-transient status information about an endpoint.
; Endpoint Group
: ''Endpoint groups'' are sets of endpoints that share a common set of policies.  Endpoint can participate in ''contracts'' that determine the kind of communication that is allowed.  They also expose both ''requirements'' and ''capabilities'', which are labels that help to determine how contracts will be applied.  An endpoint group is allowed to specify a parent endpoint group from which it inherits.
; Contract
: ''Contracts'' determine which endpoints can communicate and in what way.  Contracts between pairs of endpoint groups are selected by the contract selectors defined by the endpoint group.  Contracts expose ''qualities,'' which are labels that can help endpoint groups to select contracts.  Once the contract is selected, contracts have ''clauses'' that can match against requirements and capabilities exposed by endpoint groups, as well as any conditions that may be set on endpoints, in order to activate ''subjects'' that can allow specific kinds of communication.  A contracts is allowed to specify a parent contract from which it inherits.
; Clause
: ''Clauses'' are defined as part of a ''contract''.  ''Clauses'' determine how a contract should be applied to particular endpoints and endpoint groups.  Clauses can match against requirements and capabilities  exposed by endpoint groups, as well as any conditions that may be set on endpoints.  Matching clauses define some set of ''subjects'' which can be applied to the communication between the pairs of endpoints.
; Subject
: ''Subjects'' describe some aspect of how two endpoints are allowed to communicate.  Subjects define an ordered list of rules that will match against the traffic and perform any necessary actions on that traffic.  No communication is allowed unless a subject allows that communication.

== Policy Resolution ==
There are a lot of concepts to unpack and it can be difficult to see how this all fits together.  Let's imagine that we want to analyze a particular flow of traffic in the network and walk through the policy resolution process for that flow.  The key here is that the policy resolution process happens logically in multiple phases.  First, we need to select the contracts that are in scope for the endpoint groups of the endpoints of the flow.  Next, we select the set of subjects that apply to the endpoints of the flow.  Finally, we apply the rules from the applicable subjects to the actual network traffic in the flow.

=== Contract Selection ===
The first step in policy resolution is to select the contracts that are in scope.  For a particular flow, we look up the endpoint groups for each of the endpoints involved in the flow.

Endpoint groups participate in contracts either as a ''provider'' or as a ''consumer.''  Each endpoint group can participate in many contracts at the same time, but for each contract it can be in only one role at a time.  In addition, there are two ways for an endpoint group to select a contract: either with a ''named selector'' or with a ''target selector.''  Named selectors simply select a specific contract by its contract ID.  Target selectors allow for additional flexibility be matching against ''qualities'' of the contract's ''target.''

Thus, there are a total of 4 kinds of contract selector:
; provider named selector 
: Select a contract by contract ID, and participate as a provider.
; provider target selector
: Match against a contract's target with a quality matcher, and participate as a provider.
; consumer named selector
: Select a contract by contract ID, and participate as a consumer.
; consumer target selector
: Match against a contract's target with a quality matcher, and participate as a consumer.

So to determine which contracts are in scope for our flow, we must find contracts where either the source endpoint group selects a contract as either a provider or consumer, while the destination endpoint group matches against the same contract in the corresponding role.  So if endpoint ''x'' in endpoint group ''X'' is communicating with endpoint ''y'' in endpoint group ''Y'', a contract ''C'' is in scope if either ''X'' selects ''C'' as a provider and ''Y'' selects ''C'' as a consumer, or ''X'' selects ''C'' as a consumer and ''Y'' selects ''C'' as a provider.

The details of how quality matchers work are described further below in [[Group Policy:Architecture/Policy Model#Matchers|Matchers]].  For now, we can simply state that quality matchers provide a flexible mechanism for selecting the contract based on labels.

The end result of the contract selection phase can be thought of as a set of tuples representing selected contract scopes.  The fields of the tuple are:
* Contract ID
* The provider endpoint group ID
* The name of the selector in the provider endpoint group that was used to select the contract
* The consumer endpoint group ID
* The name of the selector in the consumer endpoint group that was used to select the contract

=== Subject Selection ===
The second phase in policy resolution is to determine which subjects are in scope.  The subjects allow us to define what kinds of communication are allowed between endpoints in the endpoint groups.  For each of the selected contract scopes from the contract selection phase, we'll need to apply the subject selection procedure.

Before we can discuss how the subjects are matched, we need to first examine what we match against to bring those subjects into scope.  We match against labels called, capabilities, requirements and conditions.  Endpoint groups have capabilities and requirements, while endpoints have conditions.

==== Requirements and Capabilities ====
When acting as a provider, endpoint groups expose ''capabilities,'' which are labels representing specific pieces of functionality that can be exposed to other endpoint groups that may meet functional requirements of those endpoint groups.  When acting as a consumer, endpoint groups expose ''requirements'', which are labels that represent that fact that the endpoint group requires some specific piece of functionality.    As an example, we might create a capability called "user-database" which indicates that an endpoint group contains endpoints that implement a database of users.  We might create a requirement also called "user-database" to indicate an endpoint group contains endpoints that will need to communicate with the endpoints that expose this service.  Note that in this example the requirement and capability have the same name, but the user need not follow this convention.

We examine the provider selector that was used by the provider endpoint group to select the contract to determine the capabilities exposed by the provider endpoint group for this contract scope.  The provider selector will have a list of capabilities either directly included in the provider selector or inherited from a parent selector or parent endpoint group (See [[Group Policy:Architecture/Policy Model#Inheritance|Inheritance]] below).  Similarly, the consumer selector will expose a set of requirements.

==== Conditions ====
Endpoints can have ''conditions'', which are labels representing some relevant piece of operational state related to the endpoint.  An example of a condition might be "malware-detected," or "authentication-succeeded."  We'll be able to use these conditions to affect how that particular endpoint can communicate.  To continue with our example, the "malware-detected" condition might cause an endpoints connectivity to be cut off, while "authentication-succeeded" might open up communication with services that require an endpoint to be first authenticate and then forward its authentication credentials.

Conditions do not actually appear in the policy configuration model other than as a named reference.  To determine the set of conditions that apply to a particular endpoint, the endpoint will need to be looked up in the endpoint registry, and it associated condition labels retrieved from there.

==== Clauses ====
Clauses are what will do the actual selection of subjects.  A clause has four component matchers.  In order for a clause to match against a subject, all four component matchers must match.  The components are:
TODO

=== Rule Application ===

==== Priority Resolution ====

== Matchers ==

Matchers have been mentioned a few times now without explaining what they are.  ''Quality matchers'' are an advanced way of selecting contracts from an endpoint by matching against labels on the contracts called ''qualities''.

Here are the fields in a quality matcher:
; id
: A UUID
; list of matcher-quality
: list of quality labels along with namespace and inheritance rules
; parent
: an optional reference to a quality matcher ID from which we inherit

A matcher quality has the following fields:
; name
: The name of the quality to match
; description
: A human-readable description field for the user to fill in
; inclusion-rule
: Either "include" or "exclude"; set to exclude to cause this label to be ignored when it might otherwise have been inherited from a parent
; target-name
: Narrow the match to include only targets with the given name.  If no name is indicated and name-inheritance is set to '
; name-inheritance 
: Determines how names are inherited by matchers.  Names are used by matchers to narrow the scope of labels against which they match to only particular targets or selectors.  Either "inherit", or "specified."

A contract contains ''targets'' that are just collections of qualities.  The quality matcher is actually matching against these targets.  The name of each target represents a namespace for the qualities contained within it.  Each quality matcher contains a list of qualities to match along with a target namespace for each quality.  

== Subject Features

=== Classifiers ===

=== Actions ===


== Inheritance ==

=== Contracts ===

=== Endpoint Groups ===

=== Matchers ===

=== Subject Feature Definitions ===
