=Current Status=
Currently there is a dirty fix (https://git.opendaylight.org/gerrit/#/c/5001/) prepared, where we 
* Remove all flows from switch upon switch reconnection
* Remove all flows from datastore upon switch disconnection

This is generally bad strategy, because
* We will immediately lose statistics data
* We wont be able to configure switch via alternative way (e.g.: different controller)
* In case of short term connection outage switch will need to configure again
* Only code in application space is supposed to write to config context of datastore

This issue is covered by [https://bugs.opendaylight.org/show_bug.cgi?id=375 BUG 375].

=Ideas on How to Handle Situations=

== Switch Gets Disconnected ==
* Let's not remove the node from operational neither config context of datastore (statistics will remain accessible, installed flows can be inspected)
* Adding flag to flowCapableNode augmentation in operational context indicating if the node is available could solve some underlying issues:
** FRM and other components working with operational context will recognize if node is gone and wont try to invoke related rpcs
** Statistics requests will skip such a node
** New rpc can be exposed to application having all (or one particular) unavailable nodes removed from operational context
* open question: we probably need to adjust topology and cope with LLDP discovery
*: <font color="green">Update:</font> LLDP packet sending mechanism will stop querying disconnected nodes (upon nodeUpdated event). And so the LLDP listening stuff and topology manager will cope with new status automatically.

== Switch Gets Reconnected ==
=== BLOCKER ===
Flows on switch do not contain id nor name as used inside controller. Meters and groups contain id on switch. So at least by flow we need a reliable compare code in order to merge flows right. 
Here are some other potentional problems:
* masks - bites outside mask are cleared by ovs, but not by cpqd
* flow flags - at least some of them seem to be ignored by cpqd
* flow id - if existed on device, generated id is used on controller side (#UF$TABLE*42*1)
*: <font color="green">Update:</font> For flow identification '''cookie field''' should be used (this is the purpose of cookie on flow).

=== DataStore does not contain any related items ===
* We will fill up operational context through pulling stats (if the switch contains any flows/meters/groups)
* App might decide to purge all the switch content
** This could be managed by new configuration item or by providing rpc to app for that goal (I vote for rpc)
* Or app might want to adopt those data into config context (e.g.: to be able to modify them)
** Again -> through configuration or via rpc (I vote for rpc)
* Node in operational context can exist (and harvest stats data..) with or without being reflected by config context


=== DataStore Contains Related Items ===
After we pulled stats, there will be up-to-date operational context.
Now there is new problem (except adopting) - merging config context with operational:
* App might (or is expected to) decide to push all stuff from config into switch
** Rpc/configuration item (I vote for configuration)
** This should either wait till operational context is completed
** Or start pushing and rely on switch to properly handle duplicate flows or updates
* Here we might encounter errors and have to decide if the not applicable flows should be removed or kept in config context
** Controlled by configuration item
** App will be able to detect anytime if some config data are not propagated into device by comparing them with operational context
*** by rpc (on demand)
* Now we might have some data in operational context not reflected in config - here the adopting can by applied (as mentioned before)
* App might decide to push flows from config into device again later (after adopting operational stuff to config context and altering it)
** by rpc (on demand)
