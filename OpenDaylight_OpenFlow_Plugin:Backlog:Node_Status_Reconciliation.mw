=Prepared Status=
https://git.opendaylight.org/gerrit/#/c/8174/

https://git.opendaylight.org/gerrit/#/c/8175/
* all flows,groups,meters added before a device connection are pre-configuration and those are saved in the Configuration Data Store only
* all pre-config node flows,groups,meters from the Configuration Data Store are commited to a device after connection/reconnection 
* all device flows,groups,meters are added to the Operational Data Store after connection/reconnection
* all flows,groups,meters are deleted from the Operational Data Store but the Configuration Data Store contains all configured flows,groups,meters

Flow ID in Flow Statistics and Flow Cookies
* The flow_id is not supported from device, so we are using cookies marker for flow
* The Configuration Data Store contains always "user defined cookies"
* We are replace "user defined cookies" in FRM to new cookies and add twins cookie (as a key) and List<FlowId> (as a list of IDs)
** We are using LIST because the operations (as sal-flow:add-flow) could add new flow without ID (without FRM) and the system generate some system alien ID (with prefix #UF$TABLE*)
** In general, we are expect only one "user defined flow ID" for one "flow cookie" and possible zero or more system alien IDs
** We have FlowCookiesMap<FlowCookie, List<FlowId>> in the node table hierarchy for the Operational Data Store
*** FlowCookiesMap removes after disconnect
*** List<FlowId> could contain only one "user defined flow_id" and zero or more system alien IDs

=Current Status=
Currently there is a dirty fix (https://git.opendaylight.org/gerrit/#/c/5001/) prepared, where we 
* Remove all flows from switch upon switch reconnection
* Remove all flows from datastore upon switch disconnection

This is generally bad strategy, because
* We will immediately lose statistics data
* We wont be able to configure switch via alternative way (e.g.: different controller)
* In case of short term connection outage switch will need to configure again
* Only code in application space is supposed to write to config context of datastore

This issue is covered by [https://bugs.opendaylight.org/show_bug.cgi?id=375 BUG 375], [https://bugs.opendaylight.org/show_bug.cgi?id=537 BUG 537].

=Ideas on How to Handle Situations=

== Switch Gets Disconnected ==
* Let's not remove the node from operational neither config context of datastore (statistics will remain accessible, installed flows can be inspected)
* Adding flag to flowCapableNode augmentation in operational context indicating if the node is available could solve some underlying issues:
** FRM and other components working with operational context will recognize if node is gone and wont try to invoke related rpcs
** Statistics requests will skip such a node
** New rpc can be exposed to application having all (or one particular) unavailable nodes removed from operational context
* open question: we probably need to adjust topology and cope with LLDP discovery
*: <font color="green">Update:</font> LLDP packet sending mechanism will stop querying disconnected nodes (upon nodeUpdated event). And so the LLDP listening stuff and topology manager will cope with new status automatically.

== Switch Gets Reconnected ==
=== BLOCKER ===
Flows on switch do not contain id nor name as used inside controller. Meters and groups contain id on switch. So at least by flow we need a reliable compare code in order to merge flows right. 
Here are some other potentional problems:
* masks - bites outside mask are cleared by ovs, but not by cpqd
* flow flags - at least some of them seem to be ignored by cpqd
* flow id - if existed on device, generated id is used on controller side (#UF$TABLE*42*1)
*: <font color="green">Update:</font> For flow identification '''cookie field''' should be used (this is the purpose of cookie on flow).

=== DataStore does not contain any related items ===
* We will fill up operational context through pulling stats (if the switch contains any flows/meters/groups)
* App might decide to purge all the switch content
** This could be managed by new configuration item or by providing rpc to app for that goal (I vote for rpc)
**: <font color="green">Update:</font> having multiple apps attached to controller it is probably safer to use configuration
* Or app might want to adopt those data into config context (e.g.: to be able to modify them)
** Again -> through configuration or via rpc (I vote for rpc)
**: <font color="green">Update:</font> having multiple apps attached to controller it is probably safer to use configuration
* Node in operational context can exist (and harvest stats data..) with or without being reflected by config context

=== DataStore Contains Related Items ===
After we pulled stats, there will be up-to-date operational context.
Now there is new problem (except adopting) - merging config context with operational:
* App might (or is expected to) decide to push all stuff from config into switch
** Rpc/configuration item (I vote for configuration)
**: <font color="green">Update:</font> having multiple apps attached to controller it is probably safer to use configuration
** This should either wait till operational context is completed
** Or start pushing and rely on switch to properly handle duplicate flows or updates
* Here we might encounter errors and have to decide if the not applicable flows should be removed or kept in config context
** Controlled by configuration item
**: <font color="green">Update:</font> having multiple apps attached to controller it is probably safer to use configuration
** App will be able to detect anytime if some config data are not propagated into device by comparing them with operational context
*** by rpc (on demand)
* Now we might have some data in operational context not reflected in config - here the adopting can by applied (as mentioned before)
* App might decide to push flows from config into device again later (after adopting operational stuff to config context and altering it)
** by rpc (on demand)
**: <font color="green">Update:</font> having multiple apps attached to controller it is probably safer to use configuration

=== Configuration note ===
Most of the values required from configuration can be in form of time-to-wait and then perform corresponding operation:
* '''purge switch content''' upon connection established
* '''adopt switch content''' to config context upon connection established
* '''push config content''' to switch upon connection established
* '''purge not appliable items''' from config context upon connection established
* '''retry to push config content''' to switch if primary push fails

Some of those are conflicting. In case that the switch gets disconnected again then all waiting operations should be cancelled.


=Completely different approach - allow inconsistency between operational and config by default=
We have already usecase covering preconfiguring flows, which means inconsistency untill device emerges.
Lets have the FRM removed from commitHandlers and make it listen to dataChange in config and operational context of dataStore. And also flows managed by controller/FRM will have cookie field filled and timeouts set to 0 (never expires). Following scenarios would arise.

== Application writes a flow into config ==
FRM gets notified upon data changed. 
* if there is corresponding device connected, FRM will push flow and statistic harvester mechanizm will deliver result into operational context
* if there is no device - no action

In case of update or removal FRM behaves the same.

== Device appears in operational context ==
FRM gets notified upon data changed. Here FRM could probably wait a few seconds till underlying items get into operational via stats harvest.
* if there is underlying flow in config, FRM will push it to device.

== Flow appears in operational context ==
FRM gets notified upon data changed.
* if there is cookie present, FRM will look up corresponding flow in config and:
** if not found - remove it from device
** if found - do nothing / update if different (might be configurable)
* no cookie means the flow is not managed by controller and wont be touched by FRM

== Flow/device disappears from operational ==
FRM gets notified upon data changed. No action.

== Unmanaged flows ==
Flows can be pushed to device via restconf by directly invoking SalFlowService, and also removed and updated this way. Those flows are expected to have timeouts specified and no cookies (eventuall collissions with cookies of managed flows will result into update, removal or keeping the flow).

== Remaining issues ==
In case of device disconnection the corresponding operational context is suppossed to get cleared. But this context is build via statitics harvest so either the stats should be stored somewhere else or disconected devices might get an inactive flag. Or statistics will get lost together with device. But this is more related to statistic manager expected statistic lifecycle.

[[OpenDaylight_OpenFlow_Plugin:Backlog:FlowCookieLifecycle|FlowCookieLifecycle]]

Fail handling - in case the flow add/update/remove action fails, then FRM should try again after some timeout or end up with error log?

== Conclusion ==
Taking this approach most of the inconsistent situations have simple solution and preconfiguration will be supported too. Similar strategy can by applied by meters and groups with one difference - there is no problem with identification of items (only flows are missing unique id on device).
