Model-Driven SAL (MD-SAL) is set of infrastructure services aimed for providing common and generic
support to application and plugin developers.

MD-SAL currently provides infrastructure services for:

* Data Services
* RPC / Service routing
* Notification subscription and publish services

This common model-driven infrastructure allows developers of applications and plugins
to develop against an  API type of their choice (Java generated APIs, DOM APIs, REST APIs)
and have other API types provided automatically by the infrastructure.

The modelling language of choice for MD-SAL is YANG, which is IETF standard for modelling
network element configuration. Support for YANG is provided by YANGTools project
and their development tools.

== API Types ==

MD-SAL provides three API types:

 - Java generated APIs - these are for consumers and producers
 - DOM APIs - these are mostly used by infrastucture components and are usuful for XML-driven plugin and application types
 - REST APIs - [[OpenDaylight Controller:MD-SAL:Restconf|Restconf]] - these APIs are available to consumer type applications and provides access to RPC and data stores.

== Base YANG Concepts and their rendition in APIs ==

The most basic concepts in YANG modeling are:
* RPCs - remote procedure call - in MD-SAL this are used for any call / invocation which crosses plugin/module boundatories, is triggered by consumer and usually have return value
* Notifications - asynchronous events, published by components for listeners
* Configuration and Operational Data tree - Well-defined (by model) tree structure which represents operational state of components and system.
** Instance Identifier - path, which uniquelly identifies subtree in configuration / operational space. Most addressing of data is done by Instance Identifier.

=== RPC ===

In YANG, RPCs (Remote Procedure Calls) are used to model any procedure call implemented by a Provider (Server), which exposes functionality to Consumers (Clients).

In the MD-SAL terminology, the term 'RPC' is used to define the input and output for a procedure (function), which is to be provided by a Provider and adapted by the MD-SAL.

In context of the MD-SAL, there are three types of RPCs (RPC services):

* [[OpenDaylight Controller:MD-SAL:Service Types#Global Service|Global]] - one service instance (implementation) per controller container / mount point
* [[OpenDaylight Controller:MD-SAL:Service Types#Routed Service|Routed]] - multiple service instances (implementations) per controller container / mount point
* [[OpenDaylight Controller:MD-SAL:Service Types#Mounted Service|Mounted]] - multiple service instances, uniquely identified in the yang data tree.

=== Instance Identifier ===

The Instance Identifier is a unique identifier of an element (location) in the yang data tree; basically it is the '''path''' to the node that uniquely identifies all the node's parent nodes. For unique identification of list elements it is required to specify key values as well.

MD-SAL currently provides three different APIs to access data in the common data store:

* Binding APIs (Java generated DTOs)
* DOM APIs
* [[OpenDaylight_Controller:MD-SAL:Restconf|HTTP Restconf APIs]]
 
==== Example ====

Consider the following simple YANG model for inventory:

<pre>module inventory {
    namespace &quot;urn:opendaylight:inventory&quot;;
    prefix inv;
    revision &quot;2013-06-07&quot;;
    container nodes {
        list node {
            key &quot;id&quot;;
            leaf &quot;id&quot; {
                type &quot;string&quot;;
            }
        }
    }
}</pre>
And having one instance of node with name ''foo'';

Lets asume we want to create instance identifier for node foo, in following bindings/ formats:

<ul>
<li><p><b>YANG / XML / XPath version</b></p>
<pre>/inv:nodes/inv:node[id=&quot;foo&quot;]</pre></li>
<li><p><b>Binding Independent version (yang-data-api)</b></p>
<pre>import org.opendaylight.yang.common.QName;
import org.opendaylight.yang.data.api.InstanceIdentifier;

QName nodes = QName.create(&quot;urn:opendaylight:inventory&quot;,&quot;2013-06-07&quot;,&quot;nodes&quot;);
QName node = QName.create(nodes,&quot;nodes&quot;);
QName idName = QName.create(nodes,&quot;id&quot;);
InstanceIdentifier = InstanceIdentifier.builder()
    .node(nodes)
    .nodeWithKey(node,idName,&quot;foo&quot;)
    .toInstance();</pre>
<p>'''Note:''' Last call ''toInstance()'' does not return an instance of node, but Java version of Instance identifier which uniquely identifies node &quot;foo&quot;;</p></li>

<li><p><b>Binding-Aware version (generated APIs)</b></p>
<pre>import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.Nodes;
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.nodes.Node;
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.nodes.NodeKey;

import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;

InstanceIdentifier&lt;Node&gt; identifier = InstanceIdentifier.builder(Nodes.class).child(Node.class,new NodeKey(&quot;foo&quot;)).toInstance();
</pre>
<p>'''Note:''' Last call ''toInstance()'' does not return an instance of node, but Java version of Instance identifier of Instance identifier which uniquely identifies node &quot;foo&quot;;</p>
</li>
<li><p>'''HTTP Restconf APIs'''</p></li>
<pre>
http://localhost:8080/restconf/config/inventory:nodes/node/foo
</pre>
<p>'''Note:''' We assume that HTTP APIs are exposed on localhost, port 8080</p>
</li>
</ul>



=== Plugin Types === 

* [[OpenDaylight Controller:MD-SAL:Plugin Types |Plugin Types]]
* [[OpenDaylight Controller:MD-SAL:Southbound Plugin Development Guide|Southbound Plugin Development Guide]]
* [[OpenDaylight_Controller:MD-SAL:FAQ| Model-Driven SAL FAQ]]
* [[OpenDaylight_Controller:Config:Main| Controller Configuration Subsystem]]
* [[OpenDaylight_Controller:Config:Model Reference| OpenDaylight Model Reference]]
