= Sample maven project =

Goal of this document is to describe a proposed shim layer over the MD-SAL config subsystem that makes it easy for Java based MD-SAL consumers/producers to use the config subsystem. Instead of having to create several YANG files and XML files with complex syntax, some simple annotations added to the Java source code will achieve majority of the same benefits. During build time, These annotations will be used to generate the same configuration files and used by the config subsystem. This new capability will be just a shim layer on top of the config subsystem. Anyone wanting to utilize the full flexibility and power of the config subsystem can continue to use it as is. 

Config subsystem provides three important capabilities to a MD-SAL Producer/Consumer.

* Declaring an MD-SAL Service and mapping it to a Java Interface
* Declaring the dependencies of this service on other services
* Defining  the configuration knobs exposed by this service

In this example, we will create a maven project that will provide 2 modules each implementing one service. We will design a simple configuration as well as runtime data for each module using yang. <br />
For this demo, we created a sample maven project called config-demo. This project contains 2 Java interfaces: Foo and Bar with one default implementation per interface: FooImpl and BarImpl. Bar is the producer in our example and produces integers when method getNextEvent() is called. Foo is the consumer and its implementation depends on a Bar instance. Both implementations require some configuration that is injected via constructors. <br/> 
* Bar.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public interface Bar {

    int getNextEvent();

}
</source>
* BarImpl.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public class BarImpl implements Bar {

    private final int l1, l2;
    private final boolean b;

    public BarImpl(int l1, int l2, boolean b) {
        this.l1 = l1;
        this.currentL = l1;
        this.l2 = l2;
        this.b = b;
    }

    private int currentL;

    @Override
    public int getNextEvent() {
        if(currentL==l2)
            return -1;
        return currentL++;
    }
}
</source>

* Foo.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public interface Foo {

    int getEventCount();
}
</source>
* FooImpl.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public class FooImpl implements Foo {

    private final String strAttribute;
    private final Bar barDependency;
    private final int intAttribute;

    public FooImpl(String strAttribute, int intAttribute, Bar barDependency) {
        this.strAttribute = strAttribute;
        this.barDependency = barDependency;
        this.intAttribute = intAttribute;
    }

    @Override
    public int getEventCount() {
        int count = 0;
        while(barDependency.getNextEvent() != intAttribute) {
            count++;
        }
        return count;
    }
}
</source>
* pom.xml (config-demo project is defined as a sub-module of the controller project and at this point contains only configuration for maven-bundle-plugin):
<source lang='xml'>
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <artifactId>commons.opendaylight</artifactId>
        <groupId>org.opendaylight.controller</groupId>
        <version>1.4.1-SNAPSHOT</version>
        <relativePath>../commons/opendaylight/pom.xml</relativePath>
    </parent>
    <groupId>org.opendaylight.controller</groupId>
    <version>0.1.1-SNAPSHOT</version>
    <artifactId>config-demo</artifactId>
    <packaging>bundle</packaging>
    <name>${project.artifactId}</name>
    <prerequisites>
        <maven>3.0.4</maven>
    </prerequisites>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.felix</groupId>
                <artifactId>maven-bundle-plugin</artifactId>
                <version>2.4.0</version>
                <extensions>true</extensions>
                <configuration>
                    <instructions>
                        <Bundle-Name>${project.groupId}.${project.artifactId}</Bundle-Name>
                        <Export-Package>
                            org.opendaylight.controller.config.demo,
                        </Export-Package>
                    </instructions>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
</source>
== Describing module configuration using yang ==
In order to fully leverage the utilities of configuration subsystem, we need to describe services, modules, their configuration and runtime state using yang modeling language. We will define 2 services and 2 modules, which will be used to configure instances of FooImpl and BarImpl. This definition will be split into 2 yang files: config-demo.yang (service definition) and config-demo-impl.yang (module definition).
* config-demo.yang
<source>
module config-demo {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:demo";
    prefix "demo";

    import config { prefix config; revision-date 2013-04-05; }

    description
        "Service definition for config-demo";

    revision "2013-10-14" {
        description
            "Initial revision";
    }

    // Service definition for service foo that encapsulates instances of org.opendaylight.controller.config.demo.Foo
    identity foo {
        description
            "Foo service definition";

        base "config:service-type";
        config:java-class "org.opendaylight.controller.config.demo.Foo";
    }

    identity bar {
        description
            "Bar service definition";

        base "config:service-type";
        config:java-class "org.opendaylight.controller.config.demo.Bar";
    }
}
</source>
As you can see, the config yang module needs to be imported in order to define services. There are 2 services defined and these services correspond to Java interfaces Foo and Bar (specified by config:java-class extension).
* config-demo-impl.yang
<source>
module config-demo-impl {

    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:demo:java";
    prefix "demo-java";

    // Dependency on service definition for config-demo
    /* Service definitions could be also located in this yang file or even
     * in a separate maven project that is marked as maven dependency
     */
    import config-demo { prefix demo; revision-date 2013-10-14;}

    // Dependencies on config subsystem definition
    import config { prefix config; revision-date 2013-04-05; }
    import rpc-context { prefix rpcx; revision-date 2013-06-17; }


    description
        "Service implementation for config-demo";

    revision "2013-10-14" {
        description
            "Initial revision";
    }
                                                                      //----- module foo-impl ----- //
    // Module implementing foo service                                                              //
    identity foo-impl {                                                                             //
        base config:module-type;                                                                    //
        config:provided-service demo:foo;                                                           //
        config:java-name-prefix FooImpl;                                                            //
    }                                                                                               //
                                                                                                    //
    // Configuration for foo-impl module                                                            //
    augment "/config:modules/config:module/config:configuration" {                                  //
        case foo-impl {                                                                             //
            when "/config:modules/config:module/config:type = 'foo-impl'";                          //
                                                                                                    //
            leaf str-attribute {                                                                    //
                type string;                                                                        //
            }                                                                                       //
                                                                                                    //
            leaf int-attribute {                                                                    //
                type int32;                                                                         //
            }                                                                                       //
                                                                                                    //
                                                                                                    //
            // Dependency on bar service instance                                                   //
            container bar-dependency {                                                              //
                uses config:service-ref {                                                           //
                    refine type {                                                                   //
                        mandatory true;                                                             //
                        config:required-identity demo:bar;                                          //
                    }                                                                               //
                }                                                                                   //
            }                                                                                       //
                                                                                                    //
        }                                                                                           //
    }                                                                                               //
                                                                                                    //
    // Runtime state definition for foo-impl module                                                 //
    augment "/config:modules/config:module/config:state" {                                          //
        case foo-impl {                                                                             //
            when "/config:modules/config:module/config:type = 'foo-impl'";                          //
                                                                                                    //
                                                                                                    //
        }                                                                                           //
    }                                                                                               //
                                                                                      // ---------- //
    // Module implementing bar service
    identity bar-impl {
        base config:module-type;
        config:provided-service demo:bar;
        config:java-name-prefix BarImpl;
    }

    augment "/config:modules/config:module/config:configuration" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

            container dto-attribute {
                leaf int-attribute {
                    type int32;
                }

                leaf int-attribute2 {
                    type int32;
                }

                leaf bool-attribute {
                    type boolean;
                }
            }

        }
    }

    augment "/config:modules/config:module/config:state" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

        }
    }

}
</source>
Again, config yang module as well as config-demo yang module need to be imported. There are 2 modules defined: foo-impl and bar-impl and their configuration (defined in augment "/config:modules/config:module/config:configuration" block) corresponds to the configuration of FooImpl and BarImpl Java classes. If we take a look at FooImpl.java's constructor, we can see that the configuration of foo-impl module defines similar 3 attributes. We will use these arguments to instantiate the FooImpl class. We placed these yang files under src/main/yang folder. </br>

== Updating maven configuration in pom.xml ==
Now we need to add yang-maven-plugin to our pom.xml. This plugin will process yang files and generate configuration code for the defined modules. Plugin's configuration:
<source lang='xml'>
<plugin>
    <groupId>org.opendaylight.yangtools</groupId>
    <artifactId>yang-maven-plugin</artifactId>
    <version>${yangtools.version}</version>
    <executions>
        <execution>
            <goals>
                <goal>generate-sources</goal>
            </goals>
            <configuration>
                <codeGenerators>
                    <generator>
                        <codeGeneratorClass>
                            org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
                        </codeGeneratorClass>
                        <outputBaseDir>${project.build.directory}/generated-sources/config</outputBaseDir>
                        <additionalConfiguration>
                            <namespaceToPackage1>
                                urn:opendaylight:params:xml:ns:yang:controller==org.opendaylight.controller.config.yang
                            </namespaceToPackage1>
                        </additionalConfiguration>
                    </generator>
                </codeGenerators>
                <inspectDependencies>true</inspectDependencies>
            </configuration>
        </execution>
    </executions>
    <dependencies>
        <dependency>
            <groupId>org.opendaylight.controller</groupId>
            <artifactId>yang-jmx-generator-plugin</artifactId>
            <version>${config.version}</version>
        </dependency>
    </dependencies>
</plugin>
</source>
Important configuration for the plugin is: output folder for generated files and mapping between yang namespaces and java packages (Inspect dependencies must be set to true ). The default location for yang files is under src/main/yang folder. This plugin is backed by artifact yang-jmx-generator-plugin and its class org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator is responsible for the code generation. This artifact is part of the configuration subsystem. <br/>

In addition to yang-maven-plugin, it is neccessary to add build-helper-maven-plugin in order to add generated sources to the build process:

 <plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>build-helper-maven-plugin</artifactId>
    <version>1.8</version>
    <executions>
        <execution>
            <id>add-source</id>
            <phase>generate-sources</phase>
            <goals>
                <goal>add-source</goal>
            </goals>
            <configuration>
                <sources>
                   &lt;source>${project.build.directory}/generated-sources/config&lt;/source>;
                </sources>
            </configuration>
        </execution>
    </executions>
 </plugin>

Earlier, we imported config yang module in our yang files. In order to acquire this yang module, we need to add dependency to the pom file:
<source lang='xml'>
<dependency>
    <groupId>org.opendaylight.controller</groupId>
    <artifactId>config-api</artifactId>
    <version>${config.version}</version>
</dependency>
</source>

We will also add a couple of utility dependencies:
<source lang='xml'>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
</dependency>
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
</dependency>
</source>

We are now ready to run '''mvn clean install'''.

== Generated java files ==
Now we can see a bunch of new source files divided into 2 groups. First group is located under ${project.build.directory}/generated-sources/config directory, which we specified in yang-maven-plugin's configuration. The second group is located under src/main/java directory. Both groups then define package org.opendaylight.controller.config.yang.config.demo.impl. The first group contains code that should not be edited in any way, since this code can be regenerated by the plugin if necessary. The code that needs to be edited belongs to the second group and is located under src/main/java. <br/>

=== Generated config source files examples ===
* BarImplModuleMXBean.java
<source lang='java'>
public interface BarImplModuleMXBean
{
    public org.opendaylight.controller.config.yang.config.demo.java.DtoAttribute getDtoAttribute();

    public void setDtoAttribute(org.opendaylight.controller.config.yang.config.demo.java.DtoAttribute dtoAttribute);

}
</source>
BarImplModuleMXBean interface represents getter and setter for dtoAttribute that will be exported to configuration registry via JMX. Attribute was defined in yang model - in this case it is composite type which was converted to OpenType.
*Attribute definition from config-demo-impl.yang
<source lang='java'>
    
    // Module implementing bar service
    identity bar-impl {
        base config:module-type;
        config:provided-service demo:foo;
        config:java-name-prefix BarImpl;
    }

    augment "/config:modules/config:module/config:configuration" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

            container dto-attribute {
                leaf int-attribute {
                    type int32;
                }

                leaf int-attribute2 {
                    type int32;
                }

                leaf bool-attribute {
                    type boolean;
                }
            }

        }
    }
</source>
From container dto-attribute, DtoAttribute java file was generated. Class contains plain constructor, getters and setters for attributes defined as container leaves.<br />
Not only ModuleMXBean is generated from this module definition, but also BarImplModuleFactory and BarImplModule stubs are generated (in fact AbstractBarImplModuleFactory and AbstractBarImplModule are generated too).

* AbstractBarImplModule.java
This abstract class is almost fully generated, only method validate() has empty body and method createInstance() is abstract. Both methods must be implemented by user, we will show it later. AbstractBarImplModule implements it's ModuleMXBean, Module, RuntimeBeanRegistratorAwareModule and dependent service interface as defined in yang. Moreover class contains two types of constructors - one for module created from old module instance and the second for module creation from scratch.

* AbstractBarImplModuleFactory.java
Unlike AbstractModule, AbstractFactory is fully generated, but still abstract class. The factory is responsible for module instances creation, provides two type of instantiateModule methods for both module constructor types. It implements ModuleFactory interface.

Next we will create runtime bean for FooImplModule. Runtime beans are designated to capture data about running module.
* Add runtime bean definition to config-demo-impl.yang
<source lang='java'>

</source>

=== Modifying generated sources ===
Generated source files:
* src/main/java/**/BarImplModule
* src/main/java/**/BarImplModuleFactory
* src/main/java/**/FooImplModule
* src/main/java/**/FooImplModuleFactory

'''BarImplModule'''<br />
We will start by modifying BarImplModule. You can see 2 constructors (not interesting at all) and 2 generated methods:
<source lang='java'>
    @Override
    public void validate(){
        super.validate();
        // Add custom validation for module attributes here.
    }

    @Override
    public java.lang.AutoCloseable createInstance() {
        //TODO:implement
        throw new java.lang.UnsupportedOperationException("Unimplemented stub method");
    }
</source>

In '''validate''', you can specify and validation for config attributes e.g.:
<source lang='java'>
    @Override
    public void validate(){
        super.validate();  
        Preconditions.checkNotNull(getDtoAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getBoolAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getIntAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getIntAttribute2());
        Preconditions.checkState(getDtoAttribute().getIntAttribute() > getDtoAttribute().getIntAttribute2());
    }
</source>

and in '''createInstance''' you need to create new instance of the bar service => Bar interface e.g.:
<source lang='java'>
        @Override
    public java.lang.AutoCloseable createInstance() {
        return new BarImpl(getDtoAttribute().getIntAttribute(), getDtoAttribute().getIntAttribute2(), getDtoAttribute()
                .getBoolAttribute());
    }
</source>
A few notes: 
* createInstance returns AutoCloseable so the returned type needs to implement it (you can make BarImpl implement AutoCloseable or create a Wrapper class around BarImpl instance that implements AutoCloseable or even extend BarImpl class and make it implement it),
* you can access all configuration attributes via getter methods, 
* in config-demo-impl.yang, we defined bar-impl's configuration as a container dto-attribute and the code generator create a transfer object DtoAttribute that you can access via getDtoAttribute() method and retrieve configuration data from it. You can even add new constructor to BarImpl that takes this transfer object and reduce the amount of arguments.

'''FooImplModule'''<br />
We will not add any custom validation in this module.
The '''createInstance''' method will look like:
<source lang='java'>
    @Override
    public java.lang.AutoCloseable createInstance() {
        return new FooImpl(getStrAttribute(), getIntAttribute(), getBarDependencyDependency());
    }
</source>

=== Adding support for default instances ===
In order to provide default instance of module bar-impl, we need to further modify generated code by overriding method ''getDefaultModules'' in ''src/main/java/**/BarImplModuleFactory'' class. The body of this class is empty so far and it inherits default behaviour from its parent abstract factory. We will replace empty body by this code:

<source lang='java'>
    public static final ModuleIdentifier defaultInstance1Id = new ModuleIdentifier(NAME, "defaultInstance1");

    @Override
    public Set<BarImplModule> getDefaultModules(DependencyResolverFactory dependencyResolverFactory, BundleContext bundleContext) {
        DependencyResolver depResolver1 = dependencyResolverFactory.createDependencyResolver(defaultInstance1Id);
        BarImplModule defaultModule1 = new BarImplModule(defaultInstance1Id, depResolver1);
        defaultModule1.setDtoAttribute(getDefaultConfiguration(bundleContext));

        return Sets.newHashSet(defaultModule1);
    }

    private DtoAttribute getDefaultConfiguration(BundleContext bundleContext) {
        DtoAttribute defaultConfiguration = new DtoAttribute();

        String property = bundleContext.getProperty("default.bool");
        defaultConfiguration.setBoolAttribute(property == null ? false : Boolean.parseBoolean(property));

        property = bundleContext.getProperty("default.int1");
        defaultConfiguration.setIntAttribute(property == null ? 55 : Integer.parseInt(property));

        property = bundleContext.getProperty("default.int2");
        defaultConfiguration.setIntAttribute2(property == null ? 0 : Integer.parseInt(property));

        return defaultConfiguration;
    }
</source>

The ''getDefaultModules'' method now produces an instance of bar-impl module with name ''defaultInstance1'' (it is possible to produce multiple default instances since the return type is a Set of module instances). Notice the ''getDefaultConfiguration'' method, it provides the default configuration for default instances by trying to retrieve system properties from bundleContext (or provides hardcoded values in case system property is not present).

For the controller distribution, system properties can be feeded via ''config.ini'' file.

Method ''getDefaultModules'' is called automatically after a bundle containing this factory is started in the OSGi environment. Its default implementation returns an empty Set.

Default instances approach is similar to the Activator class approach in OSGi with the advantage of default instances being managed by the configuration subsystem. This approach can replace Activator class approach or it can be used along with it.

==== Verifying default instances in distribution ====
If we add config-demo bundle to opendaylight's distribution, we can verify the presence of the default instance. File ''pom.xml'' under ''opendaylight/distribution/opendaylight'' folder needs to be modified by adding config-demo dependency:
<source lang='xml'>
<dependency>
    <groupId>${project.groupId}</groupId>
    <artifactId>config-demo</artifactId>
    <version>0.1.1-SNAPSHOT</version>
</dependency>
</source>

Now we need to rebuild the conf-demo module using mvn clean install. Then we can build the distribution using the same mvn command under ''opendaylight/distribution/opendaylight'' folder. Now if we head to ''opendaylight/distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight'' folder and execute ''run.sh'', the opendaylight distribution should start.

We can check the presence of default instances via JMX using tool such as ''jvisualvm'':
[[File:Default instance verify.PNG|frameless|center|jvisualvm showing the default instance of bar-impl module]]
