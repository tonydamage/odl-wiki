= Sample maven project =

Goal of this document is to describe a proposed shim layer over the MD-SAL config subsystem that makes it easy for Java based MD-SAL consumers/producers to use the config subsystem. Instead of having to create several YANG files and XML files with complex syntax, some simple annotations added to the Java source code will achieve majority of the same benefits. During build time, These annotations will be used to generate the same configuration files and used by the config subsystem. This new capability will be just a shim layer on top of the config subsystem. Anyone wanting to utilize the full flexibility and power of the config subsystem can continue to use it as is. 

Config subsystem provides three important capabilities to a MD-SAL Producer/Consumer.

* Declaring an MD-SAL Service and mapping it to a Java Interface
* Declaring the dependencies of this service on other services
* Defining  the configuration knobs exposed by this service

In this example, we will create a maven project that will provide 2 modules each implementing one service. We will design a simple configuration as well as runtime data for each module using yang. <br />
For this demo, we created a sample maven project called config-demo. This project contains 2 Java interfaces: Foo and Bar with one default implementation per interface: FooImpl and BarImpl. Bar is the producer in our example and produces integers when method getNextEvent() is called. Foo is the consumer and its implementation depends on a Bar instance. Both implementations require some configuration that is injected via constructors. <br/> 
* Bar.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public interface Bar {

    int getNextEvent();

}
</source>
* BarImpl.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public class BarImpl implements Bar {

    private final int l1, l2;
    private final boolean b;

    public BarImpl(int l1, int l2, boolean b) {
        this.l1 = l1;
        this.currentL = l1;
        this.l2 = l2;
        this.b = b;
    }

    private int currentL;

    @Override
    public int getNextEvent() {
        if(currentL==l2)
            return -1;
        return currentL++;
    }
}
</source>

* Foo.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public interface Foo {

    int getEventCount();
}
</source>
* FooImpl.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public class FooImpl implements Foo {

    private final String strAttribute;
    private final Bar barDependency;
    private final int intAttribute;

    public FooImpl(String strAttribute, int intAttribute, Bar barDependency) {
        this.strAttribute = strAttribute;
        this.barDependency = barDependency;
        this.intAttribute = intAttribute;
    }

    @Override
    public int getEventCount() {
        int count = 0;
        while(barDependency.getNextEvent() != intAttribute) {
            count++;
        }
        return count;
    }
}
</source>
* pom.xml (config-demo project is defined as a sub-module of the controller project and at this point contains only configuration for maven-bundle-plugin):
<source lang='xml'>
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <artifactId>commons.opendaylight</artifactId>
        <groupId>org.opendaylight.controller</groupId>
        <version>1.4.1-SNAPSHOT</version>
        <relativePath>../commons/opendaylight/pom.xml</relativePath>
    </parent>
    <groupId>org.opendaylight.controller</groupId>
    <version>0.1.1-SNAPSHOT</version>
    <artifactId>config-demo</artifactId>
    <packaging>bundle</packaging>
    <name>${project.artifactId}</name>
    <prerequisites>
        <maven>3.0.4</maven>
    </prerequisites>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.felix</groupId>
                <artifactId>maven-bundle-plugin</artifactId>
                <version>2.4.0</version>
                <extensions>true</extensions>
                <configuration>
                    <instructions>
                        <Bundle-Name>${project.groupId}.${project.artifactId}</Bundle-Name>
                        <Export-Package>
                            org.opendaylight.controller.config.demo,
                        </Export-Package>
                    </instructions>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
</source>
== Describing module configuration using annotations ==
In order to fully leverage the utilities of configuration subsystem, we need to describe services, modules, their configuration and runtime state. We will define 2 services and 2 modules, which will be used to configure instances of FooImpl and BarImpl. 

* Bar.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

@ServiceType(name="Bar", description="Bar Service Description")
public interface Bar {

    int getNextEvent();

}
</source>

* Foo.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

@ServiceType(name="Foo", "Foo Service Description")
public interface Foo {

    int getEventCount();
}
</source>

These two annotated Java files are equivalent to the config-demo.yang shown below and the YANG file can be automatically generated during build time  via custom annotation processor code.
* config-demo.yang
<source>
module config-demo {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:demo";
    prefix "demo";

    import config { prefix config; revision-date 2013-04-05; }

    description
        "Service definition for config-demo";

    revision "2013-10-14" {
        description
            "Initial revision";
    }

    // Service definition for service foo that encapsulates instances of org.opendaylight.controller.config.demo.Foo
    identity foo {
        description
            "Foo service definition";

        base "config:service-type";
        config:java-class "org.opendaylight.controller.config.demo.Foo";
    }

    identity bar {
        description
            "Bar service definition";

        base "config:service-type";
        config:java-class "org.opendaylight.controller.config.demo.Bar";
    }
}
</source>

Now  we need to  define service instances for the Foo and Bar Services and indicate their configuration variables and service dependencies.  This is accomplished by annotating the FooImpl.java and BarImpl.java.

* BarImpl.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

@ServiceInstance
public class BarImpl implements Bar {

    private final int l1, l2;
    private final boolean b;

@ServiceParams
    public BarImpl(int l1, int l2, boolean b) {
        this.l1 = l1;
        this.currentL = l1;
        this.l2 = l2;
        this.b = b;
    }

    private int currentL;

    @Override
    public int getNextEvent() {
        if(currentL==l2)
            return -1;
        return currentL++;
    }
}
</source>

* FooImpl.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

@ServiceInstance
public class FooImpl implements Foo {

    private final String strAttribute;
    private final Bar barDependency;
    private final int intAttribute;

@ServiceParams
    public FooImpl(String strAttribute, int intAttribute, Bar barDependency) {
        this.strAttribute = strAttribute;
        this.barDependency = barDependency;
        this.intAttribute = intAttribute;
    }

    @Override
    public int getEventCount() {
        int count = 0;
        while(barDependency.getNextEvent() != intAttribute) {
            count++;
        }
        return count;
    }
}
</source>

If we take a look at BarImpl constructor, we see that it requires two integer variables and a boolean variable. From the @ServiceParams constructor, we can automatically infer that and generate the configuration variables in the YANG Module. Similarly FooImpl.java constructor requires a string attribute and an int attribute. In addition, FooImpl declares a dependency on Bar Service. Again, These annotations are equivalent to the config-demo-impl.yang shown below. 

* config-demo-impl.yang
<source>
module config-demo-impl {

    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:demo:java";
    prefix "demo-java";

    // Dependency on service definition for config-demo
    /* Service definitions could be also located in this yang file or even
     * in a separate maven project that is marked as maven dependency
     */
    import config-demo { prefix demo; revision-date 2013-10-14;}

    // Dependencies on config subsystem definition
    import config { prefix config; revision-date 2013-04-05; }
    import rpc-context { prefix rpcx; revision-date 2013-06-17; }


    description
        "Service implementation for config-demo";

    revision "2013-10-14" {
        description
            "Initial revision";
    }
                                                                      //----- module foo-impl ----- //
    // Module implementing foo service                                                              //
    identity foo-impl {                                                                             //
        base config:module-type;                                                                    //
        config:provided-service demo:foo;                                                           //
        config:java-name-prefix FooImpl;                                                            //
    }                                                                                               //
                                                                                                    //
    // Configuration for foo-impl module                                                            //
    augment "/config:modules/config:module/config:configuration" {                                  //
        case foo-impl {                                                                             //
            when "/config:modules/config:module/config:type = 'foo-impl'";                          //
                                                                                                    //
            leaf str-attribute {                                                                    //
                type string;                                                                        //
            }                                                                                       //
                                                                                                    //
            leaf int-attribute {                                                                    //
                type int32;                                                                         //
            }                                                                                       //
                                                                                                    //
                                                                                                    //
            // Dependency on bar service instance                                                   //
            container bar-dependency {                                                              //
                uses config:service-ref {                                                           //
                    refine type {                                                                   //
                        mandatory true;                                                             //
                        config:required-identity demo:bar;                                          //
                    }                                                                               //
                }                                                                                   //
            }                                                                                       //
                                                                                                    //
        }                                                                                           //
    }                                                                                               //
                                                                                                    //
    // Runtime state definition for foo-impl module                                                 //
    augment "/config:modules/config:module/config:state" {                                          //
        case foo-impl {                                                                             //
            when "/config:modules/config:module/config:type = 'foo-impl'";                          //
                                                                                                    //
                                                                                                    //
        }                                                                                           //
    }                                                                                               //
                                                                                      // ---------- //
    // Module implementing bar service
    identity bar-impl {
        base config:module-type;
        config:provided-service demo:bar;
        config:java-name-prefix BarImpl;
    }

    augment "/config:modules/config:module/config:configuration" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

            container dto-attribute {
                leaf int-attribute {
                    type int32;
                }

                leaf int-attribute2 {
                    type int32;
                }

                leaf bool-attribute {
                    type boolean;
                }
            }

        }
    }

    augment "/config:modules/config:module/config:state" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

        }
    }

}
</source>

== Generated java files ==
Now we can see a bunch of new source files divided into 2 groups. First group is located under ${project.build.directory}/generated-sources/config directory, which we specified in yang-maven-plugin's configuration. The second group is located under src/main/java directory. Both groups then define package org.opendaylight.controller.config.yang.config.demo.impl. The first group contains code that should not be edited in any way, since this code can be regenerated by the plugin if necessary. The code that needs to be edited belongs to the second group and is located under src/main/java. <br/>

=== Generated config source files examples ===
* BarImplModuleMXBean.java
<source lang='java'>
public interface BarImplModuleMXBean
{
    public org.opendaylight.controller.config.yang.config.demo.java.DtoAttribute getDtoAttribute();

    public void setDtoAttribute(org.opendaylight.controller.config.yang.config.demo.java.DtoAttribute dtoAttribute);

}
</source>
BarImplModuleMXBean interface represents getter and setter for dtoAttribute that will be exported to configuration registry via JMX. Attribute was defined in the @ServiceParam annotation.

Not only ModuleMXBean is generated from this module definition, but also BarImplModuleFactory and BarImplModule stubs are generated (in fact AbstractBarImplModuleFactory and AbstractBarImplModule are generated too).

* AbstractBarImplModule.java
This abstract class is almost fully generated, only method validate() has empty body and method createInstance() is abstract. Both methods must be implemented by user, we will show it later. AbstractBarImplModule implements it's ModuleMXBean, Module, RuntimeBeanRegistratorAwareModule and dependent service interface as defined in yang. Moreover class contains two types of constructors - one for module created from old module instance and the second for module creation from scratch.

* AbstractBarImplModuleFactory.java
Unlike AbstractModule, AbstractFactory is fully generated, but still abstract class. The factory is responsible for module instances creation, provides two type of instantiateModule methods for both module constructor types. It implements ModuleFactory interface.

=== Modifying generated sources ===
Generated source files:
* src/main/java/**/BarImplModule
* src/main/java/**/BarImplModuleFactory
* src/main/java/**/FooImplModule
* src/main/java/**/FooImplModuleFactory

'''BarImplModule'''<br />
We will start by modifying BarImplModule. You can see 2 constructors (not interesting at all) and 2 generated methods:
<source lang='java'>
    @Override
    public void validate(){
        super.validate();
        // Add custom validation for module attributes here.
    }

    @Override
    public java.lang.AutoCloseable createInstance() {
        //TODO:implement
        throw new java.lang.UnsupportedOperationException("Unimplemented stub method");
    }
</source>

In '''validate''', you can specify and validation for config attributes e.g.:
<source lang='java'>
    @Override
    public void validate(){
        super.validate();  
        Preconditions.checkNotNull(getDtoAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getBoolAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getIntAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getIntAttribute2());
        Preconditions.checkState(getDtoAttribute().getIntAttribute() > getDtoAttribute().getIntAttribute2());
    }
</source>

and in '''createInstance''' you need to create new instance of the bar service => Bar interface e.g.:
<source lang='java'>
        @Override
    public java.lang.AutoCloseable createInstance() {
        return new BarImpl(getDtoAttribute().getIntAttribute(), getDtoAttribute().getIntAttribute2(), getDtoAttribute()
                .getBoolAttribute());
    }
</source>
A few notes: 
* createInstance returns AutoCloseable so the returned type needs to implement it (you can make BarImpl implement AutoCloseable or create a Wrapper class around BarImpl instance that implements AutoCloseable or even extend BarImpl class and make it implement it),
* you can access all configuration attributes via getter methods, 
* in config-demo-impl.yang, we defined bar-impl's configuration as a container dto-attribute and the code generator create a transfer object DtoAttribute that you can access via getDtoAttribute() method and retrieve configuration data from it. You can even add new constructor to BarImpl that takes this transfer object and reduce the amount of arguments.

'''FooImplModule'''<br />
We will not add any custom validation in this module.
The '''createInstance''' method will look like:
<source lang='java'>
    @Override
    public java.lang.AutoCloseable createInstance() {
        return new FooImpl(getStrAttribute(), getIntAttribute(), getBarDependencyDependency());
    }
</source>

=== Adding support for default instances ===
In order to provide default instance of module bar-impl, we need to further modify generated code by overriding method ''getDefaultModules'' in ''src/main/java/**/BarImplModuleFactory'' class. The body of this class is empty so far and it inherits default behaviour from its parent abstract factory. We will replace empty body by this code:

<source lang='java'>
    public static final ModuleIdentifier defaultInstance1Id = new ModuleIdentifier(NAME, "defaultInstance1");

    @Override
    public Set<BarImplModule> getDefaultModules(DependencyResolverFactory dependencyResolverFactory, BundleContext bundleContext) {
        DependencyResolver depResolver1 = dependencyResolverFactory.createDependencyResolver(defaultInstance1Id);
        BarImplModule defaultModule1 = new BarImplModule(defaultInstance1Id, depResolver1);
        defaultModule1.setDtoAttribute(getDefaultConfiguration(bundleContext));

        return Sets.newHashSet(defaultModule1);
    }

    private DtoAttribute getDefaultConfiguration(BundleContext bundleContext) {
        DtoAttribute defaultConfiguration = new DtoAttribute();

        String property = bundleContext.getProperty("default.bool");
        defaultConfiguration.setBoolAttribute(property == null ? false : Boolean.parseBoolean(property));

        property = bundleContext.getProperty("default.int1");
        defaultConfiguration.setIntAttribute(property == null ? 55 : Integer.parseInt(property));

        property = bundleContext.getProperty("default.int2");
        defaultConfiguration.setIntAttribute2(property == null ? 0 : Integer.parseInt(property));

        return defaultConfiguration;
    }
</source>

The ''getDefaultModules'' method now produces an instance of bar-impl module with name ''defaultInstance1'' (it is possible to produce multiple default instances since the return type is a Set of module instances). Notice the ''getDefaultConfiguration'' method, it provides the default configuration for default instances by trying to retrieve system properties from bundleContext (or provides hardcoded values in case system property is not present).

For the controller distribution, system properties can be feeded via ''config.ini'' file.

Method ''getDefaultModules'' is called automatically after a bundle containing this factory is started in the OSGi environment. Its default implementation returns an empty Set.

Default instances approach is similar to the Activator class approach in OSGi with the advantage of default instances being managed by the configuration subsystem. This approach can replace Activator class approach or it can be used along with it.

==== Verifying default instances in distribution ====
If we add config-demo bundle to opendaylight's distribution, we can verify the presence of the default instance. File ''pom.xml'' under ''opendaylight/distribution/opendaylight'' folder needs to be modified by adding config-demo dependency:
<source lang='xml'>
<dependency>
    <groupId>${project.groupId}</groupId>
    <artifactId>config-demo</artifactId>
    <version>0.1.1-SNAPSHOT</version>
</dependency>
</source>

Now we need to rebuild the conf-demo module using mvn clean install. Then we can build the distribution using the same mvn command under ''opendaylight/distribution/opendaylight'' folder. Now if we head to ''opendaylight/distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight'' folder and execute ''run.sh'', the opendaylight distribution should start.

We can check the presence of default instances via JMX using tool such as ''jvisualvm'':
[[File:Default instance verify.PNG|frameless|center|jvisualvm showing the default instance of bar-impl module]]
