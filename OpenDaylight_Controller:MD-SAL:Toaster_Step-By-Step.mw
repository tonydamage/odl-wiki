__TOC__

=Overview=
The following tutorial will breakdown the prebuilt Toaster sample and take you through the Toaster sample step by step as if re-creating it from scratch. We will start with simple definitions that enable access to the operational data only, and advance to the full-blown example that demonstrates many aspects of MD-SAL, including remote procedure calls via JMX and restconf, accessing state data via JMX, notifications and a consumer service. You may follow the steps by actually creating new projects and performing them or by simply reading through and also studying the prebuilt code. Either way, this exercise is useful in understanding in general what you need to do to build MD-SAL plugins from scratch and why.

''If you are looking for an overview of the prebuilt Toaster sample, along with discussions of how the classes interact with eachother, check out the [https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Toaster_Tutorial Toaster Tutorial]'''

'''NOTE: The follow documentation is a work in progress and may have embedded questions and answers. Look for QUESTION to find existing questions.'''

====Toaster Parts====
There are several parts that make up this toaster step-by-step example. During this example we illustrate how the yang model is providing abstraction for us, and how MD-SAL provides the plumbing (wiring) to hook everything up.

*'''Part 1''' of this example will define the toaster data model (north-bound interface) and will provide a read-only implementation to retrieve operational data on the toaster.
*'''Part 2''' will add and implement a remote procedure call which will allow the user to interact with the operations restconf interface, as well as see status changes to operational data.
*'''Part 3''' illustrates how a user can modify configuration data via restconf and how our toaster can listener for those changes.
*'''Part 4''' of this example will provide additional statistical attributes not present in the north bound interface, but available by the implementation via JMX.
*'''Part 5''' will introduce a KitchenService that is a consumer of the toaster model. This provides a demonstration of how other business intelligence in the controller can access the data models and invoke RPC calls for the purpose of providing additional business logic in the controller. 
*'''Part 6''' will expand our example by adding unsolicited notifications from the toaster provider and consumer that are routed through the MD-SAL .

= Part 1: Defining an Operational Toaster =

Part 1 of this tutorial will walk you through defining a data model which maps to a toaster, and a service that provides the operational data about the given toaster. The toaster model and service will be made up oftwo yang files, some new and modified java classes, and a number of auto-generated java files. Each yang file provides another level of abstraction between the north-bound client and the south-bound implementation. It is important to note that the MD-SAL is provides the plumbing while the yang data models provide the abstractions. 

#''toaster.yang'' - This file defines the north bound data model. Specifically, it defines the abstraction of a toaster that is visible to north-bound clients (e.g. the restconf API).
#''toaster-provider-impl.yang'' - This fine defines an implementation of the toaster service the services it needs from the MD-SAL framework, e.g. the data-broker, which is used to store the operational data of the toaster.

== Define the Toaster yang data model ==

The first yang file, ''toaster.yang'', defines the north bound abstraction of the toaster data model, specifically its attributes, RPCs and notifications, that can be accessed by north-bound clients (e.g. the restconf API). This file is located in the ''sample-toaster'' project under the ''src/main/yang source'' folder.

<pre>
  //This file contains a YANG data definition. This data model defines
  //a toaster, which is based on the SNMP MIB Toaster example 
  module toaster {

    //The yang version - today only 1 version exists. If omitted defaults to 1.
    yang-version 1; 

    //a unique namespace for this toaster module, to uniquely identify it from other modules that may have the same name.
    namespace
      "http://netconfcentral.org/ns/toaster"; 

    //a shorter prefix that represents the namespace for references used below
    prefix toast;

    //Defines the organization which defined / owns this .yang file.
    organization "Netconf Central";

    //defines the primary contact of this yang file.
    contact
      "Andy Bierman <andy@netconfcentral.org>";

    //provides a description of this .yang file.
    description
      "YANG version of the TOASTER-MIB.";

    //defines the dates of revisions for this yang file
    revision "2009-11-20" {
      description
        "Toaster module in progress.";
    }

    //declares a base identity, in this case a base type for different types of toast.
    identity toast-type {
      description
        "Base for all bread types supported by the toaster. New bread types not listed here nay be added in the future.";
    }

    //the below identity section is used to define globally unique identities
    //Note - removed a number of different types of bread to shorten the text length.
    identity white-bread {
      base toast:toast-type;       //logically extending the declared toast-type above.
      description "White bread.";  //free text description of this type.
    }

    identity wheat-bread {
      base toast-type;
      description "Wheat bread.";
    }

    //defines a new "Type" string type which limits the length
    typedef DisplayString {
      type string {
        length "0 .. 255";
      }
      description
        "YANG version of the SMIv2 DisplayString TEXTUAL-CONVENTION.";
      reference
        "RFC 2579, section 2.";

    }

    // This definition is the top-level configuration "item" that defines a toaster. The "presence" flag connotes there
    // can only be one instance of a toaster which, if present, indicates the service is available.
    container toaster {
      presence
        "Indicates the toaster service is available";
      description
        "Top-level container for all toaster database objects.";

      //Note in these three attributes that config = false. This indicates that these attributes are operational attributes, and are only 
      leaf toasterManufacturer {
        type DisplayString;
        config false;
        mandatory true;
        description
          "The name of the toaster's manufacturer. For instance, Microsoft Toaster.";
      }

      leaf toasterModelNumber {
        type DisplayString;
        config false;
        mandatory true;
        description
          "The name of the toaster's model. For instance, Radiant Automatic.";
      }

      leaf toasterStatus {
        type enumeration {
          enum "up" {
            value 1;
            description
              "The toaster knob position is up. No toast is being made now.";
          }
          enum "down" {
            value 2;
            description
              "The toaster knob position is down. Toast is being made now.";
          }
        }
        config false;
        mandatory true;
        description
          "This variable indicates the current state of  the toaster.";
      }
    }  // container toaster
  }  // module toaster

</pre>

You can see above that we marked all three of the leaf attributes on the toaster container as operational (''config false''), instead of configuration data. MD-SAL, along with some ietf drafts for restconf split the configuration and operational data into two separate data stores. 
* Operational - Operational data stores are used to show the running state (read only) view of the devices, network, services, etc that you might be looking at. In our case we have a service called toaster which is available - the manufacture, model and status of the toaster are all provided by the underlying toaster and can not be configured (later we will add a configuration attribute). Think of the first two attributes as constants which are hardcoded into the physical device, while the third is a representation of current state, and changes as the toaster is used.
* Config - Config data stores are generally used to configure the device in someway. These configurations are user provided and is a way for the user to tell the device how to behave. For example if you wanted to configure the resource in some way, such as applying a policy or other configuration then you would use this data store. We will add some configuration data in part 3 of this tutorial.

==Generate the Toaster yang data model source==
At this point we can compile the yang data model to generate the java source files. To do this, we need to specify the ''yang-maven-plugin'' in the pom.xml:
<code>
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"''
               xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  ...
  '''<build>
  '''  <plugins>
  '''    <plugin>
  '''      <groupId>org.opendaylight.yangtools</groupId>
  '''      <artifactId>yang-maven-plugin</artifactId>
  '''      <executions>
  '''        <execution>
  '''          <goals>
  '''            <goal>generate-sources</goal>
  '''          </goals>
  '''          <configuration>
  '''            <yangFilesRootDir>src/main/yang</yangFilesRootDir>
  '''            <codeGenerators>
  '''              <generator>
  '''                <codeGeneratorClass>org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl</codeGeneratorClass>
  '''                <outputBaseDir>${salGeneratorPath}</outputBaseDir>
  '''              </generator>
  '''            </codeGenerators>
  '''            <inspectDependencies>true</inspectDependencies>
  '''          </configuration>
  '''        </execution>
  '''      </executions>
  '''      <dependencies>
  '''        <dependency>
  '''          <groupId>org.opendaylight.yangtools</groupId>
  '''          <artifactId>maven-sal-api-gen-plugin</artifactId>
  '''          <version>${yangtools.version}</version>
  '''          <type>jar</type>
  '''        </dependency>
  '''      </dependencies>
  '''    </plugin>
  '''  </plugins>
  '''</build>
    
  '''<dependencies>
  '''  <dependency>
  '''    <groupId>org.opendaylight.yangtools</groupId>
  '''    <artifactId>yang-binding</artifactId>
  '''  </dependency>
  '''  <dependency>
  '''    <groupId>org.opendaylight.controller</groupId>
  '''    <artifactId>sal-common-util</artifactId>
  '''  </dependency>
  '''  <dependency>
  '''    <groupId>org.opendaylight.yangtools</groupId>
  '''    <artifactId>yang-common</artifactId>
  '''  </dependency>
  '''</dependencies>
  ...
 </project>
</code>

The ''yang-maven-plugin'' is used to generate java source from yang definition files. Much of the plugin's configuration is boilerplate. Tags of specific interest:

* '''yangFilesRootDir''' - specifies the directory under the project to locate yang files to process. This defaults to src/main/yang.
* '''codeGeneratorClass''' - specifies the code generator to use.  CodeGeneratorImpl is used to generate classes that represent the yang data model components.
* '''outputBaseDir''' - specifies the output directory for the generated classes. In the controller project we specify the ${salGeneratorPath} property which is defined in the root pom as src/main/yang-gen-sal. 

Next, run:
<pre>mvn clean install</pre>
''Note: You really only need to run 'mvn install' here since we have nothing to clean, but running a clean will not harm anything and is a good practice to ensure your generated code is cleaned up correctly so new code can be generated.''

Now you will see java class files generated under ''src/main/yang-gen-sal''.  Classes of note:
* '''Toaster''' - an interface that represents the toaster container with methods to obtain the leaf node data.
* '''ToasterData''' - an interface that represents the top-level toaster module with one method ''getToaster()'' that returns the singleton toaster instance.
* '''WheatBread''', '''WhiteBread''', etc' - abstract classes that represent the various toast types.
* '''$YangModelBindingProvider''', '''$YangModuleInfoImpl''' - these are used internally by MD-SAL to wire the toaster module for use. More on this later.

==Implement the operational Toaster provider (OpendaylightToaster)==

We've defined the data model for the toaster, now we need an implementation to provide the operational data. We'll create a class '''OpendaylightToaster'''. The final version of this class can be found in the ''sample-toaster-provider'' project under the ''src/main/java'' source folder. The reason this class is created in a separate project is it allows the API and implemention to be provided by different bundles, this allowing different bundles to define different implementations to the same interface. There is however nothing stopping us from putting everything into the same bundle if the implementation is proprietary.

<code>
 package org.opendaylight.toaster;
     
 import java.util.concurrent.ExecutionException;
 import org.opendaylight.controller.sal.binding.api.data.DataBrokerService;
 import org.opendaylight.controller.sal.binding.api.data.DataModificationTransaction;
 import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.DisplayString;
 import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.Toaster;
 import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.Toaster.ToasterStatus;
 import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.ToasterBuilder;
 import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
    
 public class OpendaylightToaster implements AutoCloseable{
   
    //making this public because this unique ID is required later on in other classes.
    public static final InstanceIdentifier<Toaster>  TOASTER_IID = InstanceIdentifier.builder(Toaster.class).build();
    private static final Logger LOG = LoggerFactory.getLogger(OpendaylightToaster.class);
       
    private static final DisplayString TOASTER_MANUFACTURER = new DisplayString("Opendaylight");
    private static final DisplayString TOASTER_MODEL_NUMBER = new DisplayString("Model 1 - Binding Aware");
     
    private DataBrokerService dataProvider;
   
    public OpendaylightToaster() {
    }
     
    private Toaster buildToaster() {
        //note - we are simulating a device whose manufacture and model are fixed (embedded) into the hardware.
        //This is why the manufacture and model number are hardcoded.
        ToasterBuilder tb = new ToasterBuilder();
        tb.setToasterManufacturer(TOASTER_MANUFACTURER) 
           .setToasterModelNumber(TOASTER_MODEL_NUMBER) 
           .setToasterStatus( ToasterStatus.Up );
        return tb.build();
    }
    
    public void setDataProvider(DataBrokerService salDataProvider) {
         this. dataProvider = salDataProvider;
         updateStatus();
    }
  
    /**
     * Implemented from the AutoCloseable interface.
     */
    @Override
    public void close() throws ExecutionException, InterruptedException {
        if (dataProvider != null) {
            final DataModificationTransaction t = dataProvider.beginTransaction();
            t.removeOperationalData(TOASTER_IID);
            t.commit().get();
        }
    }
    
    private void updateStatus() {
        if (dataProvider != null) {
            final DataModificationTransaction t = dataProvider.beginTransaction();
            t.removeOperationalData(TOASTER_IID);
            t.putOperationalData(TOASTER_IID, buildToaster()); 
            try {
                t.commit().get();
            } catch (InterruptedException | ExecutionException e) {
                LOG.warn("Failed to update toaster status, operational otherwise", e);
            }
        } else {
            LOG.trace("No data provider configured, not updating status");
        }
    }  
 }
</code>

The MD-SAL's '''DataBrokerService''' interface is used to create the singleton operational Toaster instance.

==Wiring the OpendaylightToaster service==

We've implemented the toaster provider service - now we have to get our '''OpendaylightToaster''' instantiated and wired up with the MD-SAL. There's a couple ways to do this - we're going to use the MD-SAL's config subsystem which provides the most flexibility and provides the full benefits of the MD-SAL (for example: access through JMX or NETCONF to the available services and run-time related data). We first need to describe our '''OpendaylightToaster''' service and what dependent services it needs for the MD-SAL to process. This is defined in... you guessed it, yang.

===Define the Toaster yang provider service implementation===

Next we need to define an implementation of the toaster provider service yang interface in the ''toaster-provider-impl.yang'' file:
<pre>
module toaster-provider-impl {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl";
    prefix "toaster-provider-impl";

    import config { prefix config; revision-date 2013-04-05; }
    import opendaylight-md-sal-binding { prefix mdsal; revision-date 2013-10-28; }

    description
        "This module contains the base YANG definitions for toaster-provider impl implementation.";

    revision "2014-01-31" {
        description
            "Initial revision.";
    }

    // This is the definition of a service implementation
    identity toaster-provider-impl {
            base config:module-type;
    }

    //augments the configuration,  
    augment "/config:modules/config:module/config:configuration" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";

            //wires in the data-broker service 
            container data-broker {
                uses config:service-ref {
                    refine type {
                        mandatory false;
                        config:required-identity mdsal:binding-data-broker;
                    }
                }
            }         
        }
    }
}
</pre>

The '''toaster-provider-impl''' identity is a ''module-type'' which is effectively providing an implementation of the toaster-provider service interface located at the ''/modules/module'' level in the MD-SAL's configuration data tree. The augmentation of ''modules/module/configuration'' adds configuration information for the toaster-provider-impl data node. '''data-broker ''' defines a dependency of the toaster-provider-impl module on the MD-SAL's DataBroker service which is needed by the '''OpendaylightToaster'''.

===Generate the Toaster yang provider source===

To generate the java source files that facilitate the service wiring, we need to add another code generator, '''JmxGenerator''', to the yang-maven-plugin configuration in the pom.xml in addition to the '''CodeGeneratorImpl''', as well as an additional dependency to the yangtools plugins:
<code>
    <plugin>
       <groupId>org.opendaylight.yangtools</groupId>
       <artifactId>yang-maven-plugin</artifactId>
       <executions>
          <execution>
             <id>config</id>
             <goals><goal>generate-sources</goal></goals>
             <configuration>
                <codeGenerators>
                   '''<generator>
                      '''<codeGeneratorClass>                                 
                          '''org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
                      '''</codeGeneratorClass>
                      '''<outputBaseDir>${jmxGeneratorPath}</outputBaseDir>
                      '''<additionalConfiguration>
                          '''<namespaceToPackage1>                                                   
                             '''urn:opendaylight:params:xml:ns:yang:controller==org.opendaylight.controller.config.yang
                          '''</namespaceToPackage1>
                      '''</additionalConfiguration>
                   '''</generator>
                   <generator>
                        CodeGeneratorImpl is specified here...
                   </generator>
               </codeGenerators>
               <inspectDependencies>true</inspectDependencies>
            </configuration>
          </execution>
       </executions>
       <dependencies>
          '''<dependency>
             '''<groupId>org.opendaylight.controller</groupId>
             '''<artifactId>yang-jmx-generator-plugin</artifactId>
             '''<version>${config.version}</version>
          '''</dependency>
          <dependency>
             <groupId>org.opendaylight.yangtools</groupId>
             <artifactId>maven-sal-api-gen-plugin</artifactId>
             <version>${yangtools.version}</version>
          </dependency>
       </dependencies>
    </plugin>
</code>  
We also need to add dependencies in the pom.xml file so the ''opendaylight-md-sal-binding'' and ''config'' yang imports can be located by the code generator:
<pre>
<dependency>
     <groupId>org.opendaylight.controller</groupId>
     <artifactId>config-api</artifactId>
</dependency>
<dependency>
      <groupId>org.opendaylight.controller</groupId>
      <artifactId>sal-binding-config</artifactId>
</dependency>
</pre>
After running mvn clean install you should see two files generated:
*'''ToasterProviderImplModule''' -  concrete class whose ''createInstance()'' method provides the OpendaylightToaster instance.
*'''ToasterProviderImplModuleFactory''' - concrete class instantiated internally by MD_SAL that creates '''ToasterProviderModule''' instances.  

'''Note''': these 2 classes are stored under src/main/java and are intended to be checked into Git as they will contain manually written code.

===Implement the ToasterProviderImplModule===
The '''ToasterProviderImplModule''' class is mostly complete from the code generation. Only the ''ToasterProviderImplModule.createInstance()'' method needs to be implemented to instantiate and wire the '''OpendaylightToaster''':

<pre>
     @Override
    public java.lang.AutoCloseable createInstance() {
        final OpendaylightToaster opendaylightToaster = new OpendaylightToaster();

        opendaylightToaster.setDataProvider(getDataBrokerDependency());
        // Wrap toaster as AutoCloseable and close registrations to md-sal at
        // close(). The close method is where you would generally clean up thread pools
        // etc.
        final class AutoCloseableToaster implements AutoCloseable {

            @Override
            public void close() throws Exception {
                  opendaylightToaster.close(); //remove operational data when shutting down
            }
        }

        return new AutoCloseableToaster();
    }
</pre>

In the above code, the '''DataBroker''' dependency has already been injected by the MD-SAL and is available via the ''getDataBrokerDependency()'' method defined in the generated base class. The return type of ''createInstance()'' is '''AutoCloseable'''. We have to return an AutoCloseable object so MD-SAL can inform our logic when it is trying to be shutdown.

We don't need to modify or implement anything in '''ToasterProviderImplModuleFactory''' for this example.
 
''Note 1: A future enhancement in this area may be to simplify the registration process here by performing more of the registrations etc automatically. Today this is how you need to perform these registrations.''

==Define the initial XML configuration==

We have now defined the toaster data model (toaster.yang), an "interface" for the toaster provider service (toaster-provider.yang) and an implementation (toaster-provider-impl.yang). At this point, if the bundles were deployed, the configuration of the toaster data model (which we haven't defined any config attributes yet) would be accessible via REST however the operational data and RPC provided by the '''OpenDaylightToaster''' service would not be accessible. What we have done so far is to define the service interface and a "possible" implementation. The last step is to actually tell MD-SAL to "deploy" the implementation, i.e. create an instance of the '''OpenDaylightToaster''' service, resolve its dependencies and advertise it for consumption/use. 

To do this, we need to create an xml file that defines the initial configuration for the toaster provider service deployment. The configuration is actually deployed internally using the netconf protocol. The xml is comprised of 2 main sections:  ''configuration'' and ''required-capabilities''.  The ''required-capabilities'' section is needed for the netconf ""hello" message and describes the yang modules that are needed by the services in order for them to function properly. Under the ''data'' section of ''configuration'' is where you define your service(s), implementation(s) and how to configure each implementation. This section is used in the subsequent netconf "edit-config" message.

Create an xml file named "03-toaster-sample.xml" with the following and put it into the ''configuration/initial'' folder of the distribution that you are running (i.e. controller/opendaylight/distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight/configuration/initial).

<br>''Note 1: Be sure to save this xml file off. If you rebuild the distribution.opendaylight project, this folder will be deleted, including your file.''
<br>''Note 2: This file likely already exists out of the box. You can safely delete this file and create an empty file with the limited data below. As we proceed in this tutorial we will rebuild that file in its entirety. Also, the original version of the file is stored in the distribution/opendaylight/src/main/resources/configuration/initial directory just in case.

Replace / edit the 03-toaster-sample.xml file and put in these contents:

<pre>
<snapshot>
    <configuration>
        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">

                <!-- defines an implementation -->
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl">
                        prefix:toaster-provider-impl
                    </type>
                    
                    <name>toaster-provider-impl</name>

                    <data-broker>
                       <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-data-broker</type>
                       <name>binding-data-broker</name>
                   </data-broker>

                </module>
            </modules>
        </data>

    </configuration>

    <required-capabilities>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl?module=toaster-provider-impl&amp;amp;revision=2014-01-31</capability>
    </required-capabilities>

</snapshot>

</pre>

The ''modules'' section specifies the toaster-provider-impl module and its dependency configuration as defined in the ''toaster-provider-impl.yang'' file. The data-broker implementation is provided by MD-SAL and is needed for the '''OpenDaylightToaster'''.

The ''required-capabilities'' section lists only the toaster-provider-impl yang module as a dependent capability. There are other dependent modules,  opendaylight-md-sal-binding etc, but they are inferred by the imports in the ''toaster-provider-impl.yang'' file so they don't have to be explicitly specified. Each ''capability'' is a URI of the form:

  ''<yang module namespace>''?module=''<yang module name>''&amp;amp;revision=''<yang module revision>''

The "03" prefix in the file name is significant. The files in ''configuration/initial'' are sorted by name thus allowing you control over the order in which they are deployed. While the file name doesn't actually need to be prefixed with a number, doing so allows for easier sorting and is the best practice/convention. You'll notice other files numbered this way. We choose "03" prefix for our toaster so it is higher than the existing internal MD-SAL config files and thus will be deployed last. You basically want to order the config files such that dependencies (as inferred by the ''required-capabilities'') are deployed first. Since the toaster is dependent on MD-SAL (specifically "01-md-sal.xml"), we deploy it last. Technically, the toaster config could actually be deployed first as the config subsystem will retry if a dependency is not yet present but it is more efficient on startup to explicitly define the ordering. 

On startup, the XML files in the ''configuration/initial'' directory are loaded by the '''ConfigPersisterActivator'''. A '''ConfigPusher''' instance is instantiated to push the configs via the NetConf subsystem to the '''ConfigRegistryImpl'''.  When processing the toaster-provider-impl module in the toaster config file, the '''ToasterProviderImplModuleFactory''' class is located and instantiated and the ''createModule'' method is called to create a '''ToasterProviderImplModule''' instance. The ''ToasterProviderImplModule.createInstance'' method is then called to create and wire the '''OpenDaylightToaster'''.

For a detailed walk-through on how to make a 'config-subsystem aware' project please visit https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Examples:Sample_Project

'''Note: Be sure to keep an eye on the command line of the OSGI container when you start it. If the wiring service fails to find all of the dependencies you will see errors printed out there about missing capabilities etc.'''

== Getting the Operational Status of the Toaster ==
To get the operational status of the toaster you will make a call to the RESTCONF service provided by MD-SAL.  You do this by performing a GET to the operational data store.

<pre>
  HTTP Method: GET
  HTTP URL: http://localhost:8080/restconf/operational/toaster:toaster
</pre>

You should see the following response:

<pre>
{
    toaster: {
        toasterManufacturer: "Opendaylight"
        toasterModelNumber: "Model 1 - Binding Aware"
        toasterStatus: "Up"
   }
}
</pre>

''Note: If you want XML instead of json, add '''Accept: application/yang.data+xml''' to the headers of the request.''

== How Does MD-SAL Know about my Toaster? ==

The sample-toaster bundle only defines a yang file and has no bundle Activator and has no code other than the generated source files. If you are wondering how MD-SAL becomes aware of the toaster yang data model then read on.

The magic is done via some files that are generated by the yang-maven-plugin under ''target/classes/META-INF'' that get inserted into the sample-toaster bundle.
*The ''src/main/yang/toaster.yang'' file is copied to ''target/classes/META-INF/yang/toaster.yang''. 
*The ''org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' file is generated in ''target/classes/META-INF/services'' and contains the fully-qualfied name of the toaster's generated '''$YangModelBindingProvider''' class. The MD-SAL's '''ModuleInfoBundleTracker''' class in the config subsystem scrapes the ''META-INF/services/org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' resource from bundles on startup and reads the class name(s) defined in the file.  For each YangModelBindingProvider class specified, the MD-SAL creates an instance and calls ''getModuleInfo()'' to return the singleton '''$YangModuleInfoImpl''' instance. This class has methods to obtain static configuration information about the yang module, e.g. name, revision, imports etc, as well as a ''getModuleSourceStream()'' method that provides an input stream to the ''META-INF/yang/toaster.yang'' file. Once the MD-SAL knows about a yang module and its definitions, it can wire it up to RestConf and other parts of the system.

= Part 2: Enabling Remote Procedure Calls (RPC) - Lets make some toast!=
Part 2 of the toaster example will add some behavior to the toaster. Having a toaster is cool but we'd really like it to make some toast for us. To accomplish this, we will define an RPC (Remote Procedure Call) in the toaster yang data model and write an implementation. 

===Define the yang RPC===

Edit the existing ''toaster.yang'' file, where we will define 2 RPC methods, ''make-toast'' and ''cancel-toast'' (add the bold lines under the module toaster heading):

<code>
    module toaster {
        ... 
    '''//This defines a Remote Procedure Call (rpc). RPC provide the ability to initiate an action
    '''//on the data model. In this case the initating action takes two optional inputs (because default value is defined)
    '''//QUESTION: Am I correct that the inputs are optional because they have defaults defined? The REST call doesn't seem to account for this.
    '''rpc make-toast {
    '''  description
    '''    "Make some toast. The toastDone notification will be sent when the toast is finished.
    '''     An 'in-use' error will be returned if toast is already being made. A 'resource-denied' error will 
    '''     be returned if the toaster service is disabled.";<br>
    '''  input {
    '''    leaf toasterDoneness {
     '''     type uint32 {
     '''       range "1 .. 10";
    '''      }
    '''      default '5';
    '''      description
     '''       "This variable controls how well-done is the ensuing toast. It should be on a scale of 1 to 10.
      '''       Toast made at 10 generally is considered unfit for human consumption; toast made at 1 is warmed lightly.";
      '''  }<br>
      '''  leaf toasterToastType {
      '''    type identityref {
      '''      base toast:toast-type;
      '''    }
    '''      default 'wheat-bread';
    '''      description
    '''        "This variable informs the toaster of the type of material that is being toasted. The toaster uses this information, 
    '''          combined with toasterDoneness, to compute for how long the material must be toasted to achieve the required doneness.";
     '''   }
   '''   }
    '''}  // rpc make-toast<br>
  '''  // action to cancel making toast - takes no input parameters
   ''' rpc cancel-toast {
   '''   description
   '''     "Stop making toast, if any is being made.
    '''       A 'resource-denied' error will be returned 
   '''        if the toaster service is disabled.";
    '''}  // rpc cancel-toast'''
    ...
  }
</code>

Running 'mvn clean install', we see the following additional classes generated:

*'''ToasterService''' - an interface that extends '''RpcService''' and defines the RPC methods corresponding to the yang data model.
*'''MakeToastInput''' - an interface defining a DTO providing the input parameters for the make-toast call. 
*'''MakeToastInputBuilder''' - a concrete class for creating MakeToastInput instances.

''Note: It is important that you run the mvn clean stage everytime you modify the yang files. There are some files that are not generated if they already exist, which can lead to incorrect generated files. When you change .yang file, you should always run mvn clean, which will remove all of the generated yang files, via the mvn-clean-plugin defined in the common.opendaylight pom.xml file.''

===Implement the RPC methods===

We've defined the data model interface for the RPC calls - now we must provide the implementation. We are going to modify our '''OpendaylightToaster''' class to implement the new '''ToasterService''' interface that was just generated. The entire code is shown for simplicity:
<code>
 public class OpendaylightToaster implements '''ToasterService,''' AutoCloseable {
  
   //making this public because this unique ID is required later on in other classes.
   public static final InstanceIdentifier<Toaster>  TOASTER_IID = InstanceIdentifier.builder(Toaster.class).build();
   private static final Logger LOG = LoggerFactory.getLogger(OpendaylightToaster.class);
      
   private static final DisplayString TOASTER_MANUFACTURER = new DisplayString("Opendaylight");
   private static final DisplayString TOASTER_MODEL_NUMBER = new DisplayString("Model 1 - Binding Aware");
    
   '''private DataBrokerService dataProvider;
  
   '''private final ExecutorService executor;
   
   '''// As you will see we are using multiple threads here. Therefore we need to be careful about concurrency.
   '''// In this case we use the taskLock to provide synchronization for the current task.
   '''private volatile Future<RpcResult<Void>> currentTask;
   '''private final Object taskLock = new Object();
   
   public OpendaylightToaster() {
   '''    executor = Executors.newFixedThreadPool(1);
   }
   
   public void setDataProvider(DataBrokerService salDataProvider) {
        this. dataProvider = salDataProvider;
        updateStatus();
   }
    
   /**
   * Implemented from the AutoCloseable interface.
   */
   @Override
   public void close() throws ExecutionException, InterruptedException {
   '''    // When we close this service we need to shutdown our executor!
   '''    executor.shutdown();
   
       if (dataProvider != null) {
           final DataModificationTransaction t = dataProvider.beginTransaction();
           t.removeOperationalData(TOASTER_IID);
           t.commit().get();
       }
   }
   
   /**
    * Implemented from the ToasterData interface.
    */
   private Toaster buildToaster() {
     '''  boolean isUp = currentTask == null;
    
       // note - we are simulating a device whose manufacture and model are
       // fixed (embedded) into the hardware.
       // This is why the manufacture and model number are hardcoded.
       ToasterBuilder tb = new ToasterBuilder();
       tb.setToasterManufacturer(TOASTER_MANUFACTURER).setToasterModelNumber(TOASTER_MODEL_NUMBER)
       '''        .setToasterStatus(isUp ? ToasterStatus.Up : ToasterStatus.Down);
       return tb.build();
   }
   
   '''/**
   ''' * RestConf RPC call implemented from the ToasterService interface.
   ''' */
   '''@Override
   '''public Future<RpcResult<Void>> cancelToast() {
   '''    synchronized (taskLock) {
   '''        if (currentTask != null) {
   '''            currentTask.cancel(true);
   '''            currentTask = null;
   '''        }
   '''    }
   '''    // Always return success from the cancel toast call.
   '''    return Futures.immediateFuture(Rpcs.<Void> getRpcResult(true, Collections.<RpcError> emptySet()));
   '''}
   
   '''/**
   ''' * RestConf RPC call implemented from the ToasterService interface.
   ''' */
   '''@Override
   '''public Future<RpcResult<Void>> makeToast(MakeToastInput input) {
   '''    LOG.info("makeToast: " + input);
  
   '''    synchronized (taskLock) {
   '''        if (currentTask != null) {
   '''            // return an error since we are already toasting some toast.
   '''            LOG.info( "Toaster is already making toast" );
   
   '''            RpcResult<Void> result = Rpcs.<Void> getRpcResult(false, null, Arrays.asList(
   '''                    RpcErrors.getRpcError( null, null, null, null,
   '''                                           "Toaster is busy", null, null ) ) );
   '''            return Futures.immediateFuture(result);
   '''        }
   '''        else {
   '''            // Notice that we are moving the actual call to another thread,
   '''            // allowing this thread to return immediately.
   '''            // The MD-SAL design encourages asynchronus programming. If the
   '''            // caller needs to block until the call is
   '''            // complete then they can leverage the blocking methods on the
   '''            // Future interface.
   '''            currentTask = executor.submit(new MakeToastTask(input));
   '''        }
   '''    }
  
   '''    updateStatus();
   '''    return currentTask;
   '''}
   
   private void updateStatus() {
       if (dataProvider != null) {
           final DataModificationTransaction t = dataProvider.beginTransaction();
           t.removeOperationalData(TOASTER_IID);
           t.putOperationalData(TOASTER_IID, buildToaster());
   
           try {
               t.commit().get();
           } catch (InterruptedException | ExecutionException e) {
               LOG.warn("Failed to update toaster status, operational otherwise", e);
           }
       } else {
           LOG.trace("No data provider configured, not updating status");
       }
   }
  
     '''private class MakeToastTask implements Callable<RpcResult<Void>> {
  
  '''      final MakeToastInput toastRequest;
  
  '''      public MakeToastTask(MakeToastInput toast) {
  '''          toastRequest = toast;
  '''      }
  
  '''      @Override
  '''      public RpcResult<Void> call() throws InterruptedException {
  '''          // make toast just sleeps for 1 second per doneness level.
  '''          try
  '''          {
  '''              Thread.sleep(1000 * toastRequest.getToasterDoneness());
  '''          }
  '''          //TODO: Consider catch interruptedException and returning valid error case.
  '''          finally
  '''          {
  '''              synchronized (taskLock) {
  '''                  currentTask = null;
  '''                  updateStatus();
  '''              }
  '''          }
  '''          LOG.debug("Toast done");        
  
  '''          return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
  '''      }
  '''  }  
 }
</code>
In the above code you can see that we have implemented the ''makeToast'' and ''cancelToast'' methods, in addition to the ''close'' method from the AutoCloseable interface to ensure that we properly clean up our embedded threadpool. Refer to inline comments for more details on what is happening.

=== Register OpendaylightToaster with the RPC service ===

The next step is to register our '''OpendaylightToaster''' as the provider for the RPC calls. To do this we will need to first declare a dependency on the MD-SAL's RPC registry service in the ''toaster-provider-impl.yang'' file similar as we did with the data broker service:
<code>
    //augments the configuration,  
    augment "/config:modules/config:module/config:configuration" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";
     
            //wires in the data-broker service 
            container data-broker {
                uses config:service-ref {
                    refine type {
                        mandatory false;
                        config:required-identity mdsal:binding-data-broker;
                    }
                }
            }         
            
            '''//Wires dependent services into this class - in this case the RPC registry service
            '''container rpc-registry {
            '''    uses config:service-ref {
            '''        refine type {
            '''            mandatory true;
            '''            config:required-identity mdsal:binding-rpc-registry;
            '''        }
            '''    }
            '''} 
        }
    }
</code>

Re-generate the source. The generated '''AbstractToasterProviderModule''' class will now have a ''getRpcRegistryDependency()'' method. We can access that method in the '''ToasterProviderImplModule''' implementation to register the '''OpenDaylightToaster''' with the RPC registry service:
<code>
    @Override
    public java.lang.AutoCloseable createInstance() {
        final OpendaylightToaster opendaylightToaster = new OpendaylightToaster();
    
        opendaylightToaster.setDataProvider(getDataBrokerDependency());
        
        '''// Register our OpendaylightToaster instance as the RPC implementation for the ToasterService.
        '''final BindingAwareBroker.RpcRegistration<ToasterService> rpcRegistration = getRpcRegistryDependency()
        '''        .addRpcImplementation(ToasterService.class, opendaylightToaster);
           
        // Wrap toaster as AutoCloseable and close registrations to md-sal at
        // close()
        final class AutoCloseableToaster implements AutoCloseable {
     
            @Override
            public void close() throws Exception {
          '''      rpcRegistration.close();
          '''      opendaylightToaster.close(); //allow closing of thread pools
            }
   
        }
    
        return new AutoCloseableToaster();
    }
</code>

Finally we need to add the dependency for the 'rpc-registry' to the toaster-provider-impl module in the initial configuration XML file (remember the 03-sample-toaster.xml file?) as we did earlier with the 'data-broker':
<code>
  <module>
      <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl">
            prefix:toaster-provider-impl
       </type>
      
       <name>toaster-provider-impl</name>
      
        '''<rpc-registry>
        '''       <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-rpc-registry</type>
        '''       <name>binding-rpc-broker</name>
        '''</rpc-registry>
    
         <data-broker>
               <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-data-broker</type>
                <name>binding-data-broker</name>
          </data-broker>
   
   </module>
</code>

Thats it! We are now ready to deploy our updated bundles and try out our makeToast and cancel toast calls.

===Invoke make-toast via RestConf===

It's finally time to make some delicious wheat toast! To invoke the ''make-toast'' via the Restconf you will perform an HTTP POST to an operations URL.
<pre>
HTTP Method => POST
URL => http://localhost:8080/restconf/operations/toaster:make-toast 
Header =>   Content-Type: application/yang.data+json  
Body =>  
{
  "input" :
  {
     "toaster:toasterDoneness" : "10",
     "toaster:toasterToastType":"wheat-bread" 
  }
}
</pre>
''Note: The default and mandatory flags are not currently implemented in, so even though the toast type and doneness is defaulted in the yang model, you still have to provide their values here.''

===Invoke cancel-toast via RestConf===
If you don't like burnt toast, you may want to cancel the ''make-toast'' operation part of the way through! You do this by invoking the ''cancel-toast'' call via restconf:
<pre>
URL => http://localhost:8080/restconf/operations/toaster:cancel-toast
HTTP Method => POST
</pre>

''Note: There is a bug in the way the RestconfImpl class processes / routes the REST requests. If you define the Content-Type header, then the rest call is routed to a method which expects a non-empty body. In this case though we don't have any input, so our body should be empty. Thus an exception is thrown. In order to make the cancel-toast call work successfully, you need to invoke the above call, with NO content-type define. By doing that you route the request to a different method, which expects an empty body.''

=== See the Toaster status updated ===
To see the updated toaster status, invoke the ''make-toast'' call (with a doneness of 10 to get the longest delay) and then immediately invoke the get to retrieve the Operational Status of the Toaster. You should now see:
{
    toaster: {
        toasterManufacturer: "Opendaylight"
        toasterModelNumber: "Model 1 - Binding Aware"
        toasterStatus: "Down"
   }
}

= Part 3: Add some configuration data =

In part 3 we will explore defining and enabling configuration attributes (as opposed to operational attributes) in our yang toaster file. In this section we are going to define a new configuration attribute on the toaster which will allow the user to modify number of seconds each level of doneness will take. More importantly, we will illustrate how our OpendaylightToaster can register for changes in that configuration data as well as how the user can set, update and delete that information.

== Add the configuration attribute to toaster.yang ==

The first step to this process is to add our new attribute to the toaster.yang file. To do this, add the below text into the "toaster" container in our yang file, along side the other leaf nodes:

<code>
  container toaster {
      ...
     
      '''leaf darknessFactor {
      '''  type uint32;
      '''  config true;
      '''  default 1000;
      '''  description
      '''    "The darkness factor. Basically, the number of ms to multiple the doneness value by.";
      '''}
     
      ...
 }
</code>

Now run 'mvn clean install' to generate an updated Toaster.java interface.

== Listening for Changes ==

In order for our OpendaylightToaster to get notified when the configuration data changes we need to implement the DataChangeListener interface.
:''Note: There are multiple DataChangeListener interfaces. We must implement the <code>org.opendaylight.controller.sal.binding.api.data.DataChangeListener;</code> interface.''
<code>
   ...
   '''import org.opendaylight.controller.sal.binding.api.data.DataChangeListener;'''
   ...
   public class OpendaylightToaster implements ToasterData, ToasterService, AutoCloseable, '''DataChangeListener''' {
   ...
      '''@Override
      '''public void onDataChanged(DataChangeEvent<InstanceIdentifier<?>, DataObject> change) {
      '''        //TODO - implement
      '''}
   ...
   }
</code>

The DataChangeListener interface has a single method, onDataChanged, which asses a change event. The change event can contain changes for multiple nodes (in the case of a list), but in our case we only have a single node that we are looking for. The next step is to extract from the change event, the updated data. Do this by providing the following implementation for the onDataChanged() method.

<code>
   ...
   //Thread safe holder for our darkness multiplier.
   '''private AtomicLong darknessFactor = new AtomicLong( 1000 );
   ...
   @Override
    public void onDataChanged(DataChangeEvent<InstanceIdentifier<?>, DataObject> change) {
        '''DataObject dataObject = change.getUpdatedConfigurationData().get( TOASTER_IID );
        '''if( dataObject instanceof Toaster )
        '''{
         '''   Toaster toaster = (Toaster) dataObject;
        '''    Long darkness = toaster.getDarknessFactor();
        '''    if( darkness != null )
        '''    {
        '''        darknessFactor.set( darkness );
       '''     }
        '''}
    }
    ...
</code>
The last step is to modify the MakeToastTask call method to use our new darkness factor instead of a hardcoded value.
<code>
  private class MakeToastTask implements Callable<RpcResult<Void>> {
        ...
        @Override
       public RpcResult<Void> call() throws InterruptedException {
           // make toast just sleeps for 1 second per doneness level.
           try
           {
               // make toast just sleeps for 1 second per doneness level.
              ''' long darknessFactor = OpendaylightToaster.this.darknessFactor.get();
             '''  Thread.sleep(darknessFactor * toastRequest.getToasterDoneness());
           }
           //TODO: Consider catch interruptedException and returning valid error case.
           finally
           {
               synchronized (taskLock) {
                   currentTask = null;
                   updateStatus();
               }
           }
           LOG.debug("Toast done");        
   
           return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
       }
    }
</code>

We have successfully implemented the DataChangeListener interface. The final step is to register our listener with the databroker service in order to actually get routed the notifications. We will perform this registration in the ToasterProviderImplModule:
<code>
   ...
   @Override
    public java.lang.AutoCloseable createInstance() {
        final OpendaylightToaster opendaylightToaster = new OpendaylightToaster();
         
        '''DataProviderService dataBrokerService = getDataBrokerDependency();
       ''' opendaylightToaster.setDataProvider(dataBrokerService);
        
        '''final ListenerRegistration<DataChangeListener> dataChangeListenerRegistration = 
        '''        dataBrokerService.registerDataChangeListener( OpendaylightToaster.TOASTER_IID, opendaylightToaster );
        
        // Register our OpendaylightToaster instance as the RPC implementation for the ToasterService.
        final BindingAwareBroker.RpcRegistration<ToasterService> rpcRegistration = getRpcRegistryDependency()
                .addRpcImplementation(ToasterService.class, opendaylightToaster);
        
        // Wrap toaster as AutoCloseable and close registrations to md-sal at
        // close()
        final class AutoCloseableToaster implements AutoCloseable {
     
            @Override
            public void close() throws Exception {
                '''dataChangeListenerRegistration.close(); //closes the listener registrations (removes it)
                opendaylightToaster.close(); //allow closing of thread pools
                rpcRegistration.close(); //unregisters this implementation.
            }
        }
    
        return new AutoCloseableToaster();
    }
    ...
</code>
We have now registered our toaster as a listener for changes to the toaster node and any node below it. Every MD-SAL registration method should return a registration object which implements AutoCloseable. This auto closeables should be closed when the bundle is shutting down to unregister listeners  / dependencies etc.

== Changing the Darkness Factor ==
To change the darkness factor we will use a REST call to the restconf service provided by MD-SAL.  Once your controller is started, perform the following PUT:
<pre>
  HTTP Method: PUT
  URL:  http://localhost:8080/restconf/config/toaster:toaster
  HEADER: content-type: application/yang.data+json
  BODY: 
  {
    toaster:
    {
       darknessFactor: "2000"
    }
 }
</pre>
You should receive a return code of 200. If you perform a GET to the same URL, your should see the update darkness factor returned. At this point, if you perform the make-toast RPC call you should see the delay reflect the value of the darknessFactor * the doneness.

'''NOTE: This is a known bug in restconf which allows your to PUT to attributes which we are NOT marked as configuration attributes inside the yang datamodel. In our example this is toasterManufacture, toasterModel, and toasterStatus. It is discouaged for developers to depend on this ability as it will be removed in the near future. Only attributes marked as <code>config: true</code> in the yang data model should be modified via restconf put/post/delete.

= Part 4: Add state data to the ToasterService implementation (JMX Access) - Count my toast!=

For internal statistical purposes and troubleshooting, we'd like to keep track of how many pieces of toast the toaster has made over time.  We need an attribute, '''toasts-made''', to track the count and a way to obtain the count. Whenever we '''make-toast''', we want to increment '''toasts-made'''. In addition, we'd like a mechanism to clear the '''toasts-made''' count.

To accomplish this, the MD-SAL provides the ability to define internal state data and RPC calls that is only accessible via JMX. 

==Define the state data model==
We'll define '''toasts-made''' as statistical state data on the toaster provider service implementation since that is where '''make-toast''' happens. In addition, we'll define an RPC call, '''clear-toasts-made'''. This is achieved by augmenting the toaster-provider-impl module's '''config:state''' in ''toaster-provider-impl.yang'':
<pre>
    import rpc-context { prefix rpcx; revision-date 2013-06-17; }
    ...
    augment "/config:modules/config:module/config:state" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";

            leaf toasts-made {
                type uint32;
            }

            rpcx:rpc-context-instance "clear-toasts-made-rpc";
        }
    }

    identity clear-toasts-made-rpc;

    rpc clear-toasts-made  {
        description
          "JMX call to clear the toasts-made counter.";

        input {
            uses rpcx:rpc-context-ref {
                refine context-instance {
                    rpcx:rpc-context-instance clear-toasts-made-rpc;
                }
            }
        }
    }
</pre>

Run 'mvn clean install' to generate the source. 3 additional classes are generated under ''src/main/yang-gen-config'':
*'''ToasterProviderRuntimeMXBean''' - JMX bean interface that defines the ''getToastsMade()'' method to provide access to the '''toasts-made''' attribute and the ''clearToastsMade()'' RPC method.
*'''ToasterProviderRuntimeRegistration''' - concrete class that wraps a '''ToasterProviderRuntimeMXBean''' registration.
*'''ToasterProviderRuntimeRegistrator''' - concrete class that registers a '''ToasterProviderRuntimeMXBean''' implementation with the MD-SAL.

==Implement the toasts-made attribute==

Now that we've defined the data model for our state data and behavior we need to provide an implementation. Since the '''OpenDaylightToaster''' makes toast, we'll implement it there.

The '''ToasterProviderRuntimeMXBean''' provides the interface for access to the state data so we need to modify '''OpenDaylightToaster''' to implement the '''ToasterProviderImplRuntimeMXBean''' interface:

<code>
 public class OpendaylightToaster implements ToasterService, AutoCloseable, DataChangeListener''', ToasterProviderImplRuntimeMXBean''' {
    ...
    '''private final AtomicLong toastsMade = new AtomicLong(0);
    ...
    <br>
    '''/**
     '''* Accessor method implemented from the ToasterProviderRuntimeMXBean interface.
     '''*/
    '''@Override
    '''public Long getToastsMade() {
        '''return toastsMade.get();
    '''}
    <br>
    '''/**
     '''* JMX RPC call implemented from the ToasterProviderRuntimeMXBean interface.
     '''*/
    '''@Override
    '''public void clearToastsMade() {
        '''LOG.info( "clearToastsMade" );
        '''toastsMade.set( 0 );
    '''}
    ...
    <br>
    private class MakeToastTask implements Callable<RpcResult<Void>> {
        ...
        @Override
        public RpcResult<Void> call() throws InterruptedException {
            ...
            Thread.sleep(darknessFactor * toastRequest.getToasterDoneness());
            '''toastsMade.incrementAndGet();'''
            ...
            return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
        }
    }
 }
</code>

==Register the ToasterProviderRuntimeMXBean service==

We need to do a final step to register the '''OpendaylightToaster''' as the '''ToasterProviderImplRuntimeMXBean''' service. We do this in the '''ToasterProviderImplModule''' via the '''ToasterProviderImplRuntimeRegistrator''' returned by the base class's ''getRootRuntimeBeanRegistratorWrapper()'' method:

<code>
    public java.lang.AutoCloseable createInstance() {
        final OpendaylightToaster opendaylightToaster = new OpendaylightToaster();
        ...
        // Register runtimeBean for toaster statistics via JMX
        '''final ToasterProviderImplRuntimeRegistration runtimeReg = getRootRuntimeBeanRegistratorWrapper().register( opendaylightToaster);
        ...
        final class AutoCloseableToaster implements AutoCloseable {
            @Override
            public void close() throws Exception {
                ...
                '''runtimeReg.close();
                ...
            }
            ...
        }
    }
</code>

Note: we also have to close the '''ToasterProviderImplRuntimeRegistration''' when the '''OpendaylightToaster''' instance is closed.

== Accessing toasts-made via JMX==
The toasts-made attribute that we added is available via MBeans through the java management beans. You can programmatically access these through the mbean platform or via JConsole.
*''JConsole is a utility shipped with each JDK and is located in the bin directory of your java home folder.''
*First, start the controller using the -jmx flag.<pre>./run.sh -jmx</pre>This flag starts the JMX server in the controller to allow JConsole to attach.<Br><br>Launch JConsole, double click on the jconsole application under <pre>$JAVA_HOME/bin/jconsole</pre>''Note: Path may change based on OS and installation''
*Connect to the running eclipse process either by selecting the application, or specifying the "hostname:1088" in the remote connect dialog. For more information on JMX check out this document: [https://wiki.opendaylight.org/images/8/89/Jconsole.pdf].
*Once connected, navigate to the "MBeans" tab.
:*Expand the "org.opendaylight.controller->RuntimeBean->toaster-provider-impl->toster-provider-impl" nodes.
*Select "Attributes". You will now see the "ToastsMade" attribute displayed and this attribute will change when the make-toast RPC call is executed.
*After you have called ToastsMade call a few times, refresh the attributes and see that the value increased.
*Now select "Operations", and click the "clearToastsMade" button.
*Return to the Attributes and note that the counter is now set to 0.

= Part 5: Add a consumer of the ToasterService  =

We've seen how we can use RestConf to access the '''ToasterService''' RPC methods. In this section we'll show how to access the '''ToasterService''' programmatically from within the controller.

We'll create a new service called '''KitchenService''' that provides a method to make breakfast (this is located in the ''sample-toaster-consumer'' project). This service will access the '''ToasterService''' to provide the toast for our breakfast.

The '''KitchenService''' defines a higher-level service for making a full breakfast. This nicely demonstrates service chaining, where a consumer of one or more services is also a provider of another service. This example will only call into the 'toast' service but one can see that it could be extended to also call into an 'eggs' service and also add a 'coffee' service etc.

==Define the KitchenService interface==

For the sake of brevity, we'll hand-code the KitchenService data model and interface instead of defining it in yang. In a true kitchenService model you would likely want to define the KitchenService in yang to get the benefit of auto-generated classes and the out-of-box functionality that MD-SAL provides. For this example, we define an enumeration and interface java files under src/main/java, in the ''org.opendaylight.controller.sample.kitchen.api package''.
<code>
 //EggsType.java  
 public enum EggsType {
     SCRAMBLED,
     OVER_EASY,
     POACHED
 }
</code>
<code>
 //KitchenService.java 
 public interface KitchenService {
   
     boolean makeBreakfast( EggsType eggs, Class<? extends ToastType> toast, int toastDoneness );
    
 }
</code>

Our breakfast only includes eggs with the toast for simplicity - a complete breakfast may also include bacon or sausage and coffee. Eggs, breakfast meat, coffee etc could also be separate data models with corresponding services like the ToasterService - we leave that as an exercise for the reader.

==Define the KitchenService implementation==

Next we create a class, '''KitchenServiceImp''', to implement the interface and access the '''ToasterService''' to make the toast:
<pre>
public class KitchenServiceImpl implements KitchenService {

    private static final Logger log = LoggerFactory.getLogger( KitchenServiceImpl.class );

    private final ToasterService toaster;

    public KitchenServiceImpl(ToasterService toaster) {
        this.toaster = toaster;
    }

    @Override
    public boolean makeBreakfast( EggsType eggs, Class<? extends ToastType> toast, int toastDoneness ) {

        // Access the ToasterService to make the toast.
        // We don't actually make the eggs for this example - sorry.
        MakeToastInputBuilder toastInput = new MakeToastInputBuilder();
        toastInput.setToasterDoneness( (long) toastDoneness);
        toastInput.setToasterToastType( toast );

        try {
            RpcResult<Void> result = toaster.makeToast( toastInput.build() ).get();

            if( result.isSuccessful() ) {
                log.trace( "Toast was successfully finished" );
            } else {
                log.warn( "Toast was not successfully finished" );
            }

            return result.isSuccessful();
        } catch( InterruptedException | ExecutionException e ) {
            log.warn( "Error occurred during toast creation" );
        }
        return false;
    }
}
</pre>

==Wiring the KitchenService implementation==

Similar to the toaster provider service, we'll describe the kitchen service interface and implementation in yang and provide the initial configuration xml so the MD-SAL can wire it up.

===Define the kitchen service yang===
We'll define the kitchen service implementation and its dependencies in ''kitchen-service-impl.yang'':
<pre>
module kitchen-service-impl {

    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:kitchen-service:impl";
    prefix "kitchen-service-impl";

    import config { prefix config; revision-date 2013-04-05; }
    import rpc-context { prefix rpcx; revision-date 2013-06-17; }

    import opendaylight-md-sal-binding { prefix mdsal; revision-date 2013-10-28; }

    description
        "This module contains the base YANG definitions for
        kitchen-service impl implementation.";

    revision "2014-01-31" {
        description
            "Initial revision.";
    }

    // This is the definition of a service implementation
    identity kitchen-service-impl {
            base config:module-type;
    }

    augment "/config:modules/config:module/config:configuration" {
        case kitchen-service-impl {
            when "/config:modules/config:module/config:type = 'kitchen-service-impl'";

            container rpc-registry {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-rpc-registry;
                    }
                }
            }
        }
    }
}
</pre>

In the pom.xml, we need to add the yang-maven-plugin with the JMXGenerator similar as we did earlier for the toaster provider pom file.

=== Implement the KitchenServiceModule===
After running 'mvn clean install', several source files will be generated similar to the toaster provider, of which we only need to modify the ''KitchenServiceImplModule.createInstance()'' method to instantiate the '''KitchenServiceImpl''' instance and wire it:
<pre>
    @Override
    public java.lang.AutoCloseable createInstance() {
        ToasterService toasterService = getRpcRegistryDependency().getRpcService(ToasterService.class);

        final KitchenServiceImpl kitchenService = new KitchenServiceImpl(toasterService);

        final class AutoCloseableKitchenService implements AutoCloseable {

            @Override
            public void close() throws Exception {
            }
        }

        AutoCloseable ret = new AutoCloseableKitchenService();
        return ret;
    }
</pre>

=== Define initial configuration ===
Finally, add the kitchen service and module definitions to the initial configuration xml created earlier:
<code>
 <snapshot>
    <configuration>
        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
               ...
               '''<module>
                  '''<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:config:kitchen-service:impl">
                     '''prefix:kitchen-service-impl
                  '''</type>
                  '''<name>kitchen-service-impl</name>
                  <br>
                  '''<rpc-registry>
                     '''<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-rpc-registry</type>
                     '''<name>binding-rpc-broker</name>
                  '''</rpc-registry>
                '''</module>
            </modules>
        </data>
    </configuration>
    
    <required-capabilities>
        '''<capability>urn:opendaylight:params:xml:ns:yang:controller:config:kitchen-service:impl?module=kitchen-service-impl&amp;amp;revision=2014-01-31</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl?module=toaster-provider-impl&amp;amp;revision=2014-01-31</capability>
    </required-capabilities>
 </snapshot>
</code>

==Add JMX RPC to make breakfast==

At this point, if we deployed the kitchen service we wouldn't be able to access it via restconf as we didn't define a yang data model for it. Presumably, for a real service, there would be java clients to consume it. In lieu of that we can utilize JMX to exercise the kitchen service to make breakfast.

The MD-SAL also supports RPC calls via JMX. We simply define the RPC in yang and tie it to the ''config:state'' via augmentation as we did earlier for the '''toastsMade''' statistical attribute.

We'll add an '''make-scrambled-with-wheat''' RPC definition to ''kitchen-service-impl.yang''. This call takes no input and hard-codes scrambled eggs with light wheat toast for simplicity. 

<pre>
    augment "/config:modules/config:module/config:state" {
        case kitchen-service-impl {
            when "/config:modules/config:module/config:type = 'kitchen-service-impl'";

            rpcx:rpc-context-instance "make-scrambled-with-wheat-rpc";
        }
    }

    identity make-scrambled-with-wheat-rpc;

    rpc make-scrambled-with-wheat  {
        description
          "Shortcut JMX call to make breakfast with scrambled eggs and wheat toast for testing.";

        input {
            uses rpcx:rpc-context-ref {
                refine context-instance {
                    rpcx:rpc-context-instance make-scrambled-with-wheat-rpc;
                }
            }
        }
        output {
            leaf result {
                type boolean;
            }
        }
    }
</pre>  

After re-generating the source, modify the '''KitchenServiceImpl''' to implement the generated interface '''KitchenServiceImplRuntimeMXBean''' that defines the ''makeScrambledWithWheat()'' method.
<pre>
    @Override
    public Boolean makeScrambledWithWheat() {
        return makeBreakfast( EggsType.SCRAMBLED, WheatBread.class, 2 );
    }
</pre>

Next, modify the ''KitchenServiceModule.createInstance()'' to register the '''KitchenService''' with JMX and then close it in the auto close..
<pre>
    final KitchenServiceImplRuntimeRegistration runtimeReg =
                                  getRootRuntimeBeanRegistratorWrapper().register( kitchenService );
    ...
    runtimeReg.close();
                    
</pre>

== Make breakfast via JMX ==

We can access the kitchen-service-impl MBean via JConsole as we did earlier with the toaster-service-impl MBean. Navigate to the MBeans tab and expand the "org.opendaylight.controller->RuntimeBean->kitchen-service-impl->kitchen-service-impl" node.

= Part 6: Notifications - Oh no, the Toaster is out of bread!=

This part will make use of the MD-SAL's unsolicited notification service to have the '''OpenDaylightToaster''' send notifications when significant events occur. Notifications can be consumed by a registered listener implementation or by an external netconf client.

A toaster can only make toast if it has supply of bread. Currently, our '''OpenDaylightToaster''' has an infinite supply of bread which isn't very realistic in the real world. 

We'll modify the '''OpenDaylightToaster''' to have a finite stock of bread. We'll keep it simple and maintain an overall limit encompassing all types of bread instead of a limit per bread type.

When called to make toast, if out of bread, a ''toasterOutOfBread'' notification will be sent.

We'll also add an RPC call, ''restock-toaster'', that can be used to set the amount of bread in stock. In addition it will send a ''toasterRestocked'' notification.

The '''KitchenService''' will register for the notifications and act accordingly when received.

==Define the notifications and RPC==

We'll define the 2 notifications and RPC in the ''toaster.yang'' file.

<code>
 module toaster {
    ... 
    '''rpc restock-toaster {
        '''description
          '''"Restocks the toaster with the amount of bread specified.";
        <br>  
        '''input {
            '''leaf amountOfBreadToStock {
                '''type uint32;
                '''description
                  '''"Indicates the amount of bread to re-stock";
            '''}
        '''}
    '''}
    <br>
    '''notification toasterOutOfBread {
      '''description
        '''"Indicates that the toaster has run of out bread.";
    '''}  // notification toasterOutOfStock
    <br>
    '''notification toasterRestocked {
      '''description
        '''"Indicates that the toaster has run of out bread.";
      '''leaf amountOfBread {
        '''type uint32;
        '''description
          '''"Indicates the amount of bread that was re-stocked";
      '''}
    '''}  // notification toasterRestocked
    
  }  // module toaster
</code>

After running 'mvn clean install', several new classes will be generated:
*'''ToasterOutOfBread''' - an interface defining a DTO for the ''toasterOutOfBread'' notification. 
*'''ToasterOutOfBreadBuilder''' - a concrete class for creating '''ToasterOutOfBread''' instances.
*'''ToasterRestocked''' - an interface defining a DTO for the ''toasterRestocked'' notification. 
*'''ToasterRestockedBuilder''' - a concrete class for creating '''ToasterRestocked''' instances.
*'''ToasterOutOfBread''' - interface for consumers of the toaster notifications to implement that defines receipt methods for each notification type.

==Implement notifications and RPC in OpenDaylightToaster==

Next we add code to the '''OpenDaylightToaster''' to implement the ''restockToaster'' RPC and to send the notifications.

<code>
 public class OpendaylightToaster implements ToasterData, ToasterService, ToasterProviderRuntimeMXBean, AutoCloseable {
    ...
    '''private NotificationProviderService notificationProvider;
    ...
    '''private final AtomicLong amountOfBreadInStock = new AtomicLong( 100 );
    ...
    '''public void setNotificationProvider(NotificationProviderService salService) {
        '''this.notificationProvider = salService;
    '''}
    ...
    /**
     * RestConf RPC call implemented from the ToasterService interface.
     */
    @Override
    public Future<RpcResult<Void>> makeToast(MakeToastInput input) {
        ...
        synchronized (taskLock) {
            if (currentTask != null) {
                ...
            }
            '''else if( outOfBread() ) {
                '''RpcResult<Void> result = Rpcs.<Void> getRpcResult(false, null, Arrays.asList(
                        '''RpcErrors.getRpcError( null, null, null, null,
                                               '''"Toaster is out of bread", null, null ) ) );
                '''return Futures.immediateFuture(result);
            '''}
            else {
                ...
            }
        }
        <br>
        updateStatus();
        return currentTask;
    }
    <br>
    '''/**
     '''* RestConf RPC call implemented from the ToasterService interface.
     '''* Restocks the bread for the toaster and sends a ToasterRestocked notification.
     '''*/
    '''@Override
    '''public Future<RpcResult<java.lang.Void>> restockToaster(RestockToasterInput input) {
        '''LOG.info( "restockToaster: " + input );
        '''
        '''synchronized( taskLock ) {
            '''amountOfBreadInStock.set( input.getAmountOfBreadToStock() );
            '''
            '''if( amountOfBreadInStock.get() > 0 ) {
                '''ToasterRestocked reStockedNotification =
                    '''new ToasterRestockedBuilder().setAmountOfBread( input.getAmountOfBreadToStock() ).build();
                '''notificationProvider.publish( reStockedNotification );
            '''}
        '''}
        '''
        '''return Futures.immediateFuture(Rpcs.<Void> getRpcResult(true, Collections.<RpcError> emptySet()));
    '''}
    ...
    '''private boolean checkIfOutOfBread()
    '''{
        '''return amountOfBreadInStock.get() == 0;
    '''}
    <br>
    private class MakeToastTask implements Callable<RpcResult<Void>> {
        ...
        @Override
        public RpcResult<Void> call() throws InterruptedException {
            ...
            toastsMade.incrementAndGet();
            <br>
            '''amountOfBreadInStock.getAndDecrement();
            '''if( outOfBread() ) {
                '''LOG.info( "Toaster is out of bread!" );
                '''
                '''notificationProvider.publish( new ToasterOutOfBreadBuilder().build() );
            '''}
            <br>
            // mark the toaster as "available" for more toasting.
            currentTask = null;
            updateStatus();
            <br>
            return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
        }
    }
}
</code>

==Wire the OpenDaylightToaster for notifications==

The '''OpenDaylightToaster''' needs access to the MD-SAL's '''NotificationProviderService''' in order to send notifications. We need to specify the '''NotificationProviderService''' as a dependency in the toaster-provider-impl module by adding an entry to the '''config:configuration''' augmentation: 
<code>
     augment "/config:modules/config:module/config:configuration" {
        case toaster-consumer-impl {
            when "/config:modules/config:module/config:type = 'toaster-consumer-impl'";
            ...
            <br>
            '''container notification-service {
                '''uses config:service-ref {
                    '''refine type {
                        '''mandatory true;
                        '''config:required-identity mdsal:binding-notification-service;
                    '''}
                '''}
            '''}
        }
    }
</code>

Run 'mvn clean install' to generate the source.

The generated '''AbstractToasterProviderModule''' class should now have a ''getNotificationServiceDependency()'' method. We can access that method in the ''ToasterProviderModule.createInstance()'' method to inject the '''NotificationProviderService''' into the '''OpenDaylightToaster'''.
<pre>
opendaylightToaster.setNotificationProvider(getNotificationServiceDependency());
</pre>

Finally we need to add the dependency for the 'notification-service' to the toaster-provider-impl module in the initial configuration XML file as we did earlier with the 'rpc-registry':
<code>
 <snapshot>
    <configuration>
        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <!-- Specify the configuration for the toaster-provider-impl module as defined in the 
                        toaster-provider-impl.yang file -->
                <module>
                    ...
                    '''<notification-service>
                        '''<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">
                            '''binding:binding-notification-service
                        '''</type>
                        '''<name>binding-notification-broker</name>
                    '''</notification-service>
                </module>
            </modules>
            ...
        </data>
    </configuration>
    ...
 </snapshot>
</code>

==Implement notifications in KitchenServiceImpl==

Next we modify the '''KitchenServiceImpl''' to implement the '''ToasterListener''' interface and the notification methods.
<code>
 public class KitchenServiceImpl implements KitchenService, KitchenServiceRuntimeMXBean, '''ToasterListener''' {
    ...
    '''private volatile boolean toasterOutOfBread;
    <br>
    public KitchenServiceImpl(ToasterService toaster) {
        this.toaster = toaster;
    }
    <br>
    @Override
    public boolean makeBreakfast( EggsType eggs, Class<? extends ToastType> toast, int toastDoneness ) {
        <br>
        '''if( toasterOutOfBread )
        '''{
            '''log.info( "We're out of toast but we can make eggs" );
            '''return true;
        '''}
        <br>
        ...
        return false;
    }
    ...
    '''/**
     '''* Implemented from the ToasterListener interface.
     '''*/
    '''@Override
    '''public void onToasterOutOfBread( ToasterOutOfBread notification ) {
        '''log.info( "ToasterOutOfBread notification" );
        '''toasterOutOfBread = true;
    '''}
    <br>
    '''/**
     '''* Implemented from the ToasterListener interface.
     '''*/
    '''@Override
    '''public void onToasterRestocked( ToasterRestocked notification ) {
        '''log.info( "ToasterRestocked notification - amountOfBread: " + notification.getAmountOfBread() );
        '''toasterOutOfBread = false;
    '''}
 }
</code>

The ''onToasterOutOfBread'' and ''onToasterRestocked'' notification methods simply set and clear the ''toasterOutOfBread''. When called to make breakfast, if ''toasterOutOfBread'', we can't make toast but attempt to make the eggs so someone can at least get something for breakfast.

==Wire the KitchenServiceImpl for notifications==

The '''KitchenServiceImpl''' needs to be registered with the MD-SAL's '''NotificationProviderService''' in order to receive notifications. We need to specify the ''notification-service'' as a dependency in the kitchen-service-impl module by adding an entry to the config:configuration augmentation:
<code>
    augment "/config:modules/config:module/config:configuration" {
        case kitchen-service-impl {
            when "/config:modules/config:module/config:type = 'kitchen-service-impl'";
            ...
            <br>
            '''container notification-service {
                '''uses config:service-ref {
                    '''refine type {
                        '''mandatory true;
                        '''config:required-identity mdsal:binding-notification-service;
                    '''}
                '''}
            '''}
        }
    }
</code>

Run 'mvn clean install' to generate the source.

The generated '''AbstractKitchenServiceModule''' class should now have a ''getNotificationServiceDependency()'' method. We can access that method in the ''KitchenServiceModule.createInstance()'' method to register the '''KitchenServiceImpl''' with the '''NotificationProviderService'''.

<code>
    public java.lang.AutoCloseable createInstance() {
        ...
        '''final Registration<NotificationListener> toasterListenerReg =
                '''getNotificationServiceDependency().registerNotificationListener( kitchenService );
        <br>
        final KitchenServiceRuntimeRegistration runtimeReg =
                getRootRuntimeBeanRegistratorWrapper().register( kitchenService );
        <br>
        final class AutoCloseableKitchenService implements AutoCloseable, KitchenService {
            @Override
            public void close() throws Exception {
                '''toasterListenerReg.close();
                runtimeReg.close();
                log.info("Toaster consumer (instance {}) torn down.", this);
            }
            ...
        }
        ...
    }

</code>

Finally we need to add the dependency for the 'notification-service' to the kitchen-service-impl module in the initial configuration XML file.
<code>
 <snapshot>
   <configuration>
       <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
           <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
               ...
               <module>
                   ...
                   '''<notification-service>
                       '''<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">
                           '''binding:binding-notification-service
                       '''</type>
                       '''<name>binding-notification-broker</name>
                   '''</notification-service>
               </module>
           </modules>
           ...
       </data>
   </configuration>
   ...
 </snapshot>
</code>

==Testing the notifications==

TODO
