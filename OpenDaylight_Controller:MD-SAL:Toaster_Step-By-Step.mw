__TOC__

=Overview=
The following documentation will take you through creating a "toaster" plugin. We will start with simple definitions of a toaster that enable CRUD (create/read/update/delete) of configuration data only, and advance to a sophisticated model that has both remote procedure calls, notifications and a specialized ODL controller which provides additional business logic.

'''NOTE: The follow documentation is a work in progress and may have embedded questions and answers. Look for QUESTION to find existing questions.'''

= Part 1: Simple Toaster CRUD Service - What Toaster do you have? =

Part 1 of the toaster service will define a simple toaster service which will enable CRUD operations via RESTCONF and MD-SAL. To achieve this it is quite simple. In fact you only need to define the yang model, and MD-SAL takes care of the rest!

===Create a New Project===

*Ensure you have downloaded the controller code. See [[OpenDaylight_Controller:Pulling,_Hacking,_and_Pushing_the_Code_from_the_CLI]].
*You can create a project anywhere, but to keep things co-located I would recommend creating a new project under controller/opendaylight/md-sal/samples. 
:*Create a new folder here. Lets call it Toaster.
:*Under the new folder define a src/main/yang directory.
:*Under the new folder, define a pom.xml file which has the following contents:
<pre>
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <artifactId>sal-samples</artifactId>
    <groupId>org.opendaylight.controller.samples</groupId>
    <version>1.1-SNAPSHOT</version>
  </parent>
  <artifactId>single-toaster</artifactId>
  <packaging>bundle</packaging>

  <build>
    <plugins>
      <plugin>
        <groupId>org.opendaylight.yangtools</groupId>
        <artifactId>yang-maven-plugin</artifactId>
        <executions>
          <execution>
            <goals>
              <goal>generate-sources</goal>
            </goals>
            <configuration>
              <yangFilesRootDir>src/main/yang</yangFilesRootDir>
              <codeGenerators>
                <generator>
                  <codeGeneratorClass>org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl</codeGeneratorClass>
                  <outputBaseDir>${salGeneratorPath}</outputBaseDir>
                </generator>
              </codeGenerators>
              <inspectDependencies>true</inspectDependencies>
            </configuration>
          </execution>
        </executions>
        <dependencies>
          <dependency>
            <groupId>org.opendaylight.yangtools</groupId>
            <artifactId>maven-sal-api-gen-plugin</artifactId>
            <version>${yangtools.version}</version>
            <type>jar</type>
          </dependency>
        </dependencies>
      </plugin>
    </plugins>
  </build>
  <dependencies>
    <dependency>
      <groupId>org.opendaylight.yangtools</groupId>
      <artifactId>yang-binding</artifactId>
    </dependency>
    <dependency>
      <groupId>org.opendaylight.yangtools</groupId>
      <artifactId>yang-common</artifactId>
    </dependency>
  </dependencies> 
 </project>
</pre>

The yang-maven-plugin is used to generate java source from yang definition files. Much of the plugin's configuration is boilerplate. Tags of specific interest:

* '''yangFilesRootDir''' - specifies the directory under the project to locate yang files to process. This defaults to src/main/yang.
* '''codeGeneratorClass''' - specifies the code generator to use.  CodeGeneratorImpl is used to generate classes that represent the yang data model constructs.
* '''outputBaseDir''' - specifies the output directory for the generated classes. In the controller project we specify the ${salGeneratorPath} property which is defined in the root pom as src/main/yang-gen-sal.  
  
Optionally at this point, you can import this project into Eclipse.

===Define the Yang Datamodel ===
*Under the src/main/yang directory create a toaster.yang file with the following contents:
<pre>
  //This file contains a YANG data definition. This data model defines
  //a toaster, which is based on the SNMP MIB Toaster example 
  module toaster {

    //The yang version - today only 1 version exists. If ommited defaults to 1.
    yang-version 1; 

    //a unique namespace for this toaster module, to uniquely identify it from other modules that may have the same name.
    namespace
      "http://netconfcentral.org/ns/toaster"; 

    //a shorter prefix that represents the namespace for references used below
    prefix toast;

    //Defines the organization which defined / owns this .yang file.
    organization "Netconf Central";

    //defines the primary contact of this yang file.
    contact
      "Andy Bierman <andy@netconfcentral.org>";

    //provides a description of this .yang file.
    description
      "YANG version of the TOASTER-MIB.";

    //defines the dates of revisions for this yang file
    revision "2009-11-20" {
      description
        "Toaster module in progress.";
    }

    //declares a base identity, in this case a base type for different types of toast.
    identity toast-type {
      description
        "Base for all bread types supported by the toaster. New bread types not listed here nay be added in the future.";
    }

    //the below identity section is used to define globally unique identities
    //Note - removed a number of different types of bread to shorten the text length.
    identity white-bread {
      base toast:toast-type;       //logically extending the declared toast-type above.
      description "White bread.";  //free text description of this type.
    }

    identity wheat-bread {
      base toast-type;
      description "Wheat bread.";
    }

    //defines a new "Type" string type which limits the length
    typedef DisplayString {
      type string {
        length "0 .. 255";
      }
      description
        "YANG version of the SMIv2 DisplayString TEXTUAL-CONVENTION.";
      reference
        "RFC 2579, section 2.";

    }

    // This definition is the top-level configuration "item" that defines a toaster. The "presence" flag connotes there
    // can only be one instance of a toaster which, if present, indicates the service is available.
    container toaster {
      presence
        "Indicates the toaster service is available";
      description
        "Top-level container for all toaster database objects.";

      //QUESTION: Should config = true here? Manufacturer and model number do not change
      //at run time - they are more configuration than state....
      leaf toasterManufacturer {
        type DisplayString;
        config false;
        mandatory true;
        description
          "The name of the toaster's manufacturer. For instance, Microsoft Toaster.";
      }

      leaf toasterModelNumber {
        type DisplayString;
        config false;
        mandatory true;
        description
          "The name of the toaster's model. For instance, Radiant Automatic.";
      }

      //notice how we restrict the allowed values in this attribute
      //Config = false indicates that this is state data - i.e. data that
      //can change which the system is running.
      leaf toasterStatus {
        type enumeration {
          enum "up" {
            value 1;
            description
              "The toaster knob position is up. No toast is being made now.";
          }
          enum "down" {
            value 2;
            description
              "The toaster knob position is down. Toast is being made now.";
          }
        }
        config false;
        mandatory true;
        description
          "This variable indicates the current state of  the toaster.";
      }
    }  // container toaster
  }  // module toaster

</pre>

==Build & Deploy ==

We are now ready to build the toaster data model bundle. After running 'mvn install', you will see java class files generated under src/main/yang-gen-sal.  Classes of note:

* '''Toaster''' - an interface that represents the toaster container with methods to obtain the leaf node data.
* '''ToasterData''' - an interface that represents the top-level toaster module with one method ''getToaster()'' that returns the singleton toaster instance.
* '''WheatBread''', '''WhiteBread'', etc' - abstract classes that represent the various toast types.
* '''$YangModelBindingProvider''', '''$YangModuleInfoImpl''' - these are used internally by MD-SAL to wire the toaster module for use. More on this later.  

To deploy, copy the bundle jar under target to the distribution plugin directory and invoke run.sh.

==Using the Toaster with RestConf ==

=== Create the Toaster ===

To create the toaster instance,  issue a REST POST (you will need a rest client such as [http://%5Bhttps://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en%20Install%20Postman%20for%20Chrome%5D PostMan for google chrome]):
:<code>
 URL => http://localhost:8080/restconf/config 
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster:toaster" :
    {
      "toaster:toasterManufacturer" : "General Electric",
      "toaster:toasterModelNumber" : "123",
      "toaster:toasterStatus" : "up"
     }
 }
 </code>
:''Note: You will likely see an exception on the OSGi terminal, and the return error code will be a 204, "No data returned". This means it succeeded!''

=== Get the Toaster ===

To get the current toaster instance via REST,  issue an HTTP GET:
:<code>
 URL => http://localhost:8080/restconf/config/toaster:toaster 
 </code>
This should return json defining the toaster, and should provide similar values to what you posted.

=== Update the Toaster ===

To update the toaster instance,  issue a REST PUT:
:<code>
 URL => http://localhost:8080/restconf/config/toaster:toaster
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster": {
        "toasterStatus": "up",
        "toasterManufacturer": "Oster",
        "toasterModelNumber": "ABC"
    }
 }
 </code>

=== Delete the Toaster ===
To delete the current toaster via REST,  issue an HTTP DELETE:
:<code>
 URL => http://localhost:8080/restconf/config/toaster:toaster 
 </code>

QUESTION: An exception prints out in the osgi terminal when you do a post or delete - do we understand the cause? What is the expected return for the post / delete?

So by just defining a yang data model file and deploying a bundle containing the generated classes, we were able to perform CRUD operations on the toaster. We didn't write a single line of java code. You might be wondering how the MD-SAL managed to wire it together. If so, read on.

The magic is done via the ''META-INF/yang/toaster.yang'' and ''META-INF/services/org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' files that are inserted into the toaster bundle by the yang-maven-plugin. The ''toaster.yang'' file is copied from the src/main/yang directory. The ''org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' file contains the fully-qualfied name of the toaster's generated '''$YangModelBindingProvider''' class. The MD-SAL's '''ModuleInfoBundleTracker''' class in the config subsystem scrapes the ''META-INF/services/org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' resource from bundles on startup and reads the class name(s) defined in the file.  For each YangModelBindingProvider class specified, the MD-SAL creates an instance and calls ''getModuleInfo()'' to return the singleton '''$YangModuleInfoImpl''' instance. This class has methods to obtain static configuration information about the yang module, e.g. name, revision, imports etc, as well as a ''getModuleSourceStream()'' method that provides an input stream to the ''META-INF/yang/toaster.yang'' file. Once the MD-SAL knows about a yang module and its definitions, it can wire it up to RestConf and other parts of the system.

= Part 2: Enabling Remote Procedure Calls - Lets make some toast!=

Part 2 of the toaster example will be adding some behavior to the toaster. Having a toaster is cool but we'd really like it to make some toast for us. To accomplish this, we will define RPC calls in the toaster yang data model and write an implementation.

===Define the yang RPC===

In the toaster.yang file, we will define 2 RPC methods, make-toast and cancel-toast:

<pre>
    //This defines a Remote Procedure Call (rpc). RPC provide the ability to initiate an action
    //on the data model. In this case the initating action takes two optional inputs (because default value is defined)
    rpc make-toast {
      description
        "Make some toast. The toastDone notification will be sent when the toast is finished.
         An 'in-use' error will be returned if toast is already being made. A 'resource-denied' error will 
         be returned if the toaster service is disabled.";

      input {
        leaf toasterDoneness {
          type uint32 {
            range "1 .. 10";
          }
          default '5';
          description
            "This variable controls how well-done is the ensuing toast. It should be on a scale of 1 to 10.
             Toast made at 10 generally is considered unfit for human consumption; toast made at 1 is warmed lightly.";
        }

        leaf toasterToastType {
          type identityref {
            base toast:toast-type;
          }
          default 'wheat-bread';
          description
            "This variable informs the toaster of the type of material that is being toasted. The toaster uses this information, 
              combined with toasterDoneness, to compute for how long the material must be toasted to achieve the required doneness.";
        }
      }
    }  // rpc make-toast

    // action to cancel making toast - takes no input parameters
    rpc cancel-toast {
      description
        "Stop making toast, if any is being made.
           A 'resource-denied' error will be returned 
           if the toaster service is disabled.";
    }  // rpc cancel-toast
</pre>

Running 'mvn install', we see the following additional classes generated:

*'''ToasterService''' - an interface that extends '''RpcService''' and defines the RPC methods corresponding to the yang data model.
*'''MakeToastInput''' - an interface defining a DTO providing the input parameters for the make-toast call. 
*'''MakeToastInputBuilder''' - a concrete class for creating MakeToastInput instances.

===Implement the RPC methods===

We've defined the data model interface for the RPC calls - now we must provide the implementation. We'll create a class called OpendaylightToaster which implements the ToasterService and ToasterData interfaces: 
<pre>
public class OpendaylightToaster implements ToasterData, ToasterService, AutoCloseable {
    private final ExecutorService executor;
    private Future<RpcResult<Void>> currentTask;

    public OpendaylightToaster() {
        executor = Executors.newFixedThreadPool(1);
    }

    @Override
    public synchronized Future<RpcResult<Void>> cancelToast() {
        if (currentTask != null) {
            currentTask.cancel(true);
        }
        return null;
    }

    @Override
    public synchronized Future<RpcResult<Void>> makeToast(MakeToastInput input) {
        log.debug("makeToast - Received input for toast");
 
        if (currentTask != null) {
            return inProgressError();
        }
        currentTask = executor.submit(new MakeToastTask(input));
        return currentTask;
    }

    private Future<RpcResult<Void>> inProgressError() {
        RpcResult<Void> result = Rpcs.<Void> getRpcResult(false, null, Collections.<RpcError> emptySet());
        return Futures.immediateFuture(result);
    }

    @Override
    public void close() throws Exception {
    }
    
    @Override
    public synchronized Toaster getToaster() {
        ToasterBuilder tb = new ToasterBuilder();
        tb.setToasterManufacturer(toasterManufacturer) 
           .setToasterModelNumber(toasterModelNumber) 
           .setToasterStatus(currentTask == null ? ToasterStatus.Up : ToasterStatus.Down);

        return tb.build();
    }

    private class MakeToastTask implements Callable<RpcResult<Void>> {
        final MakeToastInput toastRequest;

        public MakeToastTask(MakeToastInput toast) {
            toastRequest = toast;
        }

        @Override
        public RpcResult<Void> call() throws InterruptedException {
            Thread.sleep(1000 * toastRequest.getToasterDoneness());

            log.debug("Toast Done");
           
            currentTask = null;
            return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
        }
    }
}
</pre>

The ''makeToast'' method simply sleeps for the number of seconds specified by 'toasterDoneness' and returns.

QUESTION: Does it need to implement ToasterData? <br>
QUESTION: The Toaster instance returned from getToaster() is essentially a hard-coded instance. The code in the actual toaster sample in the controller project also updates the Toaster instance's status and stores it in the DataBroker service.  However this Toaster instance isn't returned from REST GET and nor is the OpenDaylightToaster aware of the Toaster created via REST. There's seems to be a disconnect between the OpenDaylightToaster and RestConf CRUD.

===Wiring the ToasterService implementation===

We've implemented the ToasterService - now we have to get our OpendaylightToaster instantiated and wired up with the MD-SAL. There's a couple ways to do this - we're going to use the MD-SAL's config subsystem which provides the most flexibility. We first need to describe our OpendaylightToaster service and what dependent services it needs for the MD_SAL to process. This is defined in... you guessed it, yang.

We define a ''toaster-provider.yang'' file as follows:
<pre>
module toaster-provider {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider";
    prefix "toaster-provider";

    import config { prefix config; revision-date 2013-04-05; }

    description
        "This module contains the base YANG definitions for toaster-provider services.";

    revision "2014-01-31" 
        description
            "Initial revision.";
    }

    // This is the definition or interface of the provider service
    identity toaster-provider {
        base "config:service-type"; // 

        // This is binding to the ToasterData class generated by the toaster.yang model. 
        // This is saying that "I am the provider for the module toaster".
        config:java-class "org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.ToasterData";
    }
}
</pre>

The toaster-provider identity is a '''service-type''' which means it's basically acting as an interface for the toaster module.

Next we need to define the/an implementation of the toaster-provider service yang interface in the ''toaster-provider-impl.yang'' file:
<pre>
module toaster-provider-impl {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl";
    prefix "toaster-provider-impl";

    import config { prefix config; revision-date 2013-04-05; }
    import toaster-provider { prefix toaster-provider; revision-date 2014-01-31; }
    import opendaylight-md-sal-binding { prefix mdsal; revision-date 2013-10-28; }

    description
        "This module contains the base YANG definitions for toaster-provider impl implementation.";

    revision "2014-01-31" {
        description
            "Initial revision.";
    }

    // This is the definition of a service implementation
    identity toaster-provider-impl {
            base config:module-type;
            config:provided-service toaster-provider:toaster-provider;
            config:java-name-prefix ToasterProvider;
    }

    //augments the configuration,  
    augment "/config:modules/config:module/config:configuration" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";

            //Wires dependent services into this class - in this case the RPC registry service
            container rpc-registry {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-rpc-registry;
                    }
                }
            }           
        }
    }
}
</pre>

The toaster-provider-impl identity is a '''module-type''' which is effectively providing an implementation of the toaster-provider service interface at the ''/modules/module'' level in the MD_SAL's configuration data tree. The augmentation of ''modules/module/configuration'' adds configuration information for the toaster-provider-impl data node. 'rpc-registry' defines a dependency of the toaster-provider-impl module on the MD-SAL's RPC registry service.   (TODO - need more info here?)

These 2 yang files generate several classes, of note are the 2 that are generated under src/man/yang:

*'''ToasterProviderModule''' -  concrete class whose ''createInstance()'' method provides the OpendaylightToaster instance.
*'''ToasterProviderModuleFactory''' - concrete class instantiated internally by MD_SAL that creates '''ToasterProviderModule''' instances.  

These 2 classes are intended to be checked into Git and the ''ToasterProviderModule.createInstance()'' method needs to be implemented to instantiate and wire the OpendaylightToaster:

<pre>
    @Override
    public java.lang.AutoCloseable createInstance() {
        final OpendaylightToaster opendaylightToaster = new OpendaylightToaster();

        // Register our OpendaylightToaster instance as the RPC implementation for the ToasterService.
        final BindingAwareBroker.RpcRegistration<ToasterService> rpcRegistration = getRpcRegistryDependency()
                .addRpcImplementation(ToasterService.class, opendaylightToaster);

        // Wrap toaster as AutoCloseable and close registrations to md-sal at
        // close()
        final class AutoCloseableToaster implements AutoCloseable, ToasterData {

            @Override
            public void close() throws Exception {
                rpcRegistration.close();
                opendaylightToaster.close();
            }

            @Override
            public Toaster getToaster() {
                return opendaylightToaster.getToaster();
            }
        }

        AutoCloseable ret = new AutoCloseableToaster();
        return ret;
    }
</pre>

TODO: Add new pom.xml dependencies on md-sal core - also need to add the JMXGenerator <br>

TODO: Do a new clean / build - new files generated <br>

TODO: Define a netconf configuration data file in configuration/initial which defines  the modules and services - see example. This becomes the startup config starts the wiring process<br>

===Invoke make-toast via RestConf===

===cancel-toast via RestConf===

= Part 3: Notifications - Tell me when my Toast is done! =

Under construction - please come back soon!

= Part 4: ODL Controller Extension - Using MD-Sal  =

Under construction - please come back soon!
