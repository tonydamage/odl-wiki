__TOC__

=Overview=
The following documentation will take you through creating a "toaster" plugin. We will start with simple definitions of a toaster that enable CRUD (create/read/update/delete) of configuration data only, and advance to a sophisticated model that has both remote procedure calls, notifications and a specialized ODL controller which provides additional business logic.

'''NOTE: The follow documentation is a work in progress and may have embedded questions and answers. Look for QUESTION to find existing questions.'''

= Part 1: Simple Toaster CRUD Service - What Toaster do you have? =

Part 1 of the toaster service will define a simple toaster service which will enable CRUD operations via RESTCONF and MD-SAL. To achieve this it is quite simple. In fact you only need to define the yang model, and MD-SAL takes care of the rest!

===Create a New Project===

*Ensure you have downloaded the controller code. See [[OpenDaylight_Controller:Pulling,_Hacking,_and_Pushing_the_Code_from_the_CLI]].
*You can create a project anywhere, but to keep things co-located I would recommend creating a new project under controller/opendaylight/md-sal/samples. 
:*Create a new folder here. Lets call it Toaster.
:*Under the new folder define a src/main/yang directory.
:*Under the new folder, define a pom.xml file which has the following contents:
<pre>
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <artifactId>sal-samples</artifactId>
    <groupId>org.opendaylight.controller.samples</groupId>
    <version>1.1-SNAPSHOT</version>
  </parent>
  <artifactId>single-toaster</artifactId>
  <packaging>bundle</packaging>

  <build>
    <plugins>
      <plugin>
        <groupId>org.opendaylight.yangtools</groupId>
        <artifactId>yang-maven-plugin</artifactId>
        <executions>
          <execution>
            <goals>
              <goal>generate-sources</goal>
            </goals>
            <configuration>
              <yangFilesRootDir>src/main/yang</yangFilesRootDir>
              <codeGenerators>
                <generator>
                  <codeGeneratorClass>org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl</codeGeneratorClass>
                  <outputBaseDir>${salGeneratorPath}</outputBaseDir>
                </generator>
              </codeGenerators>
              <inspectDependencies>true</inspectDependencies>
            </configuration>
          </execution>
        </executions>
        <dependencies>
          <dependency>
            <groupId>org.opendaylight.yangtools</groupId>
            <artifactId>maven-sal-api-gen-plugin</artifactId>
            <version>${yangtools.version}</version>
            <type>jar</type>
          </dependency>
        </dependencies>
      </plugin>
    </plugins>
  </build>
  <dependencies>
    <dependency>
      <groupId>org.opendaylight.yangtools</groupId>
      <artifactId>yang-binding</artifactId>
    </dependency>
    <dependency>
      <groupId>org.opendaylight.yangtools</groupId>
      <artifactId>yang-common</artifactId>
    </dependency>
  </dependencies> 
 </project>
</pre>

The yang-maven-plugin is used to generate java source from yang definition files. Much of the plugin's configuration is boilerplate. Tags of specific interest:

* '''yangFilesRootDir''' - specifies the directory under the project to locate yang files to process. This defaults to src/main/yang.
* '''codeGeneratorClass''' - specifies the code generator to use.  CodeGeneratorImpl is used to generate classes that represent the yang data model constructs.
* '''outputBaseDir''' - specifies the output directory for the generated classes. In the controller project we specify the ${salGeneratorPath} property which is defined in the root pom as src/main/yang-gen-sal.  
  
Optionally at this point, you can import this project into Eclipse.

===Define the Yang Datamodel ===
*Under the src/main/yang directory create a toaster.yang file with the following contents:
<pre>
  //This file contains a YANG data definition. This data model defines
  //a toaster, which is based on the SNMP MIB Toaster example 
  module toaster {

    //The yang version - today only 1 version exists. If ommited defaults to 1.
    yang-version 1; 

    //a unique namespace for this toaster module, to uniquely identify it from other modules that may have the same name.
    namespace
      "http://netconfcentral.org/ns/toaster"; 

    //a shorter prefix that represents the namespace for references used below
    prefix toast;

    //Defines the organization which defined / owns this .yang file.
    organization "Netconf Central";

    //defines the primary contact of this yang file.
    contact
      "Andy Bierman <andy@netconfcentral.org>";

    //provides a description of this .yang file.
    description
      "YANG version of the TOASTER-MIB.";

    //defines the dates of revisions for this yang file
    revision "2009-11-20" {
      description
        "Toaster module in progress.";
    }

    //declares a base identity, in this case a base type for different types of toast.
    identity toast-type {
      description
        "Base for all bread types supported by the toaster.
           New bread types not listed here nay be added in the 
           future.";
    }

    //the below identity section is used to define globally unique identities
    //Note - removed a number of different types of bread to shorten the text length.
    identity white-bread {
      base toast:toast-type;       //logically extending the declared toast-type above.
      description "White bread.";  //free text description of this type.
    }

    identity wheat-bread {
      base toast-type;
      description "Wheat bread.";
    }

    //defines a new "Type" string type which limits the length
    typedef DisplayString {
      type string {
        length "0 .. 255";
      }
      description
        "YANG version of the SMIv2 DisplayString TEXTUAL-CONVENTION.";
      reference
        "RFC 2579, section 2.";

    }

    // This definition is the top-level configuration "item" that defines a toaster. The "presence" flag connotes there
    // can only be one instance of a toaster which, if present, indicates the service is available.
    container toaster {
      presence
        "Indicates the toaster service is available";
      description
        "Top-level container for all toaster database objects.";

      //QUESTION: Should config = true here? Manufacturer and model number do not change
      //at run time - they are more configuration than state....
      leaf toasterManufacturer {
        type DisplayString;
        config false;
        mandatory true;
        description
          "The name of the toaster's manufacturer. For instance, 
                Microsoft Toaster.";
      }

      leaf toasterModelNumber {
        type DisplayString;
        config false;
        mandatory true;
        description
          "The name of the toaster's model. For instance,
               Radiant Automatic.";
      }

      //notice how we restrict the allowed values in this attribute
      //Config = false indicates that this is state data - i.e. data that
      //can change which the system is running.
      leaf toasterStatus {
        type enumeration {
          enum "up" {
            value 1;
            description
              "The toaster knob position is up. No toast is being made now.";
          }
          enum "down" {
            value 2;
            description
              "The toaster knob position is down. Toast is being made now.";
          }
        }
        config false;
        mandatory true;
        description
          "This variable indicates the current state of  the toaster.";
      }
    }  // container toaster
  }  // module toaster

</pre>

==Build & Deploy ==

We are now ready to build the toaster data model bundle. After running 'mvn install', you will see java class files generated under src/main/yang-gen-sal.  Classes of note:

* '''Toaster''' - an interface that represents the toaster container with methods to obtain the leaf node data.
* '''ToasterData''' - an interface that represents the top-level toaster module with one method ''getToaster()'' that returns the singleton toaster instance.
* '''WheatBread''', '''WhiteBread'', etc' - abstract classes that represent the various toast types.
* '''$YangModelBindingProvider''', '''$YangModuleInfoImpl''' - these are used internally by MD-SAL to wire the toaster module for use. More on this later.  

To deploy, copy the bundle jar under target to the distribution plugin directory and invoke run.sh.

==Using the Toaster with RestConf ==

=== Create the Toaster ===

To create the toaster instance,  issue a REST POST (you will need a rest client such as PostMan for google chrome):
:<code>
 URL => http://localhost:8080/restconf/config 
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster:toaster" :
    {
      "toaster:toasterManufacturer" : "General Electric",
      "toaster:toasterModelNumber" : "123",
      "toaster:toasterStatus" : "up"
     }
 }
 </code>
:''Note: You will likely see an exception on the OSGi terminal, and the return error code will be a 204, "No data returned". This means it succeeded!''

=== Get the Toaster ===

To get the current toaster instance via REST,  issue an HTTP GET:
:<code>
 URL => http://localhost:8080/restconf/config/toaster:toaster 
 </code>
This should return json defining the toaster, and should provide similar values to what you posted.

=== Update the Toaster ===

To update the toaster instance,  issue a REST PUT:
:<code>
 URL => http://localhost:8080/restconf/config/toaster:toaster
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster": {
        "toasterStatus": "up",
        "toasterManufacturer": "Oster",
        "toasterModelNumber": "ABC"
    }
 }
 </code>

=== Delete the Toaster ===


So by just defining a yang data model file and deploying a bundle containing the generated classes, we were able to perform CRUD operations on the toaster. We didn't write a single line of java code. You might be wondering how the MD-SAL managed to wire it together. If so, read on.

The magic is done via the ''META-INF/yang/toaster.yang'' and ''META-INF/services/org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' files that are inserted into the toaster bundle by the yang-maven-plugin. The ''toaster.yang'' file is copied from the src/main/yang directory. The ''org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' file contains the fully-qualfied name of the toaster's generated '''$YangModelBindingProvider''' class. The MD-SAL's '''ModuleInfoBundleTracker''' class in the config subsystem scrapes the ''META-INF/services/org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' resource from bundles on startup and reads the class name(s) defined in the file.  For each YangModelBindingProvider class specified, the MD-SAL creates an instance and calls ''getModuleInfo()'' to return the singleton '''$YangModuleInfoImpl''' instance. This class has methods to obtain static configuration information about the yang module, e.g. name, revision, imports etc, as well as a ''getModuleSourceStream()'' method that provides an input stream to the ''META-INF/yang/toaster.yang'' file. Once the MD-SAL knows about a yang module and its definitions, it can wire it up to RestConf and other parts of the system.

= Part 2: Enabling Remote Procedure Calls - Lets make some toast!=

Under construction - please come back soon!

= Part 3: Notifications - Tell me when my Toast is done! =

Under construction - please come back soon!

= Part 4: ODL Controller Extension - Using MD-Sal  =

Under construction - please come back soon!
