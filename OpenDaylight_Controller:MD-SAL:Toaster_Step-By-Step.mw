__TOC__

=Overview=
The following documentation will take you through creating a "toaster" plugin from scratch. We will start with simple definitions of a toaster that enable CRUD (create/read/update/delete) of configuration data only, and advance to a sophisticated model that has both remote procedure calls, notifications and a specialized ODL controller which provides additional business logic.

<br><br>'''If you are looking for an overview of the prebuilt Toaster sample, along with discussions of how the classes interact with eachother, check out the [https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Toaster_Tutorial Toaster Tutorial]'''

<br><br>'''NOTE: The follow documentation is a work in progress and may have embedded questions and answers. Look for QUESTION to find existing questions.'''

====Toaster Parts====
There are four parts that make up this toaster step-by-step example. During this example we illustrate how the yang model is providing abstraction for us, and how MD-SAL provides the plumbing (wiring) to hook everything up.

*'''Part 1''' of this example defines the North Bound interface for the toaster. This is the highest level of abstraction, which normalizes the view of a toaster to any north bound clients (i.e. applications). The yang file we define here contains all of the RPC and attributes required by all toaster implementations. In this first part we only define the yang file which enables CRUD on the generic toaster interface, but provides no remote calls.
*'''Part 2''' of this example uses yang to take the abstract one step further. It enhances the original yang file by adding in a Remote Procedure Call (RPC) call (thus exposing that RPC call to all North Bound clients). Then using a new yang file, defines an "interface" for all implementations. Finally in a third yang file we define one possible implementation and will be enhanced in the remaining parts to add additional functionality that the north bound implementation will not be aware of.
*'''Part 3''' of this example will add in the concept of operational data to the toaster. Specifically, this stage will enable an operational call to toaster to determine if the toaster is "up" or "down". This example will illustrait how our intelligence can interact with the data store during RPCs.
*'''Part 4''' of this example will provide additional attributes not present in the north bound interface, but available by the implementation. Specifically a count of the number of pieces of toaster that were successfully created by this toaster since it was defined. '''QUESTION: Is this a correct statement?'''
*'''Part 5''' will expand on our example adding in an example notification system. This notification system allows the implementation to send notifications out to registered listeners telling them when some event occurs (in our case when a piece of toast is done).
*'''Part 6''' will add the final piece to this example, where we provide a demonstration of how other business intelligence in the controller can access the data models and invoke RPC calls and gain access to configuration data for the purpose of providing additional business logic in the controller.

= Part 1: Simple Toaster CRUD Service - What Toaster do you have? (Config Data)=

Part 1 of the toaster service will define a simple toaster service which will enable CRUD operations via RESTCONF and MD-SAL. To achieve this it is quite simple. In fact you only need to define the yang model, and MD-SAL takes care of the rest!

===Create a New Project===

*Ensure you have downloaded the controller code. See [[OpenDaylight_Controller:Pulling,_Hacking,_and_Pushing_the_Code_from_the_CLI]].
*You can create a project anywhere, but to keep things co-located I would recommend creating a new project under controller/opendaylight/md-sal/samples. 
:*Create a new folder here. Lets call it Toaster.
:*Under the new folder define a src/main/yang directory.
<pre>
cd controller/opendaylight/md-sal/samples
mkdir Toaster
cd Toaster
vi pom.xml
</pre>
:*Under the new folder, define a pom.xml file which has the following contents:
<pre>
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <artifactId>sal-samples</artifactId>
    <groupId>org.opendaylight.controller.samples</groupId>
    <version>1.1-SNAPSHOT</version>
  </parent>
  <artifactId>single-toaster</artifactId>
  <packaging>bundle</packaging>

  <build>
    <plugins>
      <plugin>
        <groupId>org.opendaylight.yangtools</groupId>
        <artifactId>yang-maven-plugin</artifactId>
        <executions>
          <execution>
            <goals>
              <goal>generate-sources</goal>
            </goals>
            <configuration>
              <yangFilesRootDir>src/main/yang</yangFilesRootDir>
              <codeGenerators>
                <generator>
                  <codeGeneratorClass>org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl</codeGeneratorClass>
                  <outputBaseDir>${salGeneratorPath}</outputBaseDir>
                </generator>
              </codeGenerators>
              <inspectDependencies>true</inspectDependencies>
            </configuration>
          </execution>
        </executions>
        <dependencies>
          <dependency>
            <groupId>org.opendaylight.yangtools</groupId>
            <artifactId>maven-sal-api-gen-plugin</artifactId>
            <version>${yangtools.version}</version>
            <type>jar</type>
          </dependency>
        </dependencies>
      </plugin>
    </plugins>
  </build>
  <dependencies>
    <dependency>
      <groupId>org.opendaylight.yangtools</groupId>
      <artifactId>yang-binding</artifactId>
    </dependency>
    <dependency>
      <groupId>org.opendaylight.yangtools</groupId>
      <artifactId>yang-common</artifactId>
    </dependency>
  </dependencies> 
 </project>
</pre>

The yang-maven-plugin is used to generate java source from yang definition files. Much of the plugin's configuration is boilerplate. Tags of specific interest:

* '''yangFilesRootDir''' - specifies the directory under the project to locate yang files to process. This defaults to src/main/yang.
* '''codeGeneratorClass''' - specifies the code generator to use.  CodeGeneratorImpl is used to generate classes that represent the yang data model constructs.
* '''outputBaseDir''' - specifies the output directory for the generated classes. In the controller project we specify the ${salGeneratorPath} property which is defined in the root pom as src/main/yang-gen-sal.  
  
Optionally at this point, you can import this project into Eclipse.

===Define the Yang Datamodel ===
<pre>
mkdir -p src/main/yang
cd src/main/yang
vi toaster.yang
</pre>
*Under the src/main/yang directory create a toaster.yang file with the following contents:
<pre>
  //This file contains a YANG data definition. This data model defines
  //a toaster, which is based on the SNMP MIB Toaster example 
  module toaster {

    //The yang version - today only 1 version exists. If ommited defaults to 1.
    yang-version 1; 

    //a unique namespace for this toaster module, to uniquely identify it from other modules that may have the same name.
    namespace
      "http://netconfcentral.org/ns/toaster"; 

    //a shorter prefix that represents the namespace for references used below
    prefix toast;

    //Defines the organization which defined / owns this .yang file.
    organization "Netconf Central";

    //defines the primary contact of this yang file.
    contact
      "Andy Bierman <andy@netconfcentral.org>";

    //provides a description of this .yang file.
    description
      "YANG version of the TOASTER-MIB.";

    //defines the dates of revisions for this yang file
    revision "2009-11-20" {
      description
        "Toaster module in progress.";
    }

    //declares a base identity, in this case a base type for different types of toast.
    identity toast-type {
      description
        "Base for all bread types supported by the toaster. New bread types not listed here nay be added in the future.";
    }

    //the below identity section is used to define globally unique identities
    //Note - removed a number of different types of bread to shorten the text length.
    identity white-bread {
      base toast:toast-type;       //logically extending the declared toast-type above.
      description "White bread.";  //free text description of this type.
    }

    identity wheat-bread {
      base toast-type;
      description "Wheat bread.";
    }

    //defines a new "Type" string type which limits the length
    typedef DisplayString {
      type string {
        length "0 .. 255";
      }
      description
        "YANG version of the SMIv2 DisplayString TEXTUAL-CONVENTION.";
      reference
        "RFC 2579, section 2.";

    }

    // This definition is the top-level configuration "item" that defines a toaster. The "presence" flag connotes there
    // can only be one instance of a toaster which, if present, indicates the service is available.
    container toaster {
      presence
        "Indicates the toaster service is available";
      description
        "Top-level container for all toaster database objects.";

      //QUESTION: Should config = true here? Manufacturer and model number do not change
      //at run time - they are more configuration than state....
      leaf toasterManufacturer {
        type DisplayString;
        config false;
        mandatory true;
        description
          "The name of the toaster's manufacturer. For instance, Microsoft Toaster.";
      }

      leaf toasterModelNumber {
        type DisplayString;
        config false;
        mandatory true;
        description
          "The name of the toaster's model. For instance, Radiant Automatic.";
      }

      //notice how we restrict the allowed values in this attribute
      //Config = false indicates that this is state data - i.e. data that
      //can change which the system is running.
      leaf toasterStatus {
        type enumeration {
          enum "up" {
            value 1;
            description
              "The toaster knob position is up. No toast is being made now.";
          }
          enum "down" {
            value 2;
            description
              "The toaster knob position is down. Toast is being made now.";
          }
        }
        config false;
        mandatory true;
        description
          "This variable indicates the current state of  the toaster.";
      }
    }  // container toaster
  }  // module toaster

</pre>

==Build & Deploy ==
We are now ready to build the toaster data model bundle. After running 'mvn install', you will see java class files generated under ''src/main/yang-gen-sal''.  Classes of note:

* '''Toaster''' - an interface that represents the toaster container with methods to obtain the leaf node data.
* '''ToasterData''' - an interface that represents the top-level toaster module with one method ''getToaster()'' that returns the singleton toaster instance.
* '''WheatBread''', '''WhiteBread''', etc' - abstract classes that represent the various toast types.
* '''$YangModelBindingProvider''', '''$YangModuleInfoImpl''' - these are used internally by MD-SAL to wire the toaster module for use. More on this later.  

To deploy, first you will want to remove the pre-developed toaster example from the plugins directory (this is a one time step, unless you rebuild the distributions.opendaylight project).
<pre>
#note the below line removes 3 jars related to the toaster sample.
rm ../../../distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight/plugins/org.opendaylight.controller.samples.sample-toaster*
rm ../../../distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight/configuration/initial/03-toaster-sample.xml
</pre>
To deploy, copy the bundle jar under target to the distribution plugin directory and invoke run.sh.
<pre>
cp target/single-toaster-1.1-SNAPSHOT.jar ../../../distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight/plugins
cd ../../../distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight
./run.sh
</pre>

==Using the Toaster with RestConf ==

=== Create the Toaster ===

To create the toaster instance,  issue a REST POST (you will need a rest client such as [https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en%20Install%20Postman%20for%20Chrome Postman for Google Chrome]):
:<code>
 URL => http://localhost:8080/restconf/config 
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster:toaster" :
    {
      "toaster:toasterManufacturer" : "General Electric",
      "toaster:toasterModelNumber" : "123",
      "toaster:toasterStatus" : "up"
     }
 }
 </code>
:''Note: You will likely see an exception on the OSGi terminal, and the return error code will be a 204, "No data returned". This means it succeeded!'' '''QUESTION: What if any is the expected output? Seems like we should be returning the content that we posted or something. Either way we definitely need to address the exception. [https://bugs.opendaylight.org/show_bug.cgi?id=442 Bug 422] captures a similar error.'''

=== Get the Toaster ===

To get the current toaster instance via REST,  issue an HTTP GET:
:<code>
 URL => http://localhost:8080/restconf/config/toaster:toaster 
 </code>
This should return json defining the toaster, and should provide similar values to what you posted.
<br>
*If you add "Accept: application/yang.data+xml" in the request headers, XML will be returned instead of json.
<br>
QUESTION: Why do we separate operational from config? See restconf specification has combined config and operational data under /restconf/data ?? [http://tools.ietf.org/html/draft-ietf-netconf-restconf-00#section-4.3.1]

=== Update the Toaster ===

To update the toaster instance,  issue a REST PUT:
:<code>
 URL => http://localhost:8080/restconf/config/toaster:toaster
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster": {
        "toasterStatus": "up",
        "toasterManufacturer": "Oster",
        "toasterModelNumber": "ABC"
    }
 }
 </code>
''Note: You can also use the above call to create the initial toaster as well.''

=== Delete the Toaster ===
To delete the current toaster via REST,  issue an HTTP DELETE:
:<code>
 URL => http://localhost:8080/restconf/config/toaster:toaster 
 </code>

QUESTION: An exception prints out in the osgi terminal when you do a post or delete - do we understand the cause? What is the expected return for the post / delete? [https://bugs.opendaylight.org/show_bug.cgi?id=442 Bug 422] captures a similar error.'<br><br>
QUESTION: Should we even be allowed to delete this data? Seems the restconf ietf draft tell us that we can't....

== How Does MD-SAL Know about my Toaster? ==
So by just defining a yang data model file and deploying a bundle containing the generated classes, we were able to perform CRUD operations on the toaster. We didn't write a single line of java code. You might be wondering how the MD-SAL managed to wire it together. If so, read on.

The magic is done via the ''META-INF/yang/toaster.yang'' and ''META-INF/services/org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' files that are inserted into the toaster bundle by the yang-maven-plugin (to see these files, examine the target/classes/META-INF/... directory after running a build). 
*The ''toaster.yang'' file is copied from the src/main/yang directory. 
*The ''org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' file contains the fully-qualfied name of the toaster's generated '''$YangModelBindingProvider''' class. The MD-SAL's '''ModuleInfoBundleTracker''' class in the config subsystem scrapes the ''META-INF/services/org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' resource from bundles on startup and reads the class name(s) defined in the file.  For each YangModelBindingProvider class specified, the MD-SAL creates an instance and calls ''getModuleInfo()'' to return the singleton '''$YangModuleInfoImpl''' instance. This class has methods to obtain static configuration information about the yang module, e.g. name, revision, imports etc, as well as a ''getModuleSourceStream()'' method that provides an input stream to the ''META-INF/yang/toaster.yang'' file. Once the MD-SAL knows about a yang module and its definitions, it can wire it up to RestConf and other parts of the system.

= Part 2: Enabling Remote Procedure Calls - Lets make some toast!=

Part 2 of the toaster example will be adding some behavior to the toaster. Having a toaster is cool but we'd really like it to make some toast for us. To accomplish this, we will define RPC calls in the toaster yang data model and write an implementation. 

In this part we will start to show how the yang data models are providing the abstraction for us. We have the toaster.yang file which is defining the northbound API. We then define additional .yang files to abstract away the implementations. '''Question: Is this a correct interpretation?'''

===Define the yang RPC===

In the ''toaster.yang'' file, we will define 2 RPC methods, make-toast and cancel-toast:

<pre>
    //This defines a Remote Procedure Call (rpc). RPC provide the ability to initiate an action
    //on the data model. In this case the initating action takes two optional inputs (because default value is defined)
    //QUESTION: Am I correct that the inputs are optional because they have defaults defined? The REST call doesn't seem to account for this.
    rpc make-toast {
      description
        "Make some toast. The toastDone notification will be sent when the toast is finished.
         An 'in-use' error will be returned if toast is already being made. A 'resource-denied' error will 
         be returned if the toaster service is disabled.";

      input {
        leaf toasterDoneness {
          type uint32 {
            range "1 .. 10";
          }
          default '5';
          description
            "This variable controls how well-done is the ensuing toast. It should be on a scale of 1 to 10.
             Toast made at 10 generally is considered unfit for human consumption; toast made at 1 is warmed lightly.";
        }

        leaf toasterToastType {
          type identityref {
            base toast:toast-type;
          }
          default 'wheat-bread';
          description
            "This variable informs the toaster of the type of material that is being toasted. The toaster uses this information, 
              combined with toasterDoneness, to compute for how long the material must be toasted to achieve the required doneness.";
        }
      }
    }  // rpc make-toast

    // action to cancel making toast - takes no input parameters
    rpc cancel-toast {
      description
        "Stop making toast, if any is being made.
           A 'resource-denied' error will be returned 
           if the toaster service is disabled.";
    }  // rpc cancel-toast
</pre>

Running 'mvn clean install', we see the following additional classes generated:

*'''ToasterService''' - an interface that extends '''RpcService''' and defines the RPC methods corresponding to the yang data model.
*'''MakeToastInput''' - an interface defining a DTO providing the input parameters for the make-toast call. 
*'''MakeToastInputBuilder''' - a concrete class for creating MakeToastInput instances.

''Note: It is important that you run the mvn clean stage everytime you modify the yang files. There are some files that are not generated if they already exist, which can lead to incorrect generated files. When you change .yang file, you should always run mvn clean, which will remove all of the generated yang files, via the mvn-clean-plugin defined in the common.opendaylight pom.xml file.''

===Implement the RPC methods===

We've defined the data model interface for the RPC calls - now we must provide the implementation. We'll create a class called OpendaylightToaster which implements the ToasterService and ToasterData interfaces: 
<pre>
public class OpendaylightToaster implements ToasterData, ToasterService {
    private final ExecutorService executor;
    
    /** Note: This is thread safe because of the synchronized statements on the public methods. 
          However those public synchronized statements perform global locks. If you have multiple methods
          that need to be synchronized, but not on the same objects, it would be more performant to
          use an internal locking object and synchronize only where you need. */
    private Future<RpcResult<Void>> currentTask; 

    //constants used by the "getToaster()" call. QUESTION: Why are these values hard-coded? Shouldn't the values come in from REST? 
    private static final DisplayString toasterManufacturer = new DisplayString("Opendaylight");
    private static final DisplayString toasterModelNumber = new DisplayString("Model 1 - Binding Aware");

    public OpendaylightToaster() {
        executor = Executors.newFixedThreadPool(1);
    }

    /** Provides the implementation for the cancel toast call */
    @Override
    public synchronized Future<RpcResult<Void>> cancelToast() {
        if (currentTask != null) {
            currentTask.cancel(true);
            currentTask = null;
        }
        return null; 
        //QUESTION: cancel toast call always throws an example because the caller 
        //of this method expects non-null return. Is returning null suppose to be valid?
    }

     /** Provides the implementation for the make toast call */
    @Override
    public synchronized Future<RpcResult<Void>> makeToast(MakeToastInput input) {
        log.debug("makeToast - Received input for toast");
 
        if (currentTask != null) {
            return inProgressError();
        }
        //Notice that we are offloading the actual call to another thread, allowing this thread to return immediately.
        //The MD-SAL design encourages asynchronus programming. If the caller needs to block until the call is 
        //complete then they can leverage the blocking methods on the Future.
        currentTask = executor.submit(new MakeToastTask(input));
        return currentTask;
    }

    private Future<RpcResult<Void>> inProgressError() {
        RpcResult<Void> result = Rpcs.<Void> getRpcResult(false, null, Collections.<RpcError> emptySet());
        return Futures.immediateFuture(result);
    }

    @Override
    public synchronized Toaster getToaster() {
        ToasterBuilder tb = new ToasterBuilder();
        tb.setToasterManufacturer(toasterManufacturer) 
           .setToasterModelNumber(toasterModelNumber) 
           .setToasterStatus(currentTask == null ? ToasterStatus.Up : ToasterStatus.Down);

        return tb.build();
    }

    //This inner class defines a runnable which gets submitted to the executor. In general
    // this logic should probably be split out into a seperate java class to enable easier testing.
    private class MakeToastTask implements Callable<RpcResult<Void>> {
        final MakeToastInput toastRequest;

        public MakeToastTask(MakeToastInput toast) {
            toastRequest = toast;
        }

        @Override
        public RpcResult<Void> call() throws InterruptedException {
            Thread.sleep(1000 * toastRequest.getToasterDoneness());

            log.debug("Toast Done");
           
            currentTask = null;
            return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
        }
    }
}
</pre>

The ''makeToast'' method simply sleeps for the number of seconds specified by 'toasterDoneness' and returns.

QUESTION: Do we have to have these two interfaces on the same class? Or can we separate the data from the service? I.E. Does it need to implement ToasterData?<br>
QUESTION: The Toaster instance returned from getToaster() is essentially a hard-coded instance. The code in the actual toaster sample in the controller project also updates the Toaster instance's status and stores it in the DataBroker service.  However this Toaster instance isn't returned from REST GET and nor is the OpenDaylightToaster aware of the Toaster created via REST. There's seems to be a disconnect between the OpenDaylightToaster and RestConf CRUD.

===Wiring the ToasterService implementation===

We've implemented the ToasterService - now we have to get our OpendaylightToaster instantiated and wired up with the MD-SAL. There's a couple ways to do this - we're going to use the MD-SAL's config subsystem which provides the most flexibility and provides the full benefits of the MD-SAL (for example access through JMX or NETCONF to the available services and run-time related data). We first need to describe our OpendaylightToaster service and what dependent services it needs for the MD-SAL to process. This is defined in... you guessed it, yang.

====Define the yang toaster provider service interface====
We define a ''toaster-provider.yang'' file as follows:
<pre>
module toaster-provider {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider";
    prefix "toaster-provider";

    import config { prefix config; revision-date 2013-04-05; }

    description
        "This module contains the base YANG definitions for toaster-provider services.";

    revision "2014-01-31" 
        description
            "Initial revision.";
    }

    // This is the definition or interface of the provider service
    identity toaster-provider {
        base "config:service-type"; // 

        // This is binding to the ToasterData class generated by the toaster.yang model. 
        // This is saying that "I am the provider for the module toaster".
        config:java-class "org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.ToasterData";
    }
}
</pre>

The '''toaster-provider identity''' is a ''service-type'' which means it's basically acting as an interface for the toaster module. You can find the referenced config module in "config.yang" file in the controller project.

====Define the yang toaster provider service implementation====
Next we need to define the/an implementation of the toaster-provider service yang interface in the ''toaster-provider-impl.yang'' file:
<pre>
module toaster-provider-impl {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl";
    prefix "toaster-provider-impl";

    import config { prefix config; revision-date 2013-04-05; }
    import toaster-provider { prefix toaster-provider; revision-date 2014-01-31; }
    import opendaylight-md-sal-binding { prefix mdsal; revision-date 2013-10-28; }

    description
        "This module contains the base YANG definitions for toaster-provider impl implementation.";

    revision "2014-01-31" {
        description
            "Initial revision.";
    }

    // This is the definition of a service implementation
    identity toaster-provider-impl {
            base config:module-type;
            config:provided-service toaster-provider:toaster-provider;
            config:java-name-prefix ToasterProvider;
    }

    //augments the configuration,  
    augment "/config:modules/config:module/config:configuration" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";

            //Wires dependent services into this class - in this case the RPC registry service
            container rpc-registry {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-rpc-registry;
                    }
                }
            }           
        }
    }
}
</pre>

The '''toaster-provider-impl identity''' is a ''module-type'' which is effectively providing an implementation of the toaster-provider service interface located at the ''/modules/module'' level in the MD-SAL's configuration data tree. The augmentation of ''modules/module/configuration'' adds configuration information for the toaster-provider-impl data node. '''rpc-registry''' defines a dependency of the toaster-provider-impl module on the MD-SAL's RPC registry service which we'll need to register our toaster provider service.   (TODO - need more info here?)

====Generate the yang toaster provider source====

To generate the java source files that facilitate the service wiring, we need to add another code generator, '''JmxGenerator''', to the yang-maven-plugin configuration in the pom.xml in addition to the '''CodeGeneratorImpl''':
<code>
    <plugin>
       <groupId>org.opendaylight.yangtools</groupId>
       <artifactId>yang-maven-plugin</artifactId>
       <executions>
          <execution>
             <id>config</id>
             <goals><goal>generate-sources</goal></goals>
             <configuration>
                <codeGenerators>
                   '''<generator>
                      '''<codeGeneratorClass>                                 
                          '''org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
                      '''</codeGeneratorClass>
                      '''<outputBaseDir>${jmxGeneratorPath}</outputBaseDir>
                      '''<additionalConfiguration>
                          '''<namespaceToPackage1>                                                   
                             '''urn:opendaylight:params:xml:ns:yang:controller==org.opendaylight.controller.config.yang
                          '''</namespaceToPackage1>
                      '''</additionalConfiguration>
                   '''</generator>
                   <generator>
                       <!-- existing CodeGeneratorImpl shoudl remain here -->
                   </generator>
               </codeGenerators>
               <inspectDependencies>true</inspectDependencies>
            </configuration>
          </execution>
       </executions>
       <dependencies>
          '''<dependency>
             '''<groupId>org.opendaylight.controller</groupId>
             '''<artifactId>yang-jmx-generator-plugin</artifactId>
             '''<version>${config.version}</version>
          '''</dependency>
          <dependency>
             <groupId>org.opendaylight.yangtools</groupId>
             <artifactId>maven-sal-api-gen-plugin</artifactId>
             <version>${yangtools.version}</version>
          </dependency>
       </dependencies>
    </plugin>
</code>  

Run a 'mvn clean install' to generate the new sources files. The 2 yang files generate several classes, of note are the 2 that are generated under src/main/java:

*'''ToasterProviderModule''' -  concrete class whose ''createInstance()'' method provides the OpendaylightToaster instance.
*'''ToasterProviderModuleFactory''' - concrete class instantiated internally by MD_SAL that creates '''ToasterProviderModule''' instances.  

'''Note''': these 2 classes are intended to be checked into Git as they will contain manually written code.

====Implement the ToasterProviderModule====
The '''ToasterProviderModule''' class is mostly complete. The ''ToasterProviderModule.createInstance()'' method needs to be implemented to instantiate and wire the '''OpendaylightToaster''':

<pre>
    @Override
    public java.lang.AutoCloseable createInstance() {
        final OpendaylightToaster opendaylightToaster = new OpendaylightToaster();

        // Register our OpendaylightToaster instance as the RPC implementation for the ToasterService.
        final BindingAwareBroker.RpcRegistration<ToasterService> rpcRegistration = getRpcRegistryDependency()
                .addRpcImplementation(ToasterService.class, opendaylightToaster);

        // Wrap toaster as AutoCloseable and close registrations to md-sal at
        // close()
        final class AutoCloseableToaster implements AutoCloseable, ToasterData {

            @Override
            public void close() throws Exception {
                rpcRegistration.close();
            }

            @Override
            public Toaster getToaster() {
                return opendaylightToaster.getToaster();
            }
        }

        return new AutoCloseableToaster();
    }
</pre>

In the above code, the '''RpcProviderRegistry''' dependency has already been injected by the MD-SAL and is available via the ''getRpcRegistryDependency()'' method defined in the generated base class. The return type of ''createInstance()'' is '''AutoCloseable''' although the intent is to return a '''ToasterData''' instance so we must wrap the '''OpendaylightToaster ''' in an '''AutoCloseable''' instance.

We don't need to modify or implement anything in '''ToasterProviderModuleFactory''' for this example.
 
--------
'''QUESTION: An AutoCloseable return type is not well defined and it is unclear what actual interface type this method is suppose to return. Am I suppose to return a ToasterData? A ToasterService?''' <br>
'''QUESTION: Can this code be reduced to just instantiating the OpendaylightToaster and returning it?
*Have return type be ToasterData. The MD-SAL can wrap in AutoCloseable on return, if needed, if the returned instance doesn't implement AutoCloseable.
*Can the MD-SAL be smart enough to auto register the returned instance as an RPC service? The OpendaylightToaster implements RpcService via the ToasterService interface - the MD-SAL should have the info necessary to register it via addRpcImplementation.'''
--------

====Define the initial XML configuration====

We have now defined the toaster data model (toaster.yang), an "interface" for the toaster provider service (toaster-provider.yang) and an implementation (toaster-provider-impl.yang). As we've seen, the toaster data model is usable at this point and can be accessed via REST. However, if the toaster provider bundle is deployed at this point, the '''make-toast''' RPC service wouldn't be available. Everything we have done so far is to define the service interface and a "possible" implementation. The last step is to actually tell MD-SAL to "deploy" the implementation, i.e. create an instance of the service ('''OpenDaylightToaster'''), resolve dependencies and advertise it for consumption/use. 

To do this, we need to create an xml file that defines the initial configuration for the toaster provider service deployment. The xml is actually a netconf edit-config with the toaster provider ''yin'' (yang-to-xml) as its payload ('''QUESTION: is this correct?''').  First it tells MD-SAL about the toaster provider service, which implementation to use, and then finally how to configure the implementation. 
<pre>
<snapshot>
    <configuration>
        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <!-- Specify the configuration for the toaster-provider-impl module as defined in the 
                        toaster-provider-impl.yang file -->
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl">
                        prefix:toaster-provider-impl
                    </type>
                    <name>toaster-provider-impl</name>

                    <!-- Specify the rpc-registry dependency as defined in the augments clause -->
                    <rpc-registry>
                        <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-rpc-registry</type>
                        <name>binding-rpc-broker</name>   <!-- this unique ID appears to come from distributions/opendaylight/src/main/resources/configuration/initial/01-md-sal.xml configuration file, which is wiring up and exposing the core MD-SAL services. -->
                    </rpc-registry>
                </module>
            </modules>

            <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <!-- Specify the toaster-provider  service registration as defined in the toaster-provider.yang -->
                <service>
                    <!-- Service type is the toaster-provider interface -->
                    <type xmlns:toaster="urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider">toaster:toaster-provider</type>
                    <instance>
                        <name>toaster-provider</name>
                        <!-- Specify the toaster-provider-impl module as the implementation of the service - an xpath expression that references the  
                                toaster-provider-imp module defined above-->
                        <provider>/modules/module[type='toaster-provider-impl'][name='toaster-provider-impl']</provider>
                    </instance>
                </service>
            </services>
        </data>
    </configuration>

    <!-- Specify the capabilities for netconf -->
    <required-capabilities>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding?module=opendaylight-md-sal-binding&amp;revision=2013-10-28</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:config:toaster-consumer:impl?module=toaster-consumer-impl&amp;revision=2014-01-31</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl?module=toaster-provider-impl&amp;revision=2014-01-31</capability>
    </required-capabilities>
</snapshot>
</pre>

The '''modules''' section specifies the toaster-provider-impl module and its dependency configuration as defined in the ''toaster-provider-impl.yang'' file. The rpc-registry implementation is provided by MD-SAL and is needed for the '''OpenDaylightToaster'''.

The '''services''' section specifies the toaster-provider service interface and the toaster-provider-impl module as the implementation to instantiate and register.

This XML file must be put into the runtime ''configuration/initial'' directory (i.e. controller/opendaylight/distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight/configuration/initial ).

On startup, the XML files in the ''configuration/initial'' directory are loaded by the '''ConfigPersisterActivator'''. A '''ConfigPusher''' instance is instantiated to push the configs via the NetConf subsystem to the '''ConfigRegistryImpl'''.  When processing the toaster-provider-impl module in the toaster config file, the '''ToasterProviderModuleFactory''' class is located and instantiated and the ''createModule'' method is called to create a '''ToasterProviderModule''' instance. The ''ToasterProviderModule.getInstance'' method is then called to create the '''OpenDaylightToaster'''.

For a detailed walk-through on how to make a 'config-subsystem aware' project please visit https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Examples:Sample_Project

'''QUESTION: There doesn't seem to be any output to tell you when a netconf file fails to get parsed or processed due to bad text. Where would this be printed?'''

===Invoke make-toast via RestConf===

It's finally time to make some delicious wheat toast! To invoke the make toast via the Restconf you will perform an HTTP POST to an operations URL.
<pre>
HTTP Method => POST
URL => http://localhost:8080/restconf/operations/toaster:make-toast 
Header =>   Content-Type: application/yang.data+json  
Body =>  
{
  "input" :
  {
     "toaster:toasterDoneness" : "10",
     "toaster:toasterToastType":"wheat-bread" 
  }
}
</pre>
''Note: Even though the toast type and doneness is defaulted in the yang model, you still have to provide their values here.'' 
<br>'''Question: Is that correct? Seems like if the values are defaulted in the yang data model, we shouldn't be forced to specify them. Even if we are, we need to clarify the error message.'''
<br>'''Question: Haven't tested the mandatory flag for leaf data - is it honored?'''

===cancel-toast via RestConf===
If you don't like burnt toast, you may want to cancel the make-toast operation part of the way through! You do this by invoking a restconf REST call in a very similar way as you invoke the make-toast.
<pre>
URL => http://localhost:8080/restconf/operations/toaster:cancel-toast
HTTP Method => POST
</pre>

Note: There is a bug in the way the RestconfImpl class processes / routes the REST requests. If you define the Content-Type header, then the rest call is routed to a method which expects a non-empty body. In this case though we don't have any input, so our body should be empty. Thus an exception is thrown. In order to make the cancel-toast call work successfully, you need to invoke the above call, with NO content-type define. By doing that you route the request to a different method, which expects an empty body. '''QUESTION: Definitely seems like there is an bug here. We should all content types with empty bodies for these calls.'''<br>
Note 2: When you successfully invoke this call with no headers, you will still get an error. This is due to a null future being returned in our implementation above. You can though put a breakpoint in the cancel toast call at this point and have that breakpoint activated. '''Question: See above in the implementation code for the question. Ultimately should we be returning null futures? Doesn't seem like the downstream code can handle it.'''

= Part 3: Getting Toaster Status (Operational Data) =

During part 3 we will modify the OpendaylightToaster to update the "toasterStatus" field, changing it from "up" to "down" and vice-versa as toast is started/finished. The first step is to modify the toaster-provider-impl.yang to tie the data-broker service into our provider.
===Add the Data Broker Service ===

The first step is to head back to the toaster-provider-impl.yang file, and modify it to tie in the data-broker service. Open up the toaster-provider-impl.yang file, and add the bolded text to the 'augment "/config:modules/config:module/config:configuration" section.
<code>
 ...
    //augments the configuration,  
    augment "/config:modules/config:module/config:configuration" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";
 <br>
            //Wires dependent services into this class - in this case the RPC registry service
            container rpc-registry {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-rpc-registry;
                    }
                }
            }
            
            '''//wires in the data-broker service 
            '''container data-broker {
            '''    uses config:service-ref {
            '''        refine type {
            '''            mandatory false;
            '''            config:required-identity mdsal:binding-data-broker;
            '''        }
            '''    }
            '''}
            
        }
    }
 ...
</code>
Rebuild the source code (mvn clean install) and you should now see that your org.opendaylight.controller.config.yang.config.toaster_provider.impl.AbstractToasterProviderModule has two new methods: getDataBroker()  and getDataBrokerDependency(). Additionally, a "DataBroker" and  DataBrokerBuilder files were generated.<br><Br>'''QUESTION: What are these classes used for?'''
=== Modify the OpendaylightToaster ===
Now we need to modify our OpendaylightToaster to pass the data broker service in. Add the getter methods, which are in bold to the OpendaylightToaster.java
<code>
 ...
   private DataBrokerService dataBrokerService;<br>
   public void setDataProvider(DataBrokerService salDataProvider) {
        this.dataBrokerService = salDataProvider;
    }
 ...
</code>
Now that we have passed the DataBrokerService into our toaster, we need to use our service and update the status when we are making toast. Since we want to update the status from many locations (making toast, canceling toast, and initializing the status) we will create an update status method.
<code>
        ...
        private static final InstanceIdentifier<Toaster>  toasterIID = InstanceIdentifier.builder(Toaster.class).build();<br>
        private void updateStatus() {
        if (dataBrokerService != null) {
            //We start a transaction, such that our remove and put calls are atomic. 
            final DataModificationTransaction t = dataBrokerService.beginTransaction();
            //NOTE: We are interacting with the operational data store, as opposed to the config data store.
            //therefore to access this data you would go to the operational rest endpoint, instead of the config endpoint
            t.removeOperationalData(toasterIID);
            t.putOperationalData(toasterIID, getToaster());   //QUESTION: Why do we pass config information into the operational data? Can we safely assume there is only 1 instance? I think so...<br>
            try {
                t.commit().get();
            } catch (InterruptedException | ExecutionException e) {
                log.warn("Failed to update toaster status, operational otherwise", e);
            }
        } else {
            log.trace("No data provider configured, not updating status");
        }
    }
    ...
</code>
In our updateStatus method we leverage the existing getToaster() method call which determines the status of the toaster by checking the "currentTask" inner variable. We then persist that information in our data broker by creating a transaction which removes the existing values, and then saves the new data into the operational data store. Now modify the following methods, adding a call to updateStatus().
<code>
     ...
     @Override
    public synchronized Future<RpcResult<Void>> cancelToast() {
        if (currentTask != null) {
            currentTask.cancel( true );
            currentTask = null;
            '''updateStatus();
        }
        return null;
    }
    ...
    @Override
    public synchronized Future<RpcResult<Void>> makeToast(MakeToastInput input) {
        log.debug("makeToast - Received input for toast");
        logToastInput(input);
        if (currentTask != null) {
            return inProgressError();
        }
        currentTask = executor.submit(new MakeToastTask(input));
        '''updateStatus();
        return currentTask;
    }
    ...
    private class MakeToastTask implements Callable<RpcResult<Void>> {<br>
        final MakeToastInput toastRequest;<br>
        public MakeToastTask(MakeToastInput toast) {
            toastRequest = toast;
        }<br>
        @Override
        public RpcResult<Void> call() throws InterruptedException {
            Thread.sleep(1000 * toastRequest.getToasterDoneness()); <br>
            log.debug("Toast Done");
            logToastInput(toastRequest);
            toastsMade.incrementAndGet();
            currentTask = null;
            '''updateStatus();
            return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
        }
    }
    ...
</code>
The last step in modifying the code is to pass the data broker service into the toaster inside of the ToasterProviderModule class. Do this by modifying the ToasterProviderModule.java file:
<code>
      ...
      public java.lang.AutoCloseable createInstance() {
           ...
           '''opendaylightToaster.setDataProvider(getDataBrokerDependency());
           ...
      }
      ...
</code>
Finally, you have wired up the code to pass along the data broker service but we still need to pass the data broker in during the initial configuration. To do this you must modify the 03-toaster-sample.xml file, adding the following XML into module defining the  toaster-provider-impl.
<code>
      ...
      <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl">
                        prefix:toaster-provider-impl
                    </type>
                     ...
                    '''<data-broker>
                    '''    <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-data-broker</type>
                    '''    <name>binding-data-broker</name>
                    '''</data-broker>
                    ...
      </module>
      ...
</code>
You have now successfully wired in the data broker service to our toaster, and update. The next step is to try it out!
====Getting the Operational Status ====
To get the operational status of the toaster you need to do a simple GET to the operational datastore.
<pre>
  HTTP Method: GET
  HTTP URL: http://localhost:8080/restconf/operational/toaster:toaster
</pre>
You should see the information store in the update status in the return. To see the toaster status change, perform a rest call to "make-toast" (see above) with a doneness of 10. Then within 10 seconds make the rest call to the operational datastore to see toaster status change to down. <Br>''Note: If 10 seconds is not enough time, consider modifying the java code to extend delay for each doneness level''.
<br>
''Note 2: You do NOT need to create a toaster in the "config" datastore in order to access this data in the operational data store. Right now they seem to be independent entities... QUESTION: Should they be? Or should we force them to be tied together?

= Part 4: Additional Attributes in the Implementation - Count my toast! =

For statistical purposes, we'd like to keep track of how many pieces of toast the toaster has made over time.  We need an attribute, '''toasts-made''', to track the count and a way to obtain the count. Whenever we '''make-toast''', we want to increment '''toasts-made'''.<br>

==Define the toasts-made attribute==
We'll define '''toasts-made''' as statistical state data on the toaster provider service implementation since that is where '''make-toast''' happens. This is achieved by augmenting the toaster-provider-impl module's '''config:state''' in ''toaster-provider-impl.yang'':
<pre>
augment "/config:modules/config:module/config:state" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";

            leaf toasts-made {
                type uint32;
            }

        }
    }
</pre>

The MD-SAL makes state data accessible via JMX.<br>

'''QUESTION: could toasts-made be defined as part of the toaster container itself?'''<br>
'''QUESTION: is state data also available via REST? via NetConf?<br>

Run 'mvn clean install' to generate the source. 3 additional classes are generated under ''src/main/yang-gen-config'':
*'''ToasterProviderRuntimeMXBean''' - interface that defines the ''getToastsMade()'' method to provide access to the '''toasts-made''' attribute.
*'''ToasterProviderRuntimeRegistration''' - concrete class that wraps a '''ToasterProviderRuntimeMXBean''' registration.
*'''ToasterProviderRuntimeRegistrator''' - concrete class that registers a '''ToasterProviderRuntimeMXBean''' implementation with the MD-SAL.

==Implement the toasts-made attribute==

Now that we've defined the data model for the '''toasts-made''' attribute we need to provide an implementation to update it. Since the '''OpenDaylightToaster''' makes toast, we'll implement it there.<br>

The '''ToasterProviderRuntimeMXBean''' provides the interface for '''toasts-made''' so we need to modify '''OpenDaylightToaster''' to implement the '''ToasterProviderRuntimeMXBean''' interface:

<code>
 public class OpendaylightToaster implements ToasterData, ToasterService, '''ToasterProviderRuntimeMXBean''', AutoCloseable {
    ...
    '''private final AtomicLong toastsMade = new AtomicLong(0);
    ...
    <br>
    '''@Override
    '''public Long getToastsMade() {
        '''return toastsMade.get();
    '''}
    <br>
    ...
    <br>
    private class MakeToastTask implements Callable<RpcResult<Void>> {
        ...
        @Override
        public RpcResult<Void> call() throws InterruptedException {
            Thread.sleep(1000 * toastRequest.getToasterDoneness());
            ...
            <br>
            '''toastsMade.incrementAndGet();'''
            <br>
            ...
            return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
        }
    }
 }
</code>

==Register the ToasterProviderRuntimeMXBean service==

We need to do a final step to register the '''OpendaylightToaster''' as the '''ToasterProviderRuntimeMXBean''' service. We do this in the '''ToasterProviderModule''' via the '''ToasterProviderRuntimeRegistrator''' returned by the base class's ''getRootRuntimeBeanRegistratorWrapper()'' method:

<pre>
    public java.lang.AutoCloseable createInstance() {
        final OpendaylightToaster opendaylightToaster = new OpendaylightToaster();
        ...
    
        // Register runtimeBean for toaster statistics via JMX
        final ToasterProviderRuntimeRegistration runtimeReg = getRootRuntimeBeanRegistratorWrapper().register(
                opendaylightToaster);

        ...
        final class AutoCloseableToaster implements AutoCloseable, ToasterData {
            @Override
            public void close() throws Exception {
                ...
                runtimeReg.close();
                ...
            }
            ...
        }
    }
</pre>

Note: we also have to close the '''ToasterProviderRuntimeRegistration''' when the '''OpendaylightToaster''' instance is closed.

== Accessing toasts-made via JMX==
The toasts-made attribute that we added is available via MBeans through the java management beans. You can programmatically access these through the mbean platform (see [https://wiki.opendaylight.org/view/Toaster_MD-SAL_Sample:Toaster_Tutorial#Getting_Provider_Runtime_data_exposed_to_config-subsystem] ) or via jConsole.
*''JConsole is a utility shipped with each JDK and is located in the bin directory of your java home folder.''
*First, start the controller using the -jmx flag.<pre>./run.sh -jmx</pre>This flag enables controller allowing jconsole to attach.<Br><br>Launch JConsole, double click on the jconsole application under <pre>$JAVA_HOME/bin/jconsole</pre>''Note: Path may change based on OS and installation''
*Connect to the running eclipse process either by selecting the application, or specifing the "hostname:1088" in the remote connect dialog. For more information on JMX check out this document: [https://wiki.opendaylight.org/images/8/89/Jconsole.pdf].
*Once connected, navigate to the "MBeans" tab.
:*Expand the "org.opendalight.controller->RuntimeBean->toaster-provider-impl->toster-provider-impl" nodes.
*Select "Attributes". You will now see the "ToastsMade" attribute displayed and this attribute will change when the make-toast RPC call is executed.
<Br>'''Question: It seems like we should be able to access this information via restconf as well. Is that true? When we question /restconf/config/toaster-provider-impl:toaster-provider-impl it should be displayed.... Is that true? Is it a different URL since it is an augmentation of modules/module?

= Part 5: Notifications - Tell me when my Toast is done! =

When a piece of toast is made we'd like for the '''OpenDaylightToaster''' to provide a notification when it's done, or is cancelled, or encountered an error. This can be consumed by an implementation of the '''ToasterListener''' interface or by an external netconf client.

==Define the toastDone notification==

We'll define a notification called '''toastDone''' in the toaster module:
<pre>
   notification toastDone {
      description
        "Indicates that the toast in progress has completed.";
      leaf toastStatus {
        type enumeration {
          enum "done" {
            value 0;
            description "The toast is done.";
          }
          enum "cancelled" {
            value 1;
            description
              "The toast was cancelled.";
          }
          enum "error" {
            value 2;
            description
              "The toaster service was disabled or the toaster is broken.";
          }
        }
        description
          "Indicates the final toast status";
      }
   }  // notification toastDone
</pre>

Run 'mvn clean install' to generate the source. 3 additional classes are generated under ''src/main/yang-gen-sal'':

*'''ToastDone''' - interface for the '''toastDone''' notification that defines a ''getToastStatus()'' method.
*'''ToastDoneBuilder''' - concrete class for building a '''ToastDone''' instance.
*'''ToasterListener''' - interface for consumers of the '''toastDone''' notification to implement that defines an ''onToastDone(ToastDone)'' method.

==Wire the OpenDaylightToaster for notification==

The '''OpenDaylightToaster''' needs access to the MD-SAL's '''NotificationProviderService''' in order to send notifications. We need to specify the '''NotificationProviderService''' as a dependency in the toaster-provider-impl module by adding an entry to the '''config:configuration''' augmentation: 
<code>
     augment "/config:modules/config:module/config:configuration" {
        case toaster-consumer-impl {
            when "/config:modules/config:module/config:type = 'toaster-consumer-impl'";
            ...
            <br>
            '''container notification-service {
                '''uses config:service-ref {
                    '''refine type {
                        '''mandatory true;
                        '''config:required-identity mdsal:binding-notification-service;
                    '''}
                '''}
            '''}
        }
    }
</code>

Run 'mvn clean install' to generate the source.

The generated '''AbstractToasterProviderModule''' class should now have a ''getNotificationServiceDependency()'' method. We can access that method in our '''ToasterProviderModule''' implementation.
<br><br>
First we add a class member for '''NotificationProviderService''' to '''OpenDaylightToaster''' with a setter:
<pre>
private NotificationProviderService notificationProvider;

public void setNotificationProvider(NotificationProviderService salService) {
        this.notificationProvider = salService;
    }
</pre>

Next, in ''ToasterProviderModule.createInstance()'', inject the '''NotificationProviderService''' into the                 '''OpenDaylightToaster''':
<pre>
opendaylightToaster.setNotificationProvider(getNotificationServiceDependency());
</pre>

Finally we need to add the dependency for the 'notification-service' to the toaster-provider-impl module in the initial configuration XML file as we did earlier with the 'rpc-registry':
<code>
 <snapshot>
    <configuration>
        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <!-- Specify the configuration for the toaster-provider-impl module as defined in the 
                        toaster-provider-impl.yang file -->
                <module>
                    ...
                    '''<notification-service>
                        '''<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">
                            '''binding:binding-notification-service
                        '''</type>
                        '''<name>binding-notification-broker</name>
                    '''</notification-service>
                </module>
            </modules>
            ...
        </data>
    </configuration>
    ...
 </snapshot>
</code>

==Send the notification==

The '''OpendaylightToaster''' is now ready to send notifications.
<code>
 public class OpendaylightToaster implements ToasterData, ToasterService, ToasterProviderRuntimeMXBean, AutoCloseable {
    ...
    <br>
    private void cancelToastImpl() {
        currentTask.cancel(true);
        '''ToastDoneBuilder toastDone = new ToastDoneBuilder();
        '''toastDone.setToastStatus(ToastStatus.Cancelled);
        '''notificationProvider.publish(toastDone.build());
    }
    ...
    <br>
    private class MakeToastTask implements Callable<RpcResult<Void>> {
        ...
        @Override
        public RpcResult<Void> call() throws InterruptedException {
            Thread.sleep(1000 * toastRequest.getToasterDoneness());
            ...
            '''ToastDoneBuilder notifyBuilder = new ToastDoneBuilder();
            '''notifyBuilder.setToastStatus(ToastStatus.Done);
            '''notificationProvider.publish(notifyBuilder.build());
            ...
            return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
        }
    }
 }
</code>

= Part 6: ODL Controller Extension - Using MD-Sal  =

Under construction - please come back soon!
