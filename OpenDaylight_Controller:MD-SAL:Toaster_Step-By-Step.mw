__TOC__

=Overview=
The following documentation will take you through creating a "toaster" plugin from scratch. We will start with simple definitions of a toaster that enable CRUD (create/read/update/delete) of configuration data only, and advance to a sophisticated model that has both remote procedure calls, notifications and a specialized ODL controller which provides additional business logic.

<br><br>'''If you are looking for an overview of the prebuilt Toaster sample, along with discussions of how the classes interact with eachother, check out the [https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Toaster_Tutorial Toaster Tutorial]'''

<br><br>'''NOTE: The follow documentation is a work in progress and may have embedded questions and answers. Look for QUESTION to find existing questions.'''

====Toaster Parts====
There are four parts that make up this toaster step-by-step example. During this example we illustrate how the yang model is providing abstraction for us, and how MD-SAL provides the plumbing (wiring) to hook everything up.

*'''Part 1''' of this example defines the North Bound interface for the toaster. This is the highest level of abstraction, which normalizes the view of a toaster to any north bound clients (i.e. applications). The yang file we define here contains all of the RPC and attributes required by all toaster implementations. In this first part we only define the yang file which enables CRUD on the generic toaster interface, but provides no remote calls.
*'''Part 2''' of this example uses yang to take the abstract one step further. It enhances the original yang file by adding in a Remote Procedure Call (RPC) call (thus exposing that RPC call to all North Bound clients). Then using a new yang file, defines an "interface" for all implementations. Finally in a third yang file we define one possible implementation and will be enhanced in the remaining parts to add additional functionality that the north bound implementation will not be aware of.
*'''Part 3''' of this example will add in the concept of operational data to the toaster. Specifically, this stage will enable an operational call to toaster to determine if the toaster is "up" or "down". This example will illustrait how our intelligence can interact with the data store during RPCs.
*'''Part 4''' of this example will provide additional attributes not present in the north bound interface, but available by the implementation. Specifically a count of the number of pieces of toaster that were successfully created by this toaster since it was defined. '''QUESTION: Is this a correct statement?'''
*'''Part 5''' will expand on our example adding in an example notification system. This notification system allows the implementation to send notifications out to registered listeners telling them when some event occurs (in our case when a piece of toast is done).
*'''Part 6''' will add the final piece to this example, where we provide a demonstration of how other business intelligence in the controller can access the data models and invoke RPC calls and gain access to configuration data for the purpose of providing additional business logic in the controller.

= Part 1: Simple Toaster CRUD Service - What Toaster do you have? (Config Data)=

Part 1 of the toaster service will define a simple toaster service which will enable CRUD operations via RESTCONF and MD-SAL. To achieve this it is quite simple. In fact you only need to define the yang model, and MD-SAL takes care of the rest!

===Create a New Project===

*Ensure you have downloaded the controller code. See [[OpenDaylight_Controller:Pulling,_Hacking,_and_Pushing_the_Code_from_the_CLI]].
*You can create a project anywhere, but to keep things co-located I would recommend creating a new project under controller/opendaylight/md-sal/samples. 
:*Create a new folder here. Lets call it ODLToaster.

<pre>
cd controller/opendaylight/md-sal/samples
mkdir odl-toaster
cd odl-toaster
vi pom.xml
</pre>
:*Under the new folder, define a pom.xml file which has the following contents:
<pre>
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <artifactId>sal-samples</artifactId>
    <groupId>org.opendaylight.controller.samples</groupId>
    <version>1.1-SNAPSHOT</version>
  </parent>
  <artifactId>odl-toaster</artifactId>
  <packaging>bundle</packaging>

  <build>
    <plugins>
      <plugin>
        <groupId>org.opendaylight.yangtools</groupId>
        <artifactId>yang-maven-plugin</artifactId>
        <executions>
          <execution>
            <goals>
              <goal>generate-sources</goal>
            </goals>
            <configuration>
              <yangFilesRootDir>src/main/yang</yangFilesRootDir>
              <codeGenerators>
                <generator>
                  <codeGeneratorClass>org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl</codeGeneratorClass>
                  <outputBaseDir>${salGeneratorPath}</outputBaseDir>
                </generator>
              </codeGenerators>
              <inspectDependencies>true</inspectDependencies>
            </configuration>
          </execution>
        </executions>
        <dependencies>
          <dependency>
            <groupId>org.opendaylight.yangtools</groupId>
            <artifactId>maven-sal-api-gen-plugin</artifactId>
            <version>${yangtools.version}</version>
            <type>jar</type>
          </dependency>
        </dependencies>
      </plugin>
    </plugins>
  </build>
  <dependencies>
    <dependency>
      <groupId>org.opendaylight.yangtools</groupId>
      <artifactId>yang-binding</artifactId>
    </dependency>
    <dependency>
      <groupId>org.opendaylight.yangtools</groupId>
      <artifactId>yang-common</artifactId>
    </dependency>
  </dependencies> 
 </project>
</pre>

The yang-maven-plugin is used to generate java source from yang definition files. Much of the plugin's configuration is boilerplate. Tags of specific interest:

* '''yangFilesRootDir''' - specifies the directory under the project to locate yang files to process. This defaults to src/main/yang.
* '''codeGeneratorClass''' - specifies the code generator to use.  CodeGeneratorImpl is used to generate classes that represent the yang data model constructs.
* '''outputBaseDir''' - specifies the output directory for the generated classes. In the controller project we specify the ${salGeneratorPath} property which is defined in the root pom as src/main/yang-gen-sal.  
  
Optionally at this point, you can import this project into Eclipse (you will need to import the maven project from the toaster directory directly since we did not add this project to any parent pom files).

===Define the Yang Datamodel ===
Now that we have set up the project we must define a yang model to represent our toaster. We do that by creating a toaster.yang file under the src/main/yang directory.
<pre>
mkdir -p src/main/yang
cd src/main/yang
vi toaster.yang
</pre>
*Under the src/main/yang directory create a toaster.yang file with the following contents:
<pre>
  //This file contains a YANG data definition. This data model defines
  //a toaster, which is based on the SNMP MIB Toaster example 
  module toaster {

    //The yang version - today only 1 version exists. If ommited defaults to 1.
    yang-version 1; 

    //a unique namespace for this toaster module, to uniquely identify it from other modules that may have the same name.
    namespace
      "http://netconfcentral.org/ns/toaster"; 

    //a shorter prefix that represents the namespace for references used below
    prefix toast;

    //Defines the organization which defined / owns this .yang file.
    organization "Netconf Central";

    //defines the primary contact of this yang file.
    contact
      "Andy Bierman <andy@netconfcentral.org>";

    //provides a description of this .yang file.
    description
      "YANG version of the TOASTER-MIB.";

    //defines the dates of revisions for this yang file
    revision "2009-11-20" {
      description
        "Toaster module in progress.";
    }

    //declares a base identity, in this case a base type for different types of toast.
    identity toast-type {
      description
        "Base for all bread types supported by the toaster. New bread types not listed here nay be added in the future.";
    }

    //the below identity section is used to define globally unique identities
    //Note - removed a number of different types of bread to shorten the text length.
    identity white-bread {
      base toast:toast-type;       //logically extending the declared toast-type above.
      description "White bread.";  //free text description of this type.
    }

    identity wheat-bread {
      base toast-type;
      description "Wheat bread.";
    }

    //defines a new "Type" string type which limits the length
    typedef DisplayString {
      type string {
        length "0 .. 255";
      }
      description
        "YANG version of the SMIv2 DisplayString TEXTUAL-CONVENTION.";
      reference
        "RFC 2579, section 2.";

    }

    // This definition is the top-level configuration "item" that defines a toaster. The "presence" flag connotes there
    // can only be one instance of a toaster which, if present, indicates the service is available.
    container toaster {
      presence
        "Indicates the toaster service is available";
      description
        "Top-level container for all toaster database objects.";

      //QUESTION: Should config = true here? Manufacturer and model number do not change
      //at run time - they are more configuration than state....
      leaf toasterManufacturer {
        type DisplayString;
        config false;
        mandatory true;
        description
          "The name of the toaster's manufacturer. For instance, Microsoft Toaster.";
      }

      leaf toasterModelNumber {
        type DisplayString;
        config false;
        mandatory true;
        description
          "The name of the toaster's model. For instance, Radiant Automatic.";
      }

      //notice how we restrict the allowed values in this attribute
      //Config = false indicates that this is state data - i.e. data that
      //can change which the system is running.
      leaf toasterStatus {
        type enumeration {
          enum "up" {
            value 1;
            description
              "The toaster knob position is up. No toast is being made now.";
          }
          enum "down" {
            value 2;
            description
              "The toaster knob position is down. Toast is being made now.";
          }
        }
        config false;
        mandatory true;
        description
          "This variable indicates the current state of  the toaster.";
      }
    }  // container toaster
  }  // module toaster

</pre>

==Build & Deploy ==
We are now ready to build the toaster data model bundle. To do this, run the following command from the odl-toaster directory.
<pre>mvn clean install</pre>
''Note: You really only need to run 'mvn install' here since we have nothing to clean, but running a clean will not harm anything and is a good practice to ensure your generated code is cleaned up correctly so new code can be generated.''<br>
After running 'mvn clean install', you will see java class files generated under ''src/main/yang-gen-sal''.  Classes of note:
* '''Toaster''' - an interface that represents the toaster container with methods to obtain the leaf node data.
* '''ToasterData''' - an interface that represents the top-level toaster module with one method ''getToaster()'' that returns the singleton toaster instance.
* '''WheatBread''', '''WhiteBread''', etc' - abstract classes that represent the various toast types.
* '''$YangModelBindingProvider''', '''$YangModuleInfoImpl''' - these are used internally by MD-SAL to wire the toaster module for use. More on this later.  

To deploy, first you will want to remove the pre-developed toaster example from the plugins directory (this is a one time step, unless you rebuild the distributions.opendaylight project).
<pre>
#note the below line removes 3 jars related to the toaster sample.
rm ../../../distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight/plugins/org.opendaylight.controller.samples.sample-toaster*
rm ../../../distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight/configuration/initial/03-toaster-sample.xml
</pre>
To deploy, copy the bundle jar under target to the distribution plugin directory and invoke run.sh.
<pre>
cp target/odl-toaster-1.1-SNAPSHOT.jar ../../../distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight/plugins
cd ../../../distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight
./run.sh
</pre>

==Using the Toaster with RestConf ==

=== Create the Toaster ===
'''Question: Are we really creating a toaster? Or are we posting a configuration of a toaster? If the we are just posting a configuration, then shouldn't there already be a default one? Or if no default, and we actually are creating one here then should we prevent the make-toast RPC call below if the toaster doesn't exist?'''
To create the toaster instance,  issue a REST POST (you will need a rest client such as [https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en%20Install%20Postman%20for%20Chrome Postman for Google Chrome]):
:<code>
 URL => http://localhost:8080/restconf/config 
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster:toaster" :
    {
      "toaster:toasterManufacturer" : "General Electric",
      "toaster:toasterModelNumber" : "123",
      "toaster:toasterStatus" : "up"
     }
 }
 </code>
:''Note: You will likely see an exception on the OSGi terminal, and the return error code will be a 204, "No data returned". This means it succeeded!'' '''QUESTION: What if any is the expected output? Seems like we should be returning the content that we posted or something. Either way we definitely need to address the exception. [https://bugs.opendaylight.org/show_bug.cgi?id=442 Bug 422] captures a similar error.'''

=== Get the Toaster ===

To get the current toaster instance via REST,  issue an HTTP GET:
:<code>
 URL => http://localhost:8080/restconf/config/toaster:toaster 
 </code>
This should return json defining the toaster, and should provide similar values to what you posted.
<br>
*If you add "Accept: application/yang.data+xml" in the request headers, XML will be returned instead of json.
'''Question - according to the [http://tools.ietf.org/html/draft-bierman-netconf-restconf-00#section-1.4.2.1 draft] XML should be the default, the default here seems to be json. Is this expected? '''
<br>
QUESTION: Why do we separate operational from config? See restconf specification has combined config and operational data under /restconf/data ?? http://tools.ietf.org/html/draft-ietf-netconf-restconf-00#section-4.3.1

=== Update the Toaster ===

To update the toaster instance,  issue a REST PUT:
:<code>
 URL => http://localhost:8080/restconf/config/toaster:toaster
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster": {
        "toasterStatus": "up",
        "toasterManufacturer": "Oster",
        "toasterModelNumber": "ABC"
    }
 }
 </code>
''Note: You can also use the above call to create the initial toaster as well.''

=== Delete the Toaster ===
Question: What does it actually mean to "delete" the toaster? Are we just deleting the config? IF so should we revert to default values? Or should we prevent make-toasts calls when the config is deleted?
To delete the current toaster via REST,  issue an HTTP DELETE:
<code>
 URL => http://localhost:8080/restconf/config/toaster:toaster 
 </code>

QUESTION: An exception prints out in the osgi terminal when you do a post or delete - do we understand the cause? What is the expected return for the post / delete? [https://bugs.opendaylight.org/show_bug.cgi?id=442 Bug 422] captures a similar error.'<br><br>
QUESTION: Should we even be allowed to delete this data? Seems the restconf ietf draft tell us that we can't....

== How Does MD-SAL Know about my Toaster? ==
So by just defining a yang data model file and deploying a bundle containing the generated classes, we were able to perform CRUD operations on the toaster configuration. We didn't write a single line of java code. You might be wondering how the MD-SAL managed to wire it together. If so, read on.

The magic is done via some generated files. Under ''target/classes/META-INF/yang/toaster.yang'' and ''META-INF/services/org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' files that are inserted into the toaster bundle by the yang-maven-plugin (available after running a mvn clean install ).
*The ''toaster.yang'' file is copied from the src/main/yang directory. 
*The ''org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' file contains the fully-qualfied name of the toaster's generated '''$YangModelBindingProvider''' class. The MD-SAL's '''ModuleInfoBundleTracker''' class in the config subsystem scrapes the ''META-INF/services/org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' resource from bundles on startup and reads the class name(s) defined in the file.  For each YangModelBindingProvider class specified, the MD-SAL creates an instance and calls ''getModuleInfo()'' to return the singleton '''$YangModuleInfoImpl''' instance. This class has methods to obtain static configuration information about the yang module, e.g. name, revision, imports etc, as well as a ''getModuleSourceStream()'' method that provides an input stream to the ''META-INF/yang/toaster.yang'' file. Once the MD-SAL knows about a yang module and its definitions, it can wire it up to RestConf and other parts of the system.
<br><br><br>

= Part 2: Enabling Remote Procedure Calls - Lets make some toast! (RPC)=

Part 2 of the toaster example will be adding some behavior to the toaster. Having a toaster is cool but we'd really like it to make some toast for us. To accomplish this, we will define an RPC (Remote Procedure Call) in the toaster yang data model and write an implementation. 

In this part we will start to show how the yang data models are providing the abstraction for us. We have the toaster.yang file which is defining the northbound API. We then define additional .yang files to abstract away the implementations. '''Question: Is this a correct interpretation?'''

===Define the yang RPC===

Edit the existing ''toaster.yang'' file, where we will define 2 RPC methods, make-toast and cancel-toast (add the bold lines under the module toaster heading):

<code>
    module toaster {
        ... 
    '''//This defines a Remote Procedure Call (rpc). RPC provide the ability to initiate an action
    '''//on the data model. In this case the initating action takes two optional inputs (because default value is defined)
    '''//QUESTION: Am I correct that the inputs are optional because they have defaults defined? The REST call doesn't seem to account for this.
    '''rpc make-toast {
    '''  description
    '''    "Make some toast. The toastDone notification will be sent when the toast is finished.
    '''     An 'in-use' error will be returned if toast is already being made. A 'resource-denied' error will 
    '''     be returned if the toaster service is disabled.";<br>
    '''  input {
    '''    leaf toasterDoneness {
     '''     type uint32 {
     '''       range "1 .. 10";
    '''      }
    '''      default '5';
    '''      description
     '''       "This variable controls how well-done is the ensuing toast. It should be on a scale of 1 to 10.
      '''       Toast made at 10 generally is considered unfit for human consumption; toast made at 1 is warmed lightly.";
      '''  }<br>
      '''  leaf toasterToastType {
      '''    type identityref {
      '''      base toast:toast-type;
      '''    }
    '''      default 'wheat-bread';
    '''      description
    '''        "This variable informs the toaster of the type of material that is being toasted. The toaster uses this information, 
    '''          combined with toasterDoneness, to compute for how long the material must be toasted to achieve the required doneness.";
     '''   }
   '''   }
    '''}  // rpc make-toast<br>
  '''  // action to cancel making toast - takes no input parameters
   ''' rpc cancel-toast {
   '''   description
   '''     "Stop making toast, if any is being made.
    '''       A 'resource-denied' error will be returned 
   '''        if the toaster service is disabled.";
    '''}  // rpc cancel-toast'''
    ...
  }
</code>

Running 'mvn clean install', we see the following additional classes generated:

*'''ToasterService''' - an interface that extends '''RpcService''' and defines the RPC methods corresponding to the yang data model.
*'''MakeToastInput''' - an interface defining a DTO providing the input parameters for the make-toast call. 
*'''MakeToastInputBuilder''' - a concrete class for creating MakeToastInput instances.

''Note: It is important that you run the mvn clean stage everytime you modify the yang files. There are some files that are not generated if they already exist, which can lead to incorrect generated files. When you change .yang file, you should always run mvn clean, which will remove all of the generated yang files, via the mvn-clean-plugin defined in the common.opendaylight pom.xml file.''

===Implement the RPC methods===

We've defined the data model interface for the RPC calls - now we must provide the implementation. The first thing we need to do is modify our pom.xml to import some necessary support projects for the SAL. Add the following dependency to the project pom.xml:
<pre>
       <dependency>
            <groupId>org.opendaylight.controller</groupId>
            <artifactId>sal-common-util</artifactId>
        </dependency>
</pre>

We are now going to create a new class, '''OpendaylightToaster''', under the src/main/java source folder which will contain all of the business logic of our toaster. This class will implement the auto-generated ToasterService and ToasterData interfaces.
<br>'''NOTE: Do NOT create the source file under /src/main/yang-gen-sal or src/main/yang-gen-config as these directories are deleted upon mvn clean, and you will lose your work!'''

Here is the contents of the class: 

<pre>
package org.opendaylight.toaster;

import java.util.Collections;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.opendaylight.controller.sal.common.util.Rpcs;
import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.DisplayString;
import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.MakeToastInput;
import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.Toaster;
import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.Toaster.ToasterStatus;
import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.ToasterBuilder;
import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.ToasterData;
import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.ToasterService;
import org.opendaylight.yangtools.yang.common.RpcError;
import org.opendaylight.yangtools.yang.common.RpcResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.common.util.concurrent.Futures;

public class OpendaylightToaster implements ToasterData, ToasterService {
    private final ExecutorService executor;

    private static final Logger log = LoggerFactory.getLogger(OpendaylightToaster.class);

    //As you will see we are using multiple threads here. Therefore we need to be careful
    //about concurrency. In this case we use the taskLock to provide synchronization
    //for the current task.
    private Future<RpcResult<Void>> currentTask;
    private Object taskLock = new Object();

    //constants used by the "getToaster()" call. QUESTION: Why are these values hard-coded? Shouldn't the values come in from REST? 
    private static final DisplayString toasterManufacturer = new DisplayString("Opendaylight");
    private static final DisplayString toasterModelNumber = new DisplayString("Model 1 - Binding Aware");

    public OpendaylightToaster() {
        //in true production we should consider passing around and using a common thread pool.
        executor = Executors.newFixedThreadPool(1);
    }

    /** Provides the implementation for the cancel toast call */
    @Override
    public Future<RpcResult<Void>> cancelToast() {
        synchronized( taskLock )
        {
            if (currentTask != null) {
                currentTask.cancel(true);
                currentTask = null;
            }
        }
        //Always return success from the cancel toast call.
        return Futures.immediateFuture( Rpcs.<Void>getRpcResult(true, Collections.<RpcError> emptySet()) ); 
    }

     /** Provides the implementation for the make toast call */
    @Override
    public Future<RpcResult<Void>> makeToast(MakeToastInput input) {
        log.debug("makeToast - Received input for toast");
        
        boolean inProgress = false;
        synchronized( taskLock )
        {
            if (currentTask != null) {
                inProgress = true;
            }
            else
            {
                //Notice that we are moving the actual call to another thread, allowing this thread to return immediately.
                //The MD-SAL design encourages asynchronus programming. If the caller needs to block until the call is 
                //complete then they can leverage the blocking methods on the Future interface.
                currentTask = executor.submit(new MakeToastTask(input));
            }
        }
        if( inProgress )
        {
            //return an error since we are already toasting some toast.
            RpcResult<Void> result = Rpcs.<Void> getRpcResult(false, null, Collections.<RpcError> emptySet());
            return Futures.immediateFuture(result);
        }
        return currentTask;
    }

    @Override
    public Toaster getToaster() {
        boolean isUp = true;
        synchronized( taskLock )
        {
            isUp = currentTask == null;
        }
        ToasterBuilder tb = new ToasterBuilder();
        //QUESTION: Why do we hardcode the manufactuer and model number?
        tb.setToasterManufacturer(toasterManufacturer) 
           .setToasterModelNumber(toasterModelNumber) 
           .setToasterStatus(isUp ? ToasterStatus.Up : ToasterStatus.Down);
        return tb.build();
    }

    //This inner class defines a runnable which gets submitted to the executor. In general
    // this logic should probably be split out into a separate java class to enable easier testing.
    private class MakeToastTask implements Callable<RpcResult<Void>> {
        final MakeToastInput toastRequest;

        public MakeToastTask(MakeToastInput toast) {
            toastRequest = toast;
        }

        @Override
        public RpcResult<Void> call() throws InterruptedException {
            //make toast just sleeps for 1 second per doneness level.
            Thread.sleep(1000 * toastRequest.getToasterDoneness());

            log.debug("Toast Done");
           
            synchronized( taskLock )
            {
                //mark the toaster is "available" for more toasting.
                currentTask = null;
            }
            return Rpcs.<Void>getRpcResult(true, null, Collections.<RpcError> emptySet());
        }
    }
}
</pre>

This class simply implements the methods provided by the interface. One of the inherent designs of MD-SAL is to be asynchronous by nature so therefore we define a callable which is executed inside of another thread. Refer to the inline comments for more information.<br><br>
----
QUESTION: Do we have to have these two interfaces on the same class? Or can we separate the data from the service? I.E. Does it need to implement ToasterData?<br>
QUESTION: The Toaster instance returned from getToaster() is essentially a hard-coded instance. The code in the actual toaster sample in the controller project also updates the Toaster instance's status and stores it in the DataBroker service.  However this Toaster instance isn't returned from REST GET and nor is the OpenDaylightToaster aware of the Toaster created via REST. There's seems to be a disconnect between the OpenDaylightToaster and RestConf CRUD.
----

===Wiring the ToasterService implementation===

We've implemented the ToasterService - now we have to get our OpendaylightToaster instantiated and wired up with the MD-SAL. There's a couple ways to do this - we're going to use the MD-SAL's config subsystem which provides the most flexibility and provides the full benefits of the MD-SAL (for example: access through JMX or NETCONF to the available services and run-time related data). We first need to describe our OpendaylightToaster service and what dependent services it needs for the MD-SAL to process. This is defined in... you guessed it, yang.

====Define the yang toaster provider service interface====
We define a ''toaster-provider.yang'' file as follows (create this file in src/main/yang):
<pre>
module toaster-provider {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider";
    prefix "toaster-provider";

    import config { prefix config; revision-date 2013-04-05; }

    description
        "This module contains the base YANG definitions for toaster-provider services.";

    revision "2014-01-31" {
        description
            "Initial revision.";
    }

    // This is the definition or interface of the provider service
    identity toaster-provider {
        base "config:service-type"; // 

        // This is binding to the ToasterData class generated by the toaster.yang model. 
        // This is saying that "I am the provider for the module toaster".
        config:java-class "org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.ToasterData";
    }
}
</pre>

The '''toaster-provider identity''' is a ''service-type'' which means it's basically acting as an interface for the toaster module. You can find the referenced config module in "config.yang" file in the controller project.

====Define the yang toaster provider service implementation====
Next we need to define the/an implementation of the toaster-provider service yang interface in the ''toaster-provider-impl.yang'' file:
<pre>
module toaster-provider-impl {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl";
    prefix "toaster-provider-impl";

    import config { prefix config; revision-date 2013-04-05; }
    import toaster-provider { prefix toaster-provider; revision-date 2014-01-31; }
    import opendaylight-md-sal-binding { prefix mdsal; revision-date 2013-10-28; }

    description
        "This module contains the base YANG definitions for toaster-provider impl implementation.";

    revision "2014-01-31" {
        description
            "Initial revision.";
    }

    // This is the definition of a service implementation
    identity toaster-provider-impl {
            base config:module-type;
            config:provided-service toaster-provider:toaster-provider;
            config:java-name-prefix ToasterProvider;
    }

    //augments the configuration,  
    augment "/config:modules/config:module/config:configuration" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";

            //Wires dependent services into this class - in this case the RPC registry service
            container rpc-registry {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-rpc-registry;
                    }
                }
            }           
        }
    }
}
</pre>

The '''toaster-provider-impl identity''' is a ''module-type'' which is effectively providing an implementation of the toaster-provider service interface located at the ''/modules/module'' level in the MD-SAL's configuration data tree. The augmentation of ''modules/module/configuration'' adds configuration information for the toaster-provider-impl data node. '''rpc-registry''' defines a dependency of the toaster-provider-impl module on the MD-SAL's RPC registry service which we'll need to register our toaster provider service. <br>
Question: We could use some more information here on how this modeling works. Can someone provide some more details?

====Generate the yang toaster provider source====

To generate the java source files that facilitate the service wiring, we need to add another code generator, '''JmxGenerator''', to the yang-maven-plugin configuration in the pom.xml in addition to the '''CodeGeneratorImpl''':
<code>
    <plugin>
       <groupId>org.opendaylight.yangtools</groupId>
       <artifactId>yang-maven-plugin</artifactId>
       <executions>
          <execution>
             <id>config</id>
             <goals><goal>generate-sources</goal></goals>
             <configuration>
                <codeGenerators>
                   '''<generator>
                      '''<codeGeneratorClass>                                 
                          '''org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
                      '''</codeGeneratorClass>
                      '''<outputBaseDir>${jmxGeneratorPath}</outputBaseDir>
                      '''<additionalConfiguration>
                          '''<namespaceToPackage1>                                                   
                             '''urn:opendaylight:params:xml:ns:yang:controller==org.opendaylight.controller.config.yang
                          '''</namespaceToPackage1>
                      '''</additionalConfiguration>
                   '''</generator>
                   <generator>
                       <!-- existing CodeGeneratorImpl shoudl remain here -->
                   </generator>
               </codeGenerators>
               <inspectDependencies>true</inspectDependencies>
            </configuration>
          </execution>
       </executions>
       <dependencies>
          '''<dependency>
             '''<groupId>org.opendaylight.controller</groupId>
             '''<artifactId>yang-jmx-generator-plugin</artifactId>
             '''<version>${config.version}</version>
          '''</dependency>
          <dependency>
             <groupId>org.opendaylight.yangtools</groupId>
             <artifactId>maven-sal-api-gen-plugin</artifactId>
             <version>${yangtools.version}</version>
          </dependency>
       </dependencies>
    </plugin>
</code>  
We also need to add dependencies in the pom.xml file so the ''opendaylight-md-sal-binding'' and ''config'' yang imports can be located by the code generator:
<pre>
<dependency>
     <groupId>org.opendaylight.controller</groupId>
     <artifactId>config-api</artifactId>
</dependency>
<dependency>
      <groupId>org.opendaylight.controller</groupId>
      <artifactId>sal-binding-config</artifactId>
</dependency>
</pre>
After running mvn clean install you should see two files generated:
*'''ToasterProviderModule''' -  concrete class whose ''createInstance()'' method provides the OpendaylightToaster instance.
*'''ToasterProviderModuleFactory''' - concrete class instantiated internally by MD_SAL that creates '''ToasterProviderModule''' instances.  

'''Note''': these 2 classes are intended to be checked into Git as they will contain manually written code.

====Implement the ToasterProviderModule====
The '''ToasterProviderModule''' class is mostly complete from the code generation. The ''ToasterProviderModule.createInstance()'' method needs to be implemented to instantiate and wire the '''OpendaylightToaster''':

<pre>
    @Override
    public java.lang.AutoCloseable createInstance() {
        final OpendaylightToaster opendaylightToaster = new OpendaylightToaster();

        // Register our OpendaylightToaster instance as the RPC implementation for the ToasterService.
        final BindingAwareBroker.RpcRegistration<ToasterService> rpcRegistration = getRpcRegistryDependency()
                .addRpcImplementation(ToasterService.class, opendaylightToaster);

        // Wrap toaster as AutoCloseable and close registrations to md-sal at
        // close()
        final class AutoCloseableToaster implements AutoCloseable, ToasterData {

            @Override
            public void close() throws Exception {
                rpcRegistration.close();
            }

            @Override
            public Toaster getToaster() {
                return opendaylightToaster.getToaster();
            }
        }

        return new AutoCloseableToaster();
    }
</pre>

In the above code, the '''RpcProviderRegistry''' dependency has already been injected by the MD-SAL and is available via the ''getRpcRegistryDependency()'' method defined in the generated base class. The return type of ''createInstance()'' is '''AutoCloseable''' although the intent is to return a '''ToasterData''' instance so we must wrap the '''OpendaylightToaster ''' in an '''AutoCloseable''' instance.

We don't need to modify or implement anything in '''ToasterProviderModuleFactory''' for this example.
 
--------
'''QUESTION: An AutoCloseable return type is not well defined and it is unclear what actual interface type this method is suppose to return. Am I suppose to return a ToasterData? A ToasterService?''' <br>
'''QUESTION: Can this code be reduced to just instantiating the OpendaylightToaster and returning it?
*Have return type be ToasterData. The MD-SAL can wrap in AutoCloseable on return, if needed, if the returned instance doesn't implement AutoCloseable.
*Can the MD-SAL be smart enough to auto register the returned instance as an RPC service? The OpendaylightToaster implements RpcService via the ToasterService interface - the MD-SAL should have the info necessary to register it via addRpcImplementation.'''
--------

==== Build and deploy the updated bundle ====

Now that we have successfully written all of the code, build and deploy the bundle to the plugins directory.

====Define the initial XML configuration====

We have now defined the toaster data model (toaster.yang), an "interface" for the toaster provider service (toaster-provider.yang) and an implementation (toaster-provider-impl.yang). As we've seen, the toaster data model is usable at this point and can be accessed via REST. However, if the toaster provider bundle is deployed at this point, the '''make-toast''' RPC service wouldn't be available. Everything we have done so far is to define the service interface and a "possible" implementation. The last step is to actually tell MD-SAL to "deploy" the implementation, i.e. create an instance of the service ('''OpenDaylightToaster'''), resolve dependencies and advertise it for consumption/use. 

To do this, we need to create an xml file that defines the initial configuration for the toaster provider service deployment. The xml is actually a netconf edit-config with the toaster provider ''yin'' (yang-to-xml) as its payload ('''QUESTION: is this correct?''').  First it tells MD-SAL about the toaster provider service, which implementation to use, and then finally how to configure the implementation. Create an xml file named "03-Toaster.xml " and paste it into the configuration/initial folder of the distribution that you are running (i.e. controller/opendaylight/distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight/configuration/initial). <br>''Note: Be sure to save this xml file off. If you rebuild the distribution.opendaylight project, this folder will be deleted, including your file.''
<br>''''QUESTION: Does the 03 prefix matter? It doesn't look like the number prefix needs to be unique nor even be present. The files are sorted by name (XmlDirectoryPersistor) so it appears the intent of the number prefix is to impart some ordering so dependent bundles are loaded first?.
<pre>
<snapshot>
    <configuration>
        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">

                <!-- defines an implementation -->
                <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl">
                        prefix:toaster-provider-impl
                    </type>
                    
                    <name>toaster-provider-impl</name>

                    <rpc-registry>
                        <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-rpc-registry</type>
                        <name>binding-rpc-broker</name>
                    </rpc-registry>

                </module>
            </modules>

            <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <!-- exports and advertises the above module as a service -->
                <service>
                    <type xmlns:toaster="urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider">toaster:toaster-provider</type>
                    <instance>
                        <name>toaster-provider</name>
                        <provider>/modules/module[type='toaster-provider-impl'][name='toaster-provider-impl']</provider>
                    </instance>
                </service>
            </services>
        </data>

    </configuration>

    <required-capabilities>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding?module=opendaylight-md-sal-binding&amp;amp;revision=2013-10-28</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider?module=toaster-provider&amp;amp;revision=2014-01-31</capability>
        <capability>urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl?module=toaster-provider-impl&amp;amp;revision=2014-01-31</capability>
    </required-capabilities>

</snapshot>

</pre>

The '''modules''' section specifies the toaster-provider-impl module and its dependency configuration as defined in the ''toaster-provider-impl.yang'' file. The rpc-registry implementation is provided by MD-SAL and is needed for the '''OpenDaylightToaster'''.

The '''services''' section specifies the toaster-provider service interface and the toaster-provider-impl module as the implementation to instantiate and register.

This XML file must be put into the runtime ''configuration/initial'' directory (i.e. controller/opendaylight/distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight/configuration/initial ).

On startup, the XML files in the ''configuration/initial'' directory are loaded by the '''ConfigPersisterActivator'''. A '''ConfigPusher''' instance is instantiated to push the configs via the NetConf subsystem to the '''ConfigRegistryImpl'''.  When processing the toaster-provider-impl module in the toaster config file, the '''ToasterProviderModuleFactory''' class is located and instantiated and the ''createModule'' method is called to create a '''ToasterProviderModule''' instance. The ''ToasterProviderModule.createInstance'' method is then called to create and wire the '''OpenDaylightToaster'''.

For a detailed walk-through on how to make a 'config-subsystem aware' project please visit https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Examples:Sample_Project

'''QUESTION: There doesn't seem to be any output to tell you when a netconf file fails to get parsed or processed due to bad text. Where would this be printed?'''

===Invoke make-toast via RestConf===

It's finally time to make some delicious wheat toast! To invoke the make toast via the Restconf you will perform an HTTP POST to an operations URL.
<pre>
HTTP Method => POST
URL => http://localhost:8080/restconf/operations/toaster:make-toast 
Header =>   Content-Type: application/yang.data+json  
Body =>  
{
  "input" :
  {
     "toaster:toasterDoneness" : "10",
     "toaster:toasterToastType":"wheat-bread" 
  }
}
</pre>
''Note: Even though the toast type and doneness is defaulted in the yang model, you still have to provide their values here.'' 
<br>'''Question: Is that correct? Seems like if the values are defaulted in the yang data model, we shouldn't be forced to specify them. Even if we are, we need to clarify the error message.'''
<br>'''Question: Haven't tested the mandatory flag for leaf data - is it honored?'''

===Invoke cancel-toast via RestConf===
If you don't like burnt toast, you may want to cancel the make-toast operation part of the way through! You do this by invoking a restconf REST call in a very similar way as you invoke the make-toast.
<pre>
URL => http://localhost:8080/restconf/operations/toaster:cancel-toast
HTTP Method => POST
</pre>

Note: There is a bug in the way the RestconfImpl class processes / routes the REST requests. If you define the Content-Type header, then the rest call is routed to a method which expects a non-empty body. In this case though we don't have any input, so our body should be empty. Thus an exception is thrown. In order to make the cancel-toast call work successfully, you need to invoke the above call, with NO content-type define. By doing that you route the request to a different method, which expects an empty body. '''QUESTION: Definitely seems like there is an bug here. We should all content types with empty bodies for these calls.'''

= Part 3: Getting Toaster Status (Operational Data) =

During part 3 we will modify the '''OpendaylightToaster''' to update the ''toasterStatus'' field, changing it from "up" to "down" and vice-versa as toast is started/finished. 

===Add the Data Broker Service ===

The first step is to modify the ''toaster-provider-impl.yang'' to add a dependency on the MD-SAL's '''DataBroker''' service into our provider. Open up the ''toaster-provider-impl.yang'' file, and add the bolded text to the "augment /config:modules/config:module/config:configuration" section.
<code>
 ...
    //augments the configuration,  
    augment "/config:modules/config:module/config:configuration" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";
 <br>
            //Wires dependent services into this class - in this case the RPC registry service
            container rpc-registry {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-rpc-registry;
                    }
                }
            }
            
            '''//wires in the data-broker service 
            '''container data-broker {
            '''    uses config:service-ref {
            '''        refine type {
            '''            mandatory false;
            '''            config:required-identity mdsal:binding-data-broker;
            '''        }
            '''    }
            '''}
            
        }
    }
 ...
</code>
Rebuild the source code (mvn clean install) and you should now see that the '''AbstractToasterProviderModule''' has two new methods: ''getDataBroker()''  and ''getDataBrokerDependency()''. Additionally, a "DataBroker" and  DataBrokerBuilder files were generated.<br><Br>'''QUESTION: What are these classes used for?'''

=== Modify the OpendaylightToaster ===
Now we need to modify our OpendaylightToaster to pass the data broker service in. Add the setter method to the OpendaylightToaster.java
<code>
 ...
   private DataBrokerService dataBrokerService;<br>
   public void setDataProvider(DataBrokerService salDataProvider) {
        this.dataBrokerService = salDataProvider;
    }
 ...
</code>
Now we use the '''DataBrokerService''' and update the status when we are making toast. Since we want to update the status from several locations (making toast, canceling toast, and initializing the status) we will create an ''updateStatus'' method.
<code>
        ...
        private static final InstanceIdentifier<Toaster>  toasterIID = InstanceIdentifier.builder(Toaster.class).build();<br>
        private void updateStatus() {
            if (dataBrokerService != null) {
                //We start a transaction, such that our remove and put calls are atomic. 
                final DataModificationTransaction t = dataBrokerService.beginTransaction();
                //NOTE: We are interacting with the operational data store, as opposed to the config data store.
                //therefore to access this data you would go to the operational rest endpoint, instead of the config endpoint
                t.removeOperationalData(toasterIID);
               t.putOperationalData(toasterIID, getToaster()); 
                try {
                    t.commit().get();
                } catch (InterruptedException | ExecutionException e) {
                    log.warn("Failed to update toaster status, operational otherwise", e);
                }
            } else {
                log.trace("No data provider configured, not updating status");
            }
        }
    ...
</code>
In the ''updateStatus()'' method we leverage the existing ''getToaster()'' method call which determines the status of the toaster by checking the "currentTask" member. We then persist that information in the data broker by creating a transaction which removes the existing values, and then saves the new data into the operational data store. Now modify the following methods, adding a call to ''updateStatus()''.
<br>'''QUESTION: Why do we pass config information into the operational data? Can we safely assume there is only 1 instance? I think so...
<code>
     ...
     @Override
    public Future<RpcResult<Void>> cancelToast() {
        ...
        '''updateStatus();'''
        //Always return success from the cancel toast call.
        return Futures.immediateFuture( Rpcs.<Void>getRpcResult(true, Collections.<RpcError> emptySet()) ); 
    }
    ...
    @Override
    public Future<RpcResult<Void>> makeToast(MakeToastInput input) {
        log.debug("makeToast - Received input for toast");       
        ...       
        '''updateStatus();'''
        return currentTask;
    }
    ...
    private class MakeToastTask implements Callable<RpcResult<Void>> {
        ...
        @Override
        public RpcResult<Void> call() throws InterruptedException {
            //make toast just sleeps for 1 second per doneness level.
            Thread.sleep(1000 * toastRequest.getToasterDoneness());
            ...
            '''updateStatus();'''
            return Rpcs.<Void>getRpcResult(true, null, Collections.<RpcError> emptySet());
        }
    }
    ...
    public void setDataProvider(DataBrokerService salDataProvider) {
         this.dataBrokerService = salDataProvider;
         '''updateStatus();'''
     }
     ...
</code>
The next step is to inject the '''DataBrokerService'''  into the toaster inside of the ''ToasterProviderModule.createInstance()'' method:
<code>
      ...
      public java.lang.AutoCloseable createInstance() {
           ...
           '''opendaylightToaster.setDataProvider(getDataBrokerDependency());
           ...
      }
      ...
</code>
Finally, we need to modify the initial configuration xml file to add the '''data-broker''' dependency for the toaster-provider-impl module:
<code>
      ...
      <module>
                    <type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:config:toaster-provider:impl">
                        prefix:toaster-provider-impl
                    </type>
                     ...
                    '''<data-broker>
                    '''    <type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-data-broker</type>
                    '''    <name>binding-data-broker</name>
                    '''</data-broker>
                    ...
      </module>
      ...
</code>

====Getting the Operational Status ====
To get the operational status of the toaster you need to do a simple GET to the operational datastore.
<pre>
  HTTP Method: GET
  HTTP URL: http://localhost:8080/restconf/operational/toaster:toaster
</pre>
You should see the toaster status in the response. To see the toaster status change, perform a rest call to "make-toast" (see above) with a doneness of 10. Then within 10 seconds make the rest call to the operational datastore to see toaster status change to "down". 
<br>
''Note: You do NOT need to create a toaster in the "config" datastore in order to access this data in the operational data store. Right now they seem to be independent entities... '''QUESTION: Should they be? Or should we force them to be tied together? Or should we just have one endpoint, /restconf/data as discussed here? http://tools.ietf.org/html/draft-ietf-netconf-restconf-00#section-4.3.1'''

= Part 4: Additional Attributes in the Implementation - Count my toast! (JMX Access)=

For statistical purposes, we'd like to keep track of how many pieces of toast the toaster has made over time.  We need an attribute, '''toasts-made''', to track the count and a way to obtain the count. Whenever we '''make-toast''', we want to increment '''toasts-made'''.<br>

==Define the toasts-made attribute==
We'll define '''toasts-made''' as statistical state data on the toaster provider service implementation since that is where '''make-toast''' happens. This is achieved by augmenting the toaster-provider-impl module's '''config:state''' in ''toaster-provider-impl.yang'':
<pre>
augment "/config:modules/config:module/config:state" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";

            leaf toasts-made {
                type uint32;
            }

        }
    }
</pre>

The MD-SAL makes state data accessible via JMX.<br>

'''QUESTION: could toasts-made be defined as part of the toaster container itself?'''<br>
'''QUESTION: is state data also available via REST? via NetConf?<br>

Run 'mvn clean install' to generate the source. 3 additional classes are generated under ''src/main/yang-gen-config'':
*'''ToasterProviderRuntimeMXBean''' - interface that defines the ''getToastsMade()'' method to provide access to the '''toasts-made''' attribute.
*'''ToasterProviderRuntimeRegistration''' - concrete class that wraps a '''ToasterProviderRuntimeMXBean''' registration.
*'''ToasterProviderRuntimeRegistrator''' - concrete class that registers a '''ToasterProviderRuntimeMXBean''' implementation with the MD-SAL.

==Implement the toasts-made attribute==

Now that we've defined the data model for the '''toasts-made''' attribute we need to provide an implementation to update it. Since the '''OpenDaylightToaster''' makes toast, we'll implement it there.<br>

The '''ToasterProviderRuntimeMXBean''' provides the interface for '''toasts-made''' so we need to modify '''OpenDaylightToaster''' to implement the '''ToasterProviderRuntimeMXBean''' interface:

<code>
 public class OpendaylightToaster implements ToasterData, ToasterService, '''ToasterProviderRuntimeMXBean''' {
    ...
    '''private final AtomicLong toastsMade = new AtomicLong(0);
    ...
    <br>
    '''@Override
    '''public Long getToastsMade() {
        '''return toastsMade.get();
    '''}
    <br>
    ...
    <br>
    private class MakeToastTask implements Callable<RpcResult<Void>> {
        ...
        @Override
        public RpcResult<Void> call() throws InterruptedException {
            Thread.sleep(1000 * toastRequest.getToasterDoneness());
            ...
            <br>
            '''toastsMade.incrementAndGet();'''
            <br>
            ...
            return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
        }
    }
 }
</code>

==Register the ToasterProviderRuntimeMXBean service==

We need to do a final step to register the '''OpendaylightToaster''' as the '''ToasterProviderRuntimeMXBean''' service. We do this in the '''ToasterProviderModule''' via the '''ToasterProviderRuntimeRegistrator''' returned by the base class's ''getRootRuntimeBeanRegistratorWrapper()'' method:

<code>
    public java.lang.AutoCloseable createInstance() {
        final OpendaylightToaster opendaylightToaster = new OpendaylightToaster();
        ...
    
        // Register runtimeBean for toaster statistics via JMX
        '''final ToasterProviderRuntimeRegistration runtimeReg = getRootRuntimeBeanRegistratorWrapper().register(
        '''        opendaylightToaster);
        <br>
        ...
        final class AutoCloseableToaster implements AutoCloseable, ToasterData {
            @Override
            public void close() throws Exception {
                ...
                '''runtimeReg.close();
                ...
            }
            ...
        }
    }
</code>

Note: we also have to close the '''ToasterProviderRuntimeRegistration''' when the '''OpendaylightToaster''' instance is closed.

== Accessing toasts-made via JMX==
The toasts-made attribute that we added is available via MBeans through the java management beans. You can programmatically access these through the mbean platform (see [https://wiki.opendaylight.org/view/Toaster_MD-SAL_Sample:Toaster_Tutorial#Getting_Provider_Runtime_data_exposed_to_config-subsystem] ) or via jConsole.
*''JConsole is a utility shipped with each JDK and is located in the bin directory of your java home folder.''
*First, start the controller using the -jmx flag.<pre>./run.sh -jmx</pre>This flag enables controller allowing jconsole to attach.<Br><br>Launch JConsole, double click on the jconsole application under <pre>$JAVA_HOME/bin/jconsole</pre>''Note: Path may change based on OS and installation''
*Connect to the running eclipse process either by selecting the application, or specifing the "hostname:1088" in the remote connect dialog. For more information on JMX check out this document: [https://wiki.opendaylight.org/images/8/89/Jconsole.pdf].
*Once connected, navigate to the "MBeans" tab.
:*Expand the "org.opendalight.controller->RuntimeBean->toaster-provider-impl->toster-provider-impl" nodes.
*Select "Attributes". You will now see the "ToastsMade" attribute displayed and this attribute will change when the make-toast RPC call is executed.
<Br>'''Question: It seems like we should be able to access this information via restconf as well. Is that true? When we question /restconf/config/toaster-provider-impl:toaster-provider-impl it should be displayed.... Is that true? Is it a different URL since it is an augmentation of modules/module?

= Part 5: Add a consumer of the ToasterService  =

We've seen how we can use RestConf to access the ToasterService RPC methods. In this section we'll show how to access the ToasterService programmatically from within the controller.
<br>
We'll create a new service called '''KitchenService''' that provides a method to make breakfast. This service will access the ToasterService to provide the toast for our breakfast.
<br>
Note: create a new project/bundle for this. In the pre-built toaster sample, it's toaster-consumer.
== Project Set Up ==
We recommend creating a new project for this service. Lets call it "odl-kitchen" service. We need to create a new folder and then we can copy and modify the pom.xml file from our odl-toaster example.
<code>
    #From controller/md-sal/samples/ folder:
    mkdir -p odl-kitchen
    cp odl-toaster/pom.xml odl-kitchen
    cd odl-kitchen
</code>
Edit the pom.xml, changing the bundle name to "odl-kitchen".<code><artifactId>odl-toaster</artifactId></code>. Additionally, since our kitchen service is going to leverage the odl-toaster, we need to import that bundle as a dependency. Add the follow dependency to the dependency section.

<code>
   <dependency>
      <groupId>org.opendaylight.controller.samples</groupId>
      <artifactId>odl-toaster</artifactId>
      <version>1.1-SNAPSHOT</version>
   </dependency>
</code>
You can now import this project into eclipse if you desire.

==Define the KitchenService interface==

For the sake of brevity, we'll hand-code the KitchenService data model and interface instead of defining it in yang. In a true kitchenService model you would likely want to define the KitchenService in yang to get the benefit of auto-generated classes. For now, define an enumeration and interface java files under src/main/java, in the org.opendaylight.controller.sample.kitchen.api package.
<pre>
//EggsType.java
public enum EggsType {
    SCRAMBLED,
    OVER_EASY,
    POACHED
}

//KitchenService.java
public interface KitchenService {

    boolean makeBreakfast( EggsType eggs, Class<? extends ToastType> toast, int toastDoneness );
}
</pre>

Our breakfast only includes eggs with the toast for simplicity - a complete breakfast may also include bacon or sausage and coffee. Eggs, breakfast meat, coffee etc could also be separate data models with corresponding services like the ToasterService - we leave that as an exercise for the reader.

==Define the KitchenService implementation==

Next we create a class, '''KitchenServiceImp''', to implement the interface and access the ToasterService to make the toast:
<pre>
package org.opendaylight.controller.sample.kitchen.impl;

import java.util.concurrent.ExecutionException;

import org.opendaylight.controller.sample.kitchen.api.EggsType;
import org.opendaylight.controller.sample.kitchen.api.KitchenService;
import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.MakeToastInputBuilder;
import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.ToastType;
import org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.ToasterService;
import org.opendaylight.yangtools.yang.common.RpcResult;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class KitchenServiceImpl implements KitchenService {

    private static final Logger log = LoggerFactory.getLogger( KitchenServiceImpl.class );

    private final ToasterService toaster;

    public KitchenServiceImpl(ToasterService toaster) {
        this.toaster = toaster;
    }

    @Override
    public boolean makeBreakfast( EggsType eggs, Class<? extends ToastType> toast, int toastDoneness ) {

        // Access the ToasterService to make the toast.
        // We don't actually make the eggs for this example - sorry.
        MakeToastInputBuilder toastInput = new MakeToastInputBuilder();
        toastInput.setToasterDoneness( (long) toastDoneness);
        toastInput.setToasterToastType( toast );

        try {
            RpcResult<Void> result = toaster.makeToast( toastInput.build() ).get();

            if( result.isSuccessful() ) {
                log.trace( "Toast was successfully finished" );
            } else {
                log.warn( "Toast was not successfully finished" );
            }

            return result.isSuccessful();
        } catch( InterruptedException | ExecutionException e ) {
            log.warn( "Error occurred during toast creation" );
        }
        return false;
    }
}
</pre>

==Wiring the KitchenService implementation==

Similar to the toaster provider service, we'll describe the kitchen service interface and implementation in yang and provide the initial configuration xml so the MD-SAL can wire it up.

===Define the kitchen service yang===

We'll define the kitchen service interface in ''kitchen-service.yang'':
<pre>
module kitchen-service {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:kitchen-service";
    prefix "kitchen-service";

    import config { prefix config; revision-date 2013-04-05; }

    description
        "This module contains the base YANG definitions for kitchen-service services.";

    revision "2014-01-31" {
        description
            "Initial revision.";
    }

    // This is the definition of a service
    identity kitchen-service {
        base "config:service-type";
        config:java-class "org.opendaylight.controller.sample.kitchen.api.KitchenService";
    }
}
</pre>

Note that ''config:java-class'' doesn't have to be backed by a yang data model. The MD-SAL also allows a hand-coded java interface.
<br><br>
Next define the kitchen service implementation and its dependencies in ''kitchen-service-impl.yang'':
<pre>
module kitchen-service-impl {

    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:kitchen-service:impl";
    prefix "kitchen-service-impl";

    import config { prefix config; revision-date 2013-04-05; }
    import rpc-context { prefix rpcx; revision-date 2013-06-17; }

    import kitchen-service { prefix kitchen-service; revision-date 2014-01-31; }
    import opendaylight-md-sal-binding { prefix mdsal; revision-date 2013-10-28; }

    description
        "This module contains the base YANG definitions for
        kitchen-service impl implementation.";

    revision "2014-01-31" {
        description
            "Initial revision.";
    }

    // This is the definition of a service implementation
    identity kitchen-service-impl {
            base config:module-type;
            config:provided-service kitchen-service:kitchen-service;
            config:java-name-prefix KitchenService;
    }

    augment "/config:modules/config:module/config:configuration" {
        case kitchen-service-impl {
            when "/config:modules/config:module/config:type = 'kitchen-service-impl'";

            container rpc-registry {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-rpc-registry;
                    }
                }
            }
        }
    }
}
</pre>
 === Update Kitchen Pom.xml (if you didn't copy it) ===
If you didn't copy the pom.xml from odl-toaster, then you will now need to add the yang-maven-plugin to the pom.xml (otherwise, you can skip this step, or optionally clean up the extra code generators):
<pre>
<plugin>
       <groupId>org.opendaylight.yangtools</groupId>
       <artifactId>yang-maven-plugin</artifactId>
       <executions>
          <execution>
             <id>config</id>
             <goals><goal>generate-sources</goal></goals>
             <configuration>
                <codeGenerators>
                   <generator>
                      <codeGeneratorClass>                                 
                          org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
                      </codeGeneratorClass>
                      <outputBaseDir>${jmxGeneratorPath}</outputBaseDir>
                      <additionalConfiguration>
                          <namespaceToPackage1>                                                   
                             urn:opendaylight:params:xml:ns:yang:controller==org.opendaylight.controller.config.yang
                          </namespaceToPackage1>
                      </additionalConfiguration>
                   </generator>                   
               </codeGenerators>
               <inspectDependencies>true</inspectDependencies>
            </configuration>
          </execution>
       </executions>
       <dependencies>
          <dependency>
             <groupId>org.opendaylight.controller</groupId>
             <artifactId>yang-jmx-generator-plugin</artifactId>
             <version>${config.version}</version>
          </dependency>
       </dependencies>
    </plugin>
</pre>

Add the pom dependencies for the yang imports (again, if you copied odl-toaster pom.xml, you can skip this step):
<pre>
    <dependency>
       <groupId>org.opendaylight.controller</groupId>
       <artifactId>config-api</artifactId>
    </dependency>
    <dependency>
       <groupId>org.opendaylight.controller</groupId>
       <artifactId>sal-binding-config</artifactId>
    </dependency>
</pre>

=== Implement the KitchenServiceModule.createInstance() ===
Now that our yang data models and pom.xml files are set up correctly, lets run a mvn clean install. This will generate multiples files, of which we only need to modify the KitchenServiceModule class. Edit the KitchenServicemodule.java file, and implement the createInterface() section.
<code>
@Override
    public java.lang.AutoCloseable createInstance() {
        //retrieves the toaster service from the MD-SAL
        ToasterService toasterService = getRpcRegistryDependency().getRpcService(ToasterService.class);<br>
        final KitchenServiceImpl kitchen = new KitchenServiceImpl( toasterService );<br>
        return null; //TODO - missing the remainder of the implementation....
    }
</code>

=== Define initial configuration ===
Finally, add the kitchen service and module definitions to the initial configuration xml created in a previous section:
<code>
 <snapshot>
    <configuration>
        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
               ...
               '''<module>
                  '''<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:config:kitchen-service:impl">
                     '''prefix:kitchen-service-impl
                  '''</type>
                  '''<name>kitchen-service-impl</name>
                  <br>
                  '''<rpc-registry>
                     '''<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">binding:binding-rpc-registry</type>
                     '''<name>binding-rpc-broker</name>
                  '''</rpc-registry>
                '''</module>
            </modules>
            <br>
            <services xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
               ...
               '''<service>
                  '''<type xmlns:toaster="urn:opendaylight:params:xml:ns:yang:controller:config:kitchen-service">toaster:kitchen-service</type>
                  '''<instance>
                     '''<name>kitchen-service</name>
                     '''<provider>/modules/module[type='kitchen-service-impl'][name='kitchen-service-impl']</provider>
                  '''</instance>
              '''</service>                
            </services>
        </data>
    </configuration>
    ...
 </snapshot>
</code>

= Part 6: Notifications - Tell me when my Toast is done! (Notifications)=

When a piece of toast is made we'd like for the '''OpenDaylightToaster''' to provide a notification when it's done, or is cancelled, or encountered an error. This can be consumed by an implementation of the '''ToasterListener''' interface or by an external netconf client.

==Define the toastDone notification==

We'll define a notification called '''toastDone''' in the toaster module. Edit toaster.yang and add the following section underneath "module toaster {"
<pre>
   notification toastDone {
      description
        "Indicates that the toast in progress has completed.";
      leaf toastStatus {
        type enumeration {
          enum "done" {
            value 0;
            description "The toast is done.";
          }
          enum "cancelled" {
            value 1;
            description
              "The toast was cancelled.";
          }
          enum "error" {
            value 2;
            description
              "The toaster service was disabled or the toaster is broken.";
          }
        }
        description
          "Indicates the final toast status";
      }
   }  // notification toastDone
</pre>

Run 'mvn clean install' to generate the source. 3 additional classes are generated under ''src/main/yang-gen-sal'':

*'''ToastDone''' - interface for the '''toastDone''' notification that defines a ''getToastStatus()'' method.
*'''ToastDoneBuilder''' - concrete class for building a '''ToastDone''' instance.
*'''ToasterListener''' - interface for consumers of the '''toastDone''' notification to implement that defines an ''onToastDone(ToastDone)'' method.

==Wire the OpenDaylightToaster for notification==

The '''OpenDaylightToaster''' needs access to the MD-SAL's '''NotificationProviderService''' in order to send notifications. We need to specify the '''NotificationProviderService''' as a dependency in the toaster-provider-impl module by adding an entry to the '''config:configuration''' augmentation: 
<code>
     augment "/config:modules/config:module/config:configuration" {
        case toaster-consumer-impl {
            when "/config:modules/config:module/config:type = 'toaster-consumer-impl'";
            ...
            <br>
            '''container notification-service {
                '''uses config:service-ref {
                    '''refine type {
                        '''mandatory true;
                        '''config:required-identity mdsal:binding-notification-service;
                    '''}
                '''}
            '''}
        }
    }
</code>

Run 'mvn clean install' to generate the source.

The generated '''AbstractToasterProviderModule''' class should now have a ''getNotificationServiceDependency()'' method. We can access that method in our '''ToasterProviderModule''' implementation.
<br><br>
First we add a class member for '''NotificationProviderService''' to '''OpenDaylightToaster''' with a setter:
<pre>
private NotificationProviderService notificationProvider;

public void setNotificationProvider(NotificationProviderService salService) {
        this.notificationProvider = salService;
    }
</pre>

Next, in ''ToasterProviderModule.createInstance()'', inject the '''NotificationProviderService''' into the                 '''OpenDaylightToaster''':
<pre>
opendaylightToaster.setNotificationProvider(getNotificationServiceDependency());
</pre>

Finally we need to add the dependency for the 'notification-service' to the toaster-provider-impl module in the initial configuration XML file as we did earlier with the 'rpc-registry':
<code>
 <snapshot>
    <configuration>
        <data xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <!-- Specify the configuration for the toaster-provider-impl module as defined in the 
                        toaster-provider-impl.yang file -->
                <module>
                    ...
                    '''<notification-service>
                        '''<type xmlns:binding="urn:opendaylight:params:xml:ns:yang:controller:md:sal:binding">
                            '''binding:binding-notification-service
                        '''</type>
                        '''<name>binding-notification-broker</name>
                    '''</notification-service>
                </module>
            </modules>
            ...
        </data>
    </configuration>
    ...
 </snapshot>
</code>

==Send the notification==

The '''OpendaylightToaster''' is now ready to send notifications.
<code>
 public class OpendaylightToaster implements ToasterData, ToasterService, ToasterProviderRuntimeMXBean, AutoCloseable {
    ...
    <br>
    public Future<RpcResult<Void>> cancelToast() {
        ...
        updateStatus();
        ToastDoneBuilder toastDone = new ToastDoneBuilder();
        toastDone.setToastStatus(ToastStatus.Cancelled);
        notificationProvider.publish(toastDone.build());
        ...
    }
    ...
    <br>
    private class MakeToastTask implements Callable<RpcResult<Void>> {
        ...
        @Override
        public RpcResult<Void> call() throws InterruptedException {
            Thread.sleep(1000 * toastRequest.getToasterDoneness());
            ...
            '''ToastDoneBuilder notifyBuilder = new ToastDoneBuilder();
            '''notifyBuilder.setToastStatus(ToastStatus.Done);
            '''notificationProvider.publish(notifyBuilder.build());
            ...
            return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
        }
    }
 }
</code>
