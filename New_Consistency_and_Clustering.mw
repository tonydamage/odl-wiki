==[[User:Ckd|Colin]]'s Opinionated Next Steps==

# We should just use Akka
#* It seems to provide most, if not all, of the features we want
#* The people running it seem to really know what they're doing
#* They offer concrete, understandable consistency properties that can be configured
#* It's Scala/Java-based
# Some of us should just fork off and start testing a version of OpenDaylight which replaces Infinispan with Akka
# In the longer run, we need to find better, more flexible APIs for things like
#* Picking CP vs. AP and specifying merge policies when/if we have AP
#* Picking persisted vs. ephemeral state
#* Configuring the cluster itself, e.g., potential members
#* Specifying sharding/locality information
#* Possibly also specifying query optimizations, e.g., should we build indices on some of the object's keys

==Coarse Next Steps==

# <s>Figure out what have now with Infinispan
#* Can we figure out what properties it gives us, if any?
#* Can we figure out how to make it not suck?
#* Is the Infinispan team interested in our use case?
#* Is there something simple we can do to bring JGroups up through Infinispan?</s>
#* I think that we have enough evidence than Infinispan doesn't quite do what we want to move on here. --[[User:Ckd|Colin]]
# Figure out if we want to have our own project? Giovanni says yes.
# Explore our other options: Akka, Cassandra, Zookeeper, JGroups, etc.
# This is all basically just to get us where we should have been at the Hydrogen release.
#* At the same time, there are at least 3 different areas we need to look at from the point of view of consistency:
#*# What consistency models do we want to have within a “region”? Also what is a “region”?
#*# Do we want to start talking about inter-regioin consistency and state exchange?
#*#* Does this also tie into controller federation? Can we avoid this?
#*# What consistency model do we want to provide in the network?
#*#* In particular, how does merging after a partition play into this?

==Big (Long-Term) Questions==
# How much state needs to be replicated and where?
#* Jan points out that if you push every flowmod to every controller that’s going to limit your scalability.
#* At the same time, state that is logically global has to live everywhere.
#* Exploiting locality seems like a really good idea, but you re doing it at the risk of being less fault-tolerant.
#* We probably want to consider the set of possible controllers for a given switch to fail over to and make sure that we replicate any state we might need over to them.
# How far can we scale this strongly consistent model?
# Are there fundamental trade-offs we’re somehow making by choosing strong consistency?
#* What are they and how can they bite us?
# Do we want to have a micro-controller per switch? How might that be done?
#* Could be a full-fledged version of the controller. Could be something simpler.
# Why didn’t we do this with protocols in the past, e.g., OSPF?
#* Was it scale? Physical distances? Just not having the right tools?
#* What does 4D have to say about this?
