'''Q-1: MD-SAL architecture 101:''' 
:* '''What is the overall architecture, components and functionality?'''
:*  '''Who supplies which components, how are the components plumbed, etc.?'''

'''A-1:'''
:The overall MD-SAL architecture did not really change from the Hard SAL. As with the Hard SAL, plugins can be data providers, or data consumers or both (although the Hard SAL did not explicitly name them as such). Just like the Hard SAL, the MD-SAL connects data consumers to appropriate data providers and (optionally) facilitates data adaptation between them. 

:Now, in the Hard SAL, the SAL APIs, request routing between consumers and providers, and data adaptations are all statically defined at compile/build time. In the MD-SAL, the SAL APIs and request routing between consumers and providers are defined from models, and data adaptations are provided by 'internal' adaptation plugins. API code is generated from models when a plugin is compiled. The API code is loaded into the controller along with the rest of the plugin containing the model when the plugin OSGI bundle is loaded into the controller.

:The Hard SAL and the MD-SAL are shown side-by-side in the following figure:

[[File:SAL-Comparison.png]]

:The Hard SAL provides request routing (selects an SB plugin based on service type) and optionally provides service adaptation, if an NB (Service, abstract) API is different from its corresponding SB (protocol) API. For example, in the above figure the Hard SAL routes requests from NB-Plugin 1 to SB Plugins 1 and 2. Note that the plugin SB and NB APIs in this example are essentially the same (although both of them need to be defined). Request routing is based on plugin type: the SAL know which node instance is served by which plugin, and when an NB Plugin requests an operation on a given node, the request is routed to the appropriate plugin which then routes the request to the appropriate node. The Hard SAL can also provide service abstractions and adaptations. For example, in the above figure NB Plugin 2 is using an abstract API to access services provided by SB Plugins 1 and 2. The translation between the SB Plugin API and the abstract NB API is done in the Abstraction module in the Hard SAL.

:The MD-SAL provides request routing and the infrastructure to support service adaptation, but it does not provide service adaptation itself; service adaptation is provided by plugins. From the MD-SAL’s point of view, the Adaptation Plugin is a regular plugin: it provides data to the SAL and consumes data form the SAL through APIs generated from models. An Adaptation Plugin basically performs model-to-model translations between two APIs. Request Routing in the MD-SAL is done on both protocol type and node instances, since node instance data is exported from the plugin into the SAL (the model data contains routing information). 

:The simplest MD-SAL APIs generated from models (RPCs and Notifications, both supported in the yang modeling language) are functionally equivalent to Hard SAL function call APIs. Additionally, the MD-SAL can store data for models defined by plugins: provider and consumer plugins can exchange data through the MD-SAL storage (more details in later sections). Data in the MD-SAL is accessed through getter and setter APIs generated from models. Note also that the Hard SAL is stateless.

:Note that in the above figure, both NB Hard SAL Plugins provide REST APIs to controller client applications.

:Functionality provided by the MD-SAL is basically to facilitate the plumbing between providers and consumers.  A provider or a consumer can register itself with the MD-SAL. A consumer can find a provider that it’s interested in. A provider can generate notifications; a consumer can receive notifications and issue RPCs to get data from providers. A provider can insert data into SAL’s storage; a consumer can read data from SAL’s storage. 

:Note that the structure of SAL APIs is different in the MD-SAL than in the Hard SAL.  The Hard SAL typically has both NB and SB APIs even for functions/services that are mapped 1:1 between SB Plugins and NB Plugins. For example, in the current Hard SAL implementation of the OpenFlow Plugin and applications, the NB SAL APIs used by OF applications are mapped 1:1 onto SB OF Plugin APIs. The MD-SAL allows both the NB plugins and SB plugins to use the same API generated from a model. One plugin becomes an API (service) provider; the other becomes an API (service) Consumer. This eliminates the need to define two different APIs and to provide three different implementations even for cases where APIs are mapped onto each other 1:1. The MD SAL provides instance-based request routing between multiple provider plugins.

<br />

'''Q-2: What functionality does the MD-SAL assume? For example, does the SAL assume the network model is a part of the SAL?'''

'''A-2''': 
:The MD-SAL does not assume any model – all models are provided by plugins. The MD-SAL only provides infrastructure and plumbing for plugins.

<br />

'''Q-3: What is the "day in the life" of an MD-SAL plugin?'''

'''A-3:'''

:All plugins (protocol, application, adaptation, ...) have the same lifecycle. Any plugin’s life has two distinct phases - design and operation.

:During the design phase, the plugin’s designer performs the following actions:
:* The designer decides which data will be consumed by the plugin and imports the SAL APIs generated from the API provider’s models. Note that the topology model is just one possible data type that may be consumed by a plugin. The list of currently available data models and their APIs is here <#provide pointer to Tony’s list#>
:* The designer decides which data and how will be provided by the plugin and designs the data model for the provided data. The data model (expressed in yang) is then run through the yang tools <#include pointer to yang tools#>, which generate the SAL APIs for the model.
:* The implementations for the generated consumer and provider APIs, along with other plugin features and functionality, are developed. The resulting code is packaged in a “plugin” OSGI bundle. Note that a developer may package a subsystem code in multiple plugins / applications  that may communicate with each other through the SAL. 
:* The generated APIs and a set of helper classes are also build and packaged in an “API” OSGI bundle.

:The plugin development process is shown in the following figure.
