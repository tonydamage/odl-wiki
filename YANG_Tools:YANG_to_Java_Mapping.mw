= YANG to JAVA mapping =
== Package name ==
The package name consists from following parts:
* <font color="red">opendaylight prefix</font color> - every package name starts with prefix <code>'''org.opendaylight.yang.gen.v'''</code> which is hardcoded in <code>'''BindingGeneratorUtil.moduleNamespaceToPackageName()'''</code>.
* <font color="green">YANG version</font color> - is specified through '''module''' substatement '''yang-version'''
* <font color="blue">namespace</font color> - equals to value of '''module''' subelement '''namespace''' argument value. The namespace characters ''': / : - @ $ # ' * + , ; = and character group:/''') are replaced with periods ('''.''').
*  <font color="violet">revision</font color> - concatenation of word <code>rev</code> and value of '''module''' subelement '''revision''' argument value without leading zeros before month and day (e.g. rev201379)

After the package name is generated then it is checked if it contains any JAVA key words or digits. If it is so then before this tokens is adden underscore ('''_''').
List of key words which are prefixed with underscore:<br />
<code>abstract, assert, boolean, break, byte, case, catch, char, class, const, continue, default, double, do, else, enum, extends, false, final, finally, float, for, goto, if, implements, import, instanceof, int, interface, long, native, new, null, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, true, try, void, volatile, while</code>

As an example suppose following yang model:<br />
<source>
module module {
    
    namespace <font color="blue">"urn:2:case#module"</font color>
    prefix "sbd";

    organization "OPEN DAYLIGHT";
    contact "http://www.whatever.com/";

    revision <font color="violet">2013-07-09</font color> {        
    }
}
</source>
Package name will be 
<font color="red">org.opendaylight.yang.gen.v</font color><font color="green">1</font color><font color="blue">.urn:2:case#module</font color><font color="violet">.rev201379</font color><br /> 
and after replacing digits and JAVA keywords<br />
<font color="red">org.opendaylight.yang.gen.v</font color><font color="green">1</font color><font color="blue">.urn._2._case.module</font color><font color="violet">.rev201379</font color><br />
=== Other package names ===
In some cases there are generated also additional packages. It happens in cases where superior YANG elements contains specific subordinate YANG elements (see table below).<br />

{| class="wikitable"
|-
! Superior element !! Subordinate element
|-
| list || list, container, choice
|-
| container || list, container, choice
|-
| choice || leaf, list, leaf-list, container, case
|-
| case || list, container, choice
|-
| rpc.input
rpc.output 
|| list, container, <small>(choice isn't supported)</small>
|-
| notification || list, container, <small>(choice isn't supported)</small>
|}
In this case the subordinate elements aren't mapped only to JAVA getter methods in interface of superior element but there are also generated packages which names consist of superior element package name + superior element name.<br />
''In example YANG model suppose that <code>container</code> element '''cont''' is direct subelement of module''<br /><br />
<font face="Courier">
container <font color="red">'''cont'''</font color> { <br />
&nbsp;&nbsp;container <font color="green">'''cont-inner</font color> {<br /> 
&nbsp;&nbsp;}<br />
&nbsp;&nbsp;list <font color="green">'''outter-list'''</font color> {<br />
&nbsp;&nbsp;&nbsp;&nbsp;list list-in-list {<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;}<br />
}<br />
</font face> 
''Container <font color="red">'''cont'''</font color> is first level element for second level elements <font color="green">'''cont-inner'''</font color> and <font color="green">'''outter-list'''</font color>.<br />

JAVA code will be generated in following structure:<br />
*org.opendaylight.yang.gen.v1.urn.module.rev201379 - module level
** Cont.java
*org.opendaylight.yang.gen.v1.urn.module.rev201379.'''<font color="red">cont</font color>''' - '' '''cont''' container level''
** ContInner.java
** OutterList.java
<br />
<font face="Courier">
container cont { <br />
&nbsp;&nbsp;container cont-inner {<br /> 
&nbsp;&nbsp;}<br />
&nbsp;&nbsp;list <font color="red">'''outter-list'''</font color> {<br />
&nbsp;&nbsp;&nbsp;&nbsp;list <font color="green">'''list-in-list</font color>''' {<br />
&nbsp;&nbsp;&nbsp;&nbsp;}<br />
&nbsp;&nbsp;}<br />
}<br /><br />
</font face>
''list <font color="red">'''outter-list'''</font color> is first level element for second level element <font color="green">'''list-in-list'''</font color> ''

JAVA code will be generated in following structure:<br />
*org.opendaylight.yang.gen.v1.urn.module.rev201379.'''<font color="red">cont</font color>.<font color="green">outter.list</font color>''' - '' '''outter-list''' list level''
** ListInList.java

== Class and interface name ==
Some YANG elements are mapped to JAVA classes and interfaces. The name of YANG element may contain various characters which aren't permitted in JAVA class names. Firstly whitespaces are trimmed from YANG name. Next characters '''space, -, _''' are deleted and subsequent letter is capitalized. At the end first letter is capitalized.
Transformation example:<br />
<code>
example-name without_capitalization<br />
</code>
is mapped to<br /> 
<code>
ExampleNameWithoutCapitalization
</code>

== Getters and setters name ==
In some cases are YANG elements generated as getter or setter methods. This methods are created through class <code>'''MethodSignatureBuilder'''</code><br />
The process for getter is:<br />
* name of YANG element is converted to JAVA class name style
* the word <code>get</code> is added as preffix
* return type of the getter method is set to element's <code>type</code> substatement value
<br />The process for setter is:<br />
* name of YANG element is converted to JAVA class name style
* word <code>set</code> is added as preffix
* input parameter name is set to element's name converted to JAVA parameter style
* return parameter is set to void

== Module ==
YANG module is converted to JAVA as two JAVA classes. Each of the class is in the separate JAVA file. The names of JAVA files are composed as follows:<br />
<font color="red"><YANG_module_name></font color><font color="green"><Sufix></font color>.java
where <sufix> can be '''Data''' or '''Service'''.<br />

<table border="1">
<tr>
<td>YANG</td>
<td>JAVA</td>
</tr>
<tr>
<td rowspan="2">
<source>
module module {
    
    namespace "urn:module";
    prefix "sbd";

    organization "OPEN DAYLIGHT";
    contact "http://www.whatever.com/";    

    revision 2013-07-09 {
    }
}
</source>
</td>
<td>
<font color="red">Module</font color><font color="green">Data</font color>.java
<source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379;
public interface ModuleData {
}
</source>
</td>
</tr>
<tr>
<td>
<font color="red">Module</font color><font color="green">Service</font color>.java
<source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379;
public interface ModuleService {
}
</source>
</td>
</tr>
</table>

== Typedef ==
YANG <code>typedef</code> statement is mapped to JAVA class. Typedef may contain following substatement:<br />
{| class="wikitable"
|-
! Substatement!! How si argument mapped to JAVA
|-
| <code>[[#Type's valid arguments|type]]</code>|| is mapped as class attribute
|-
| <code>descripton</code> || isn't mapped
|-
| <code>units</code>|| isn't mapped
|-
| <code>default</code> || isn't mapped
|}
{| class="wikitable"

=== Type's valid arguments ===
Simple values of type argument are mapped as follows:
{| class="wikitable"
|-
! Type's argument!! Mapped to JAVA
|-
| boolean  || Boolean
|- 
| empty  || Boolean
|- 
| int8  || Byte
|- 
| int16  || Short
|- 
| int32  || Integer
|- 
| int64  || Long
|-
| string  || 
*String or
*[[#String mapping|<code>class</code> (if <code>pattern</code> substatement is specified)]] 
|- 
| decimal64  || Double
|- 
| uint8  || Short
|- 
| uint16  || Integer
|- 
| uint32  || Long
|- 
| int64  || BigInteger
|- 
| binary  || byte[]
|}


Complex values of type argument are mapped as follows:
{| class="wikitable"
|-
! Type's argument!! Mapped to JAVA
|-
| [[#Enumeration's substatement enum|enumeration]]  || <code>enum</code>
|- 
| [[#Bits's substatement bit|bits]]  || <code>class</code>
|- 
| leafref  || ??
|- 
| identityref  || ??
|- 
| [[#Union's substatement type|union]]  || <code>class</code>
|- 
| instance-identifier  || ??
|}


==== Enumeration's substatement enum ====
The YANG <code>enumeration</code> type has to contain some <code>enum</code> substatements. Enumeration is mapped as JAVA <code>enum</code> type (standalone class) and every YANG <code>enum</code> subelement is mapped to JAVA <code>enum</code>'s predefined values.<br />
<code>Enum</code> substatement can have following substatements:<br />
{| class="wikitable"
|-
! Enum's substatement!! mapping to JAVA
|-
| description || isn't mapped
|-
| value || mapped as input parameter for every predefined value of enum
|}
Example of maping of YANG enumeration to JAVA
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>    
</tr>
<tr>
    <td>
    <source>
typedef typedef-enumeration {
    type enumeration {
        enum enum1 {
            description "enum1 description";
            value 18;
        }
        enum enum2 {
            value 16;
        }
        enum enum3 {
        }    		
    }
}       </source>
    </td>
    <td>
    <source lang="java">
public enum TypedefEnumeration {
    Enum1(18),
    Enum2(16),
    Enum3(19);

    int value;

    private TypedefEnumeration(int value) {
        this.value = value;
    }
}
    </source>    
    </td>
</tr>
</table>

==== Bits's substatement bit ====
The YANG <code>bits</code> type has to contain some <code>bit</code> substatements. YANG <code>Bits</code> is mapped to JAVA class (standalone class) and every YANG <code>bits</code> subelement is mapped to class boolean attributes. In addition are overriden Object methods <code>hash, toString, equals</code>.<br />
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
    <th>JAVA overriden Object methods</th>
</tr>
<tr>
    <td>
    <source>
typedef typedef-bits {
  type bits {
    bit first-bit {
      description "first-bit description";
        position 15;
      }
    bit second-bit; 
  }
} 
    </source>
    </td>
    <td>
    <source lang="java">
public class TypedefBits {

    private Boolean firstBit;
    private Boolean secondBit;

    public TypedefBits() {
        super();
    }

    public Boolean getFirstBit() {
        return firstBit;
    }
    
    public void setFirstBit(Boolean firstBit) {
        this.firstBit = firstBit;
    }
    
    public Boolean getSecondBit() {
        return secondBit;
    }
    
    public void setSecondBit(Boolean secondBit) {
        this.secondBit = secondBit;
    }
}
    </source>    
    </td>
    <td>
    <source lang="java">
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result +
     ((firstBit == null) ? 0 : firstBit.hashCode());
    result = prime * result +
     ((secondBit == null) ? 0 : secondBit.hashCode());
    return result;
}

@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    TypedefBits other = (TypedefBits) obj;
    if (firstBit == null) {
        if (other.firstBit != null) {
            return false;
        }
    } else if(!firstBit.equals(other.firstBit)) {
        return false;
    }
    if (secondBit == null) {
        if (other.secondBit != null) {
            return false;
        }
    } else if(!secondBit.equals(other.secondBit)) {
        return false;
    }
    return true;
}

@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("TypedefBits [firstBit=");
    builder.append(firstBit);
    builder.append(", secondBit=");
    builder.append(secondBit);
    builder.append("]");
    return builder.toString();
}
    </source>
    </td>
</tr>

</table>

==== Union's substatement type ====
If type of typedef is <code>union</code> it has to contain <code>type</code> substatements. <code>Union</code> typedef is mapped to class and its <code>type</code> subelements are mapped to private class attributes. For every YANG union subtype si generated own JAVA constructor with a parameter which represent just one attribute.<br />
Example to union mapping:<br />
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
    <th>JAVA overriden Object methods</th>    
</tr>
<tr>
    <td>
    <source>
typedef typedef-union {
    type union {
        type int32;
        type string;
    }
}    
    </source>
    </td>
    <td>
    <source lang="java">
public class TypedefUnion {



    private Integer int32;
    private String string;

    public TypedefUnion(Integer int32) {
        super();
        this.int32 = int32;
    }
    
    public TypedefUnion(String string) {
        super();
        this.string = string;
    }

    public Integer getInt32() {
        return int32;
    }
    
    public String getString() {
        return string;
    }
}
    </source>    
    </td>
    <td>
    <source lang="java">
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((int32 == null) ? 0 : int32.hashCode());
    result = prime * result + ((string == null) ? 0 : string.hashCode());
    return result;
}

@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    TypedefUnion other = (TypedefUnion) obj;
    if (int32 == null) {
        if (other.int32 != null) {
            return false;
        }
    } else if(!int32.equals(other.int32)) {
        return false;
    }
    if (string == null) {
        if (other.string != null) {
            return false;
        }
    } else if(!string.equals(other.string)) {
        return false;
    }
    return true;
}

@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("TypedefUnion [int32=");
    builder.append(int32);
    builder.append(", string=");
    builder.append(string);
    builder.append("]");
    return builder.toString();
}
    </source>    
    </td>
    
</tr>
</table>

=== String mapping ===
YANG String can be detailed specified through type's subelements <code>length</code> and <code>pattern</code> which are mapped as follows:<br />
{| class="wikitable"
|-
! Type's subelement !! Mapping to JAVA
|-
| <code>length</code> || isn't mapped
|-
| <code>pattern</code> || 
* list of string constants = list of patterns
* list of Pattern objects
* static initialization block where list of Patterns is initialized from list of string of constants
|}
Example of YANG string mapping
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>    
    <th>JAVA overriden Object methods</th>    
</tr>
<tr>
    <td>
    <source>
typedef typedef-string {
    type string {
        length 44;
        pattern "[a][.]*"
    }
} 
    </source>
    </td>
    <td>
    <source lang="java">
public class TypedefString {

    private static final List<Pattern> patterns = new ArrayList<Pattern>();
    public static final List<String> PATTERN_CONSTANTS = Arrays.asList("[a][.]*");
    
    static {
        for (String regEx : PATTERN_CONSTANTS) {
            patterns.add(Pattern.compile(regEx));
        }
    }

    private String typedefString;

    public TypedefString(String typedefString) {
        super();
        this.typedefString = typedefString;
    }

    public String getTypedefString() {
        return typedefString;
    }
}
    </source>    
    </td>
    <td>
    <source>    
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((typedefString == null) ? 0 : typedefString.hashCode());
    return result;
}

@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    TypedefString other = (TypedefString) obj;
    if (typedefString == null) {
        if (other.typedefString != null) {
            return false;
        }
    } else if(!typedefString.equals(other.typedefString)) {
        return false;
    }
    return true;
}

@Override
public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append("TypedefString [typedefString=");
    builder.append(typedefString);
    builder.append("]");
    return builder.toString();
}
    </source>    
    </td>
</tr>
</table>


== Container ==
YANG Container is mapped to JAVA interface which extends interfaces <code>DataObject, Augmentable<<font color="red">container_interface</font color>></code>, where <font color="red">container_interface</font color> is name of mapped interface.<br />
Example of mapping:<br />
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
    <td>
    <source>
container cont {
}
    </source>
    </td>
    <td>
    <source lang="java">
public interface Cont extends DataObject, Augmentable<Cont> {
}
    </source>    
    </td>
    <td>
</tr>
</table>

== Leaf ==
<!-------------------- LEAF ------------------------->
Each <code>leaf</code> has to contain at least one <code>type</code> substatement. The <code>leaf</code> is mapped to getter method of superior element with return type equal to <code>type</code> substatement value.<br />
''Example of leaf mapping at model level:<br />''
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
    <td>
    <source>
module module {
    
    namespace "urn:module";
    prefix "sbd";

    organization "OPEN DAYLIGHT";
    contact "http://www.whatever.com/";    

    revision 2013-07-09 {
        
    }
    leaf lf {
        type string;				
    }     
}
    </source>
    </td>
    <td>
    <source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379;
public interface ModuleData {
    String getLf();
}
    </source>    
    </td>
</tr>
</table>
''Example of leaf mapping at container level:<br />''
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
    <td>
    <source>
container cont {
  leaf lf {
    type string;				
  }
}
    </source>
    </td>
    <td>
    <source lang="java">
public interface Cont extends DataObject, Augmentable<Cont> {
    String getLf();
}
    </source>    
    </td>
</tr>
</table>

== Leaf-list ==
<!-------------------- LEAF-LIST ------------------------->
Each <code>leaf-list</code> has to contain one type substatement. The <code>leaf-list</code> is mapped to getter method of superior element with return type equal to <code>List</code> of <code>type</code> substatement value.<br />
''Example of mapping of <code>leaf-list</code>.''<br />
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
    <td>
    <source>
container cont {
    leaf-list lf-lst {
        type typedef-union;
    }
}
    </source>
    </td>
    <td>
    <source lang="java">
public interface Cont extends DataObject, Augmentable<Cont> {
    List<TypedefUnion> getLfLst();
}
    </source>    
    </td>
</tr>
</table>
''<small>YANG <code>typedef-union</code> and JAVA <code>TypedefUnion</code> are the same as in [[#Union's substatement type|union type]].''</small><br />

== List ==
<!-------------------- LIST ------------------------->
YANG <code>list</code> element is mapped to JAVA interface. In superior element is generated as getter method with return type <code>List</code> of generated interfaces.<br />
''Example of list mapping. '''outter-list''' is mapped to JAVA interface '''OutterList''' and in '''Cont''' interface (superior of '''OutterList''') contains getter method with return type List<'''OutterList'''>  ''
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
    <td>
<source>
container cont {
  list outter-list {
    leaf leaf-in-list {
      type uint64;                
    }
    leaf-list leaf-list-in-list {
      type string;                
    }
    list list-in-list {
      leaf-list inner-leaf-list {
        type int16;
      }
    }
  }
}
</source>
    </td>
    <td>
ListInList.java    
    <source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.outter.list;

import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import java.util.List;

public interface ListInList extends DataObject, Augmentable<ListInList> {

    List<Short> getInnerLeafList();
}
    </source>    
OutterList.java    
    <source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379.cont;


import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import java.util.List;
import org.opendaylight.yang.gen.v1.urn.module.rev201379.outter.list.ListInList;
import java.math.BigInteger;

public interface OutterList extends DataObject, Augmentable<OutterList> {

    List<String> getLeafListInList();
    
    List<ListInList> getListInList();
    
    BigInteger getLeafInList();

}
</source>    
Cont.java
<source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379;


import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import java.util.List;
import org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.OutterList;

public interface Cont extends DataObject, Augmentable<Cont> {

    List<OutterList> getOutterList();

}
</source>
      
    </td>
</tr>
</table>

== Choice and case ==
<!-------------------- CHOICE AND CASE ------------------------->
<code>Choice</code> element is mapped similarly as <code>list</code> element. It means that is mapped to interface (marker interface) and in superior element is created getter method with return type <code>List</code> of this marker interfaces.<br />
<code>Case</code> substatements are mapped to JAVA interfaces which extend mentioned marker interface.<br />
'''Example of choice mapping:'''
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
    <td>
    <source>
container cont {
    choice choice-test {
        case case1 {
        }
        case case2 {
        }
    }
}
    </source>
    </td>
    <td>
Case1.java
    <source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.choice.test;

import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.ChoiceTest;

public interface Case1 extends DataObject, Augmentable<Case1>, ChoiceTest {
}
    </source>    
Case2.java
    <source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.choice.test;

import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.ChoiceTest;

public interface Case2 extends DataObject, Augmentable<Case2>, ChoiceTest {
}
    </source>
ChoiceTest.java
    <source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379.cont;

import org.opendaylight.yangtools.yang.binding.DataObject;

public interface ChoiceTest extends DataObject {
}
    </source>
Cont.java
    <source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import org.opendaylight.yang.gen.v1.urn.module.rev201379.cont.ChoiceTest;

public interface Cont extends DataObject, Augmentable<Cont> {

    ChoiceTest getChoiceTest();

}
    </source>


    </td>
</tr>
</table>

== Grouping and uses ==
<!-------------------- GROUPING AND USES ------------------------->
<code>Grouping</code> is mapped to JAVA interface. <code>Uses</code> used in some element is mapped as extension of interface for this element.<br />
''Example of grouping and uses mapping.''<br />
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
    <td>
    <source>
grouping grp {
    
}

container cont {
    uses grp;
}
    </source>
    </td>
    <td>
Cont.java
    <source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;

public interface Cont extends DataObject, Augmentable<Cont>, Grp {
}
    </source>    
Grp.java
    <source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

import org.opendaylight.yangtools.yang.binding.DataObject;

public interface Grp extends DataObject {
}
    </source>    
    </td>
</tr>
</table>

== Rpc ==
<!-------------------- RPC ------------------------->
<code>Rpc</code> is mapped to JAVA as method of class <code>'''ModuleService.java'''</code>. Rpc's substatement are mapped as follows:
{| class="wikitable"
|-
! Rpc substatement !! mapped to JAVA
|-
| input || interface
|-
| output || interface
|}
''Example of rpc mapping:'' 
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
    <td>
    <source>
rpc rpc-test1 {
    output {
        leaf lf-output {
            type string;
        }
    }
    input {
        leaf lf-input {
            type string;
        }        
    }
}
    </source>
    </td>
    <td>
ModuleService.java
    <source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

import java.util.concurrent.Future;
import org.opendaylight.yangtools.yang.common.RpcResult;

public interface ModuleService {

    Future<RpcResult<RpcTest1Output>> rpcTest1(RpcTest1Input input);

}
    </source>    
RpcTest1Input.java
    <source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

public interface RpcTest1Input {

    String getLfInput();

}
    </source>    
RpcTest1Output.java
    <source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379;

public interface RpcTest1Output {

    String getLfOutput();

}
    </source>    

    </td>
</tr>
</table>

== Notification ==
<!-------------------- NOTIFICATION ------------------------->
<code>Notification</code> is mapped to JAVA interface which extends Notification interface.
''Example of notification mapping:''
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
    <td>
    <source>
	notification notif {
	}
    </source>
    </td>
    <td>
    <source lang="java">
package org.opendaylight.yang.gen.v1.urn.module.rev201379;


import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import org.opendaylight.yangtools.yang.binding.Notification;

public interface Notif extends DataObject, Augmentable<Notif>, Notification {
}
    </source>    
    </td>
</tr>
</table>

== Augment ==
<!-------------------- AUGMENT ------------------------->
== Identity ==
<!-------------------- IDENTITY ------------------------->
The purpose of the identity statement is “to define a new globally unique, abstract, and untyped identity “. YANG substatement base „takes as an argument a string that is the name of existing identity, from which the new identity is derived.1“ Therefore the identity statement is mapped to JAVA abstract class and base substatement is mapped as extends JAVA keyword. The identity name is translated to class name.

<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>    
</tr>
<tr>
    <td>
    <source>
identity toast-type {  
}
    </source>
    </td>
    <td>
ToastType.java
    <source lang="java">
public abstract class ToastType extends BaseIdentity {
    protected ToastType() {
        super();
    }
}
    
    </source>    
    </td>
</tr>
<tr>
    <td>
    <source>
identity white-bread {
  base toast-type;
}
    </source>
    </td>
    <td>
WhiteBread.java
    <source lang="java">
public abstract class WhiteBread extends ToastType {
    protected WhiteBread() {
        super();
    }
}    
    </source>    
    </td>
</tr>
</table>
