{| align="right" border="1"
|align="center"|'''SAL Guide Contents'''
|-
|[[OpenDaylight Controller:Model-Driven Controller Service Abstraction Layer|Model-Driven Controller SAL]]<br>[[OpenDaylight Controller:SAL Infrastructure|SAL:Infrastructure and Interfaces]]<br>[[OpenDaylight Controller: SAL Architecture Overview|SAL:Architecture Overview]]<br>[[OpenDaylight Controller:YANG Schema and Model|SAL:YANG Schema]]<br>[[OpenDaylight Controller:Binding-Independent Data Format|SAL:BI Data Format]]<br>[[OpenDaylight Controller:Binding-Independent Components|SAL:BI Components]]<br>[[OpenDaylight Controller:Binding-Aware SAL|SAL:Binding-Aware SAL]]<br>[[OpenDaylight Controller:Binding Model|SAL:Binding Model]]<br>[[OpenDaylight Controller:Binding Aware Components|SAL:BA Components]]<br>[[OpenDaylight Controller:Example Workflows|SAL:Example Workflows and Diagrams]]<br>[[OpenDaylight Controller:Programmer Guide|Programmer Guide Top Level]]<br>[[OpenDaylight Controller:Main|Top Level Contents]]
|}

==Introduction==
Model-driven approach to service abstraction presents an opportunity to unify both northbound and southbound APIs and the data structures used in various services and components of an SDN Controller.

In order to describe the structure of data provided by controller components a domain-specific language, YANG, is proposed as the modeling language for service and data abstractions. Such language allows to:

* Modeling the structure of XML data and functionality provided by controller components

* Define semantic elements and their relationships

* Model all the components as a single system.

The XML nature of YANG data model presents an opportunity for self-describing data, which controller components and applications using the controller’s northbound APIs can consume in a raw format, along with the data’s schema. 

Utilizing a schema language simplifies development of controller components and application. A developer of a module that provides some functionality (a service, data, functions/procedure) can define a schema and thus create simpler, statically typed APIs for the provided functionality, and thus lower the risk of incorrect interpretation of data structures exposed through the Service Abstraction Layer.

==Scope==
This content defines the architecture of a model-driven Service Abstraction Layer (SAL), binding-independent data formats used in the SAL, and infrastructure components that comprise the SAL.

==Definitions and Acronyms==
* '''Binding''': Java interfaces, classes and contracts generated from a YANG schema describing functionality

* '''Binding-Aware''': A component or functionality which uses a generated Binding for data and APIs

* '''BI, Binding-independent''':  A component or functionality which uses a neutral data DOM format for data and API calls, which is independent of generated Java language bindings.

* '''Binding-independent type identifier''': An identifier for a data structure or an RPC method in a QName-like format[1].

* '''Consumer''': A component (e.g. an application) which uses the model and/or APIs provided (implemented) by another Providers

* '''Data operation''': An operation on top of data  subset describing the state of the system as a whole (configuration, running data).

* '''DTO, Data Transfer Object''': a simple object used to transfer data between Binding-Aware components. DTOs are part of binding.

* '''Infrastructure Component''': A component which is neither a Provider or a Consumer, but exposes or extends the SAL functionality.

* '''Provider''': A component which provides functionality to applications through either model-specific APIs or in a binding-independent format

* '''SAL''': Service Abstraction Layer

* '''NSF''': Network Service Function (e.g. TopologyManager, ForwardingRulesManager)

==Content Structure==
This content is organized into three main parts:

* [[OpenDaylight Controller:SAL Infrastructure|Infrastructure and Infrastructural Components]] 
** [[OpenDaylight Controller: SAL Architecture Overview|Architecture Overview]]
** [[OpenDaylight Controller:YANG Schema and Model|YANG Schema and Model]]
** [[OpenDaylight Controller:Binding-Independent Data Format|Binding-Independent Data Format]]
** [[OpenDaylight Controller:Binding-Independent Components|Binding-Independent Components]]
* [[OpenDaylight Controller:Binding-Aware SAL|Binding-Aware SAL]] - This uses code generated both at development time and at runtime. It comprises the following sections: 
** [[OpenDaylight Controller:Binding Model|Binding Model]] – describes the base concepts of mapping the Binding-Independent format to generated Java binding
** [[OpenDaylight Controller:Binding Aware Components|Binding Aware Components]] – describes the components, which uses the Binding and/or provide the support functionality for Binding.
*[[OpenDaylight Controller:Example Workflows|Example Workflows and Sequence Diagrams]] -  demonstrates how the Controller SAL works.

==Transition Plan==

A discussion of the transition to the MD-SAL in the context of the Hydrogen release can be found in the [[Tech Work Stream:Main#Information From Past Meetings|October 14th Technical Work Stream meeting]]. Also, described in the [[File:MD-SAL-transition.pdf|diagrams]] draw by Colin Dixon after the call and discussed in this [https://lists.opendaylight.org/pipermail/controller-dev/2013-October/001595.html mailing list thread]. The steps are also described here:

=== Status and Timeline Summary ===
The details of the plan are in the pictures below, this captures the status and timeline

{| class="wikitable"
|-
! Step # !! Name  !! Status  !! Plan
|-
| 1 || AD-SAL only || Done || Done
|-
| 2 || Adapt AD-SAL SB APIs to MD-SAL || Done || (see [https://git.opendaylight.org/gerrit/gitweb?p=controller.git;a=tree;f=opendaylight/md-sal/sal-compability;h=c55cbb1d57860c0f25b4299d90005fff71a40cde;hb=HEAD opendaylight/md-sal/sal-compability] )
|-
| 3 || Adapt AD-SAL NSF interfaces to MD-SAL || Done || [https://git.opendaylight.org/gerrit/gitweb?p=controller.git;a=tree;f=opendaylight/md-sal/compatibility/flow-management-compatibility;h=d571655577d9f4c4b0b213b23fc493f8175b913a;hb=HEAD FRM], [https://git.opendaylight.org/gerrit/gitweb?p=controller.git;a=tree;f=opendaylight/md-sal/compatibility/inventory-topology-compatibility;h=e6fe88b061eb01fcb470895a4190bbd9733552b3;hb=HEAD SwitchManager, TopologyManager]
|-
| 4 || Port AD-SAL NSFs to the MD-SAL || || [https://git.opendaylight.org/gerrit/gitweb?p=controller.git;a=tree;f=opendaylight/md-sal/inventory-manager;h=a1bd2a7de6ef2baf630de4a4d6959edd06081715;hb=HEAD Inventory]: Done <br /> Topology: Nov 8 <br /> FRM: Nov 11 <br /> Statistics Manager is an App <br /> HostTracker is an App <br /> Troubleshooting Manager is an App
|-
| 5 || All AD-SAL NSFs transitioned (Final Intended State for Hydrogen) ||  || Nov 11
|}

=== Step 1: Initial State AD-SAL only ===

[[File:MD-SAL-transition-1.png|border]]

Step 1: AD-SAL only

=== Step 2: Adapt AD-SAL SB APIs to MD-SAL ===

[[File:MD-SAL-transition-2.png|border]]

Step 2: Adapt AD-SAL SB APIs to MD-SAL.  (see [https://git.opendaylight.org/gerrit/gitweb?p=controller.git;a=tree;f=opendaylight/md-sal/sal-compability;h=c55cbb1d57860c0f25b4299d90005fff71a40cde;hb=HEAD opendaylight/md-sal/sal-compability] ).  So when a call comes through the AD-SAL that is destined for a SB that is handled by the MD-SAL, it works.

=== Step 3: Adapt AD-SAL NSF interfaces to MD-SAL ===

[[File:MD-SAL-transition-3.png|border]]

Step 3: Adapt AD-SAL NSF interfaces to MD-SAL, so that when a call is made to the MD-SAL NB for a NSF that is still AD-SAL, it works.

=== Step 4:Port AD-SAL NSFs to the MD-SAL ===

[[File:MD-SAL-transition-4.png|border]]

Step 4: One by one AD-SAL NSFs are ported to the MD-SAL with the MD-SAL NSF Adaptor bundle adapting them back to AD-SAL Apps so those apps still work.  NSF by NSF we can choose to 'switch over' just by switching which set of bundles go into the distribution as confidence is gained.

=== Step 5: All AD-SAL NSFs transitioned (Final Intended State for Hydrogen) ===

[[File:MD-SAL-transition-5.png|border]]

Step 5: All AD-SAL NSFs transitioned.  AD-SAL apps continue to work via the AD-SAL NSF Adaptor Bundle.  Remaining AD-SAL SB plugins can use the AD-SAL SB Adaptor.

Because the plan is to have (briefly) source-bundle-level duplication of
the NSFs, this should mean that there's no real need for a branch to do
this development since we're effectively getting the same isolation by
having two copies of the NSF bundles. I would imagine the plan is to do
something analogous for the SB drivers as well, but I haven't illustrated
that here.

==References==
* http://tools.ietf.org/html/rfc6241  - Network Configuration Protocol (NETCONF)
* http://tools.ietf.org/html/rfc6020 -  YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)
* http://datatracker.ietf.org/doc/draft-clemm-netmod-mount - Mounting YANG-Defined Information from Remote Datastores
* http://en.wikipedia.org/wiki/Northbound_interface

[[Category:OpenDaylight Controller]]
