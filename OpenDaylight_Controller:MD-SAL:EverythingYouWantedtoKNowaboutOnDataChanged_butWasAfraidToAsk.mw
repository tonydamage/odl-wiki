

== Introduction ==

I decided to put together a series of live tests due to the difficulties I was having understanding OnDataChanged() events.

I will update this page as my tests progress since I detected many other inconsistencies but did not have time to perform controlled test and capture results in a nice format.

== First round of Tests ==

All test in the first round are based in the module below

==== Module Definition ====
<pre>

module service-function {

  namespace "urn:cisco:params:xml:ns:yang:sfc-sf";

  prefix sfc-sf;

  import ietf-inet-types { prefix inet; }
  import ietf-yang-types { prefix yang; }
  import service-function-type {prefix sfc-sft;}
  import service-locator {prefix sfc-sl;}

  organization "Cisco Systems, Inc.";
  contact "Reinaldo Penno <repenno@cisco.com>";


  description
    "This module contains a collection of YANG definitions for
     managing service function."

  revision 2014-07-01 {
    description
    "Changes based on Opendaylight Testing.";
  }

  container service-functions {
    description
      "Service Function";

    list service-function {
      key "name";
      leaf name {
        type string;
        description
            "The name of the service function.";
      }
      leaf type {
        type string;
        mandatory true;
        description
          "Service Function Type from service-function-type.yang.";
      }
      leaf ip-mgmt-address {
        type inet:ip-address;
      }

      container data-plane-locator {
        uses sfc-sl:data-plane-locator;
      }

      leaf-list service-function-forwarder {
        type string;
        description
          "The service function forwarders associated with this Service Function";
      }
    }
  }
}

</pre>

I register a dataChangeListener at the "list service-function" level as below. '''If you register your listener one level above (container), the results are very different - and that's another source of confusion (at least to me).'''

<pre>

public static final InstanceIdentifier<ServiceFunction>  sfEntryIID =
	InstanceIdentifier.builder(ServiceFunctions.class).child(ServiceFunction.class).build();


final ListenerRegistration<DataChangeListener> sfEntryDataChangeListenerRegistration =
	dataBrokerService.registerDataChangeListener( OpendaylightSfc.sfEntryIID, sfcProviderSfEntryDataListener);

</pre>

=== Creating a single Service Function ===

<pre>

put /config/service-function:service-functions/ 

{
  "service-functions": {
    "service-function": [
      {
        "ip-mgmt-address": "2001::2",
        "type": "firewall",
        "name": "fw-aa",
        "data-plane-locator": {
         "ip": "10.0.0.1",
         "port": "5050"
        }
      }
    ]
  }
} 

2014-07-07 13:28:16.425 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## Start: org.opendaylight.sfc.provider.SfcProviderSfEntryDataListener.onDataChanged(SfcProviderSfEntryDataListener.java:40)
2014-07-07 13:28:16.433 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getOriginalConfigurationData
2014-07-07 13:28:16.434 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationSubtree
2014-07-07 13:28:16.630 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getCreatedConfigurationData
014-07-07 13:28:16.687 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getCreatedConfigurationData firewall  fw-aa
2014-07-07 13:28:16.687 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationData
2014-07-07 13:28:16.687 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationData firewall  fw-aa
2014-07-07 13:28:16.687 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## Stop: org.opendaylight.sfc.provider.SfcProviderSfEntryDataListener.onDataChanged(SfcProviderSfEntryDataListener.java:125)

</pre>

The code that processes the the PUT above can be found below

<pre>

        Map<InstanceIdentifier<?>, DataObject> dataCreatedObject = change.getCreatedConfigurationData();
        LOG.info("\n########## getCreatedConfigurationData");

        for (Map.Entry<InstanceIdentifier<?>, DataObject> entry : dataCreatedObject.entrySet()) {
            if( entry.getValue() instanceof  ServiceFunction) {
                ServiceFunction createdServiceFunction = (ServiceFunction) entry.getValue();
                LOG.info("\n########## getCreatedConfigurationData {}  {}",
                            createdServiceFunction.getType(), createdServiceFunction.getName());
            }
            //System.out.println(entry.getKey() + "/" + entry.getValue());
        }

</pre>

The Map we get back contains two elements that are represented in Yang by containers. [1] is the entire ServiceFunction and [0] is the data plane locator. 

<pre>

dataCreatedObject = {java.util.Collections$UnmodifiableMap@11227} size = 2
[0] = {java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry@11231}"InstanceIdentifier{targetType=interface
org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sf.rev140701.service.functions.service.function.DataPlaneLocator,
path=[org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sf.rev140701.Servi...
[1] = {java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry@11234}"KeyedInstanceIdentifier{targetType=interface
org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sf.rev140701.service.functions.ServiceFunction,
path=[org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sf.rev140701.ServiceFunctions, ...

</pre>

Summary is:

* getCreatedConfigurationData contains service function
* getUpdatedConfigurationData contains service function

'''Some things to notice:'''
 
* Why UpdatedConfigurationData also has service function data? Are they the same or not? 
* Having duplicate information in general is confusing. In my application I want to know which service functions were created and send them to a consumer, but since creation data can be under different APIs I need to check both. This means I might send data to the consumer twice or not catch creation at all when it is only under "Updated" API.

Keep your answers in mind as we go through other tests...

=== Creating another single Service Function. ===

Since it is a PUT operation expectation is a complete overwrite even tough the only difference 
between the first service function and the existing one is the service type.

This means we should get some form of delete plus a create.

<pre>
	put /config/service-function:service-functions/ 

	{
	  "service-functions": {
	    "service-function": [
	      {
	        "ip-mgmt-address": "2001::2",
	        "type": "firewall-1",
	        "name": "fw-aa",
	        "data-plane-locator": {
	         "ip": "10.0.0.1",
	         "port": "5050"
	        }
	      }
	    ]
	  }
	}

The onDataChange code was instrumented to exercise most of the available APIs

2014-07-07 13:30:40.589 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## Start: org.opendaylight.sfc.provider.SfcProviderSfEntryDataListener.onDataChanged(SfcProviderSfEntryDataListener.java:40)
2014-07-07 13:30:40.621 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getOriginalConfigurationData
2014-07-07 13:30:40.628 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getOriginalConfigurationData firewall  fw-aa
2014-07-07 13:30:40.628 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationSubtree
2014-07-07 13:30:40.628 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getCreatedConfigurationData
2014-07-07 13:30:40.630 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationData
2014-07-07 13:30:40.630 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationData firewall-1  fw-aa
2014-07-07 13:30:40.630 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## Stop: org.opendaylight.sfc.provider.SfcProviderSfEntryDataListener.onDataChanged(SfcProviderSfEntryDataListener.java:125)

</pre>

Summary is:

* getOriginalConfigurationData has the old service function
* getUpdatedConfigurationData contains the new service function
* getCreatedConfigurationData is null


'''Some things to notice:'''

* Although a PUT is a create, getCreatedConfigurationData is NULL. This is not consistent with the first test.
* getUpdatedConfigurationData contains the new service function. This is something I did not expect since everything was overwritten. Nothing was "updated".

=== Creating two Service Functions. === 

Since it is a PUT this means a complete overwrite even tough the only difference between the first service 
function and the existing one is the service type.

The second service-function is completely new.

<pre>

	put /config/service-function:service-functions/ 

	{
	  "service-functions": {
	    "service-function": [
	      {
	        "ip-mgmt-address": "2001::2",
	        "type": "firewall-2",
	        "name": "fw-aa",
	        "data-plane-locator": {
	         "ip": "10.0.0.1",
	         "port": "5050"
	        }
	      },
	      {
	        "ip-mgmt-address": "2001::2",
	        "type": "firewall",
	        "name": "fw-cc",
	        "data-plane-locator": {
	         "ip": "10.0.0.1",
	         "port": "5050"
	        }
	      }
	    ]
	  }
	}

2014-07-07 13:44:18.385 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## Start: org.opendaylight.sfc.provider.SfcProviderSfEntryDataListener.onDataChanged(SfcProviderSfEntryDataListener.java:40)
2014-07-07 13:44:18.415 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getOriginalConfigurationData
2014-07-07 13:44:18.418 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getOriginalConfigurationData firewall-1  fw-aa
2014-07-07 13:44:18.418 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationSubtree
2014-07-07 13:44:18.419 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getCreatedConfigurationData
2014-07-07 13:44:18.422 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getCreatedConfigurationData firewall  fw-cc
2014-07-07 13:44:18.423 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationData
2014-07-07 13:44:18.423 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationData firewall-2  fw-aa
2014-07-07 13:44:18.423 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationData firewall  fw-cc
2014-07-07 13:44:18.449 PDT [pool-14-thread-1] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## Stop: org.opendaylight.sfc.provider.SfcProviderSfEntryDataListener.onDataChanged(SfcProviderSfEntryDataListener.java:125)

</pre>

'''Some things to notice:'''

* getUpdatedConfigurationData has the the old service function that was "changed" plus the new service function
* Although a PUT operation is a full delete + create, getCreatedConfigurationData only has the firewall fw-cc
* getUpdatedConfigurationData contains the new service function. This is something I did not expect since everything was overwritten. Nothing was "updated".


=== Deleting a single service function ===

We are deleting fw-aa

<pre>

2014-07-07 13:56:16.035 PDT [http-bio-8080-exec-9] INFO  o.o.c.sal.restconf.impl.BrokerFacade - Delete Configuration via Restconf:
(urn:cisco:params:xml:ns:yang:sfc-sf?revision=2014-07-01)service-functions/(urn:cisco:params:xml:ns:yang:sfc-sf?revision=2014-07-01)service-function[{(urn:cisco:params:xml:ns:yang:sfc-sf?revision=2014-07-01)name=fw-aa}]
2014-07-07 13:56:16.057 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## Start: org.opendaylight.sfc.provider.SfcProviderSfEntryDataListener.onDataChanged(SfcProviderSfEntryDataListener.java:40)
2014-07-07 13:56:16.060 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getCreatedConfigurationData
2014-07-07 13:56:16.064 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getOriginalConfigurationData firewall-2  fw-aa
2014-07-07 13:56:16.082 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationSubtree
2014-07-07 13:56:16.082 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getCreatedConfigurationData
2014-07-07 13:56:16.082 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationData
2014-07-07 13:56:16.082 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## Stop: org.opendaylight.sfc.provider.SfcProviderSfEntryDataListener.onDataChanged(SfcProviderSfEntryDataListener.java:125)

</pre>

This works as expected

'''Adding a single service function with inconsistency between path and JSON name'''

<pre>

put /config/service-function:service-functions/service-function/fw-zz/ 

{
  "service-function": [
    {
      "ip-mgmt-address": "20.0.0.11",
      "type": "firewall",
      "name": "fw-yy"
    }
  ]
}

</pre>

This is the actual Service Function created

<pre>

{
  "service-functions": {
    "service-function": [
      {
        "ip-mgmt-address": "20.0.0.11",
        "name": "fw-yy",
        "type": "firewall"
      }
    }
  }
}

</pre>

'''Some things to notice:'''

* The service function name from the path "fw-zz" was ignored. The actually created service function name was "fw-yy"

* There was no callback. '''OndataChanged() was _never_ called'''. So, which InstanceIdentifier should I construct in order to get a callback when a service function is created with the full path? This seems like a bug https://bugs.opendaylight.org/show_bug.cgi?id=1330

=== Adding a single service function without inconsistencies ===

<pre>

put /config/service-function:service-functions/service-function/fw-bb/ 

{
  "service-function": [
    {
      "ip-mgmt-address": "20.0.0.11",
      "type": "firewall",
      "name": "fw-bb",
      "data-plane-locator": {
        "ip": "10.0.0.1",
	"port": "5050"
      }
    }
  ]
}

osgi> 2014-07-08 00:17:07.529 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## Start: org.opendaylight.sfc.provider.SfcProviderSfEntryDataListener.onDataChanged(SfcProviderSfEntryDataListener.java:55)
2014-07-08 00:17:09.522 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getOriginalConfigurationData
2014-07-08 00:17:12.143 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationSubtree
2014-07-08 00:18:03.811 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getCreatedConfigurationData
2014-07-08 00:18:03.829 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getCreatedConfigurationData firewall  fw-bb
2014-07-08 00:18:03.829 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationData
2014-07-08 00:18:03.832 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## getUpdatedConfigurationData firewall  fw-bb
2014-07-08 00:18:03.832 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfEntryDataListener -
########## Stop: org.opendaylight.sfc.provider.SfcProviderSfEntryDataListener.onDataChanged(SfcProviderSfEntryDataListener.java:140)

</pre>

Summary is:

* getCreatedConfigurationData contains service function
* getUpdatedConfigurationData contains service function

== Second round of Tests ==

Tests in the second round are based in the module below. This module is more elaborate, containing lists of lists and groupings which brings several interesting challenges. '''There is really no point in showing a simple model where everything works flawlessly'''. Real life Yang modules are much more complex than the one below so in order to test our design, we need to use these modules.

It is very important to notice that the listener is attached to the container as below

<pre>

public static final InstanceIdentifier<ServiceFunctionChains>  sfcIID =
  InstanceIdentifier.builder(ServiceFunctionChains.class).build();


final ListenerRegistration<DataChangeListener> sfcDataChangeListenerRegistration =
  dataBrokerService.registerDataChangeListener( OpendaylightSfc.sfcIID, sfcProviderSfcDataListener  );

</pre>

==== Module Definition ====
<pre>

module service-function-chain {

  namespace "urn:cisco:params:xml:ns:yang:sfc-sfc";

  prefix sfc-sfc;

  import ietf-inet-types { prefix inet; }
  import ietf-yang-types { prefix yang; }
  import service-function {prefix sfc-sf; }


  organization "Cisco Systems, Inc.";
  contact "Reinaldo Penno <repenno@cisco.com>";


  description
    "This module contains a collection of YANG definitions for
     managing service function chains.

  revision 2014-07-01 {
    description
    "Revised based on Opendaylight Project feedback";
  }

  grouping service-function-chain-grouping {
    list service-function-chain {
      description
        "A service chain defines the required functions and
        associated order (service-function1 --> service-function 2) that
        must be applied to packets and/or frames.  A service chain does
        not specify the network location or specific instance of service
        functions (e.g. firewall1 vs. firewall2).";
      key "name";
      leaf name {
        type string;
        description
          "the name of the service function chain";
      }
      list sfc-service-function {
        key "name";
        leaf name {
          type string;
          description
            "The name of the service function.";
        }
        leaf type {
          type string;
          mandatory true;
          description
            "Service Function Type from service-function-type.yang.";
        }
        ordered-by user;
        description
          "A list of service functions that compose the service chain";
      }
    }
  }

  // Service Function Chains

  container service-function-chains {
    uses service-function-chain-grouping;
  }

  rpc put-service-function-chains {
    input {
      uses service-function-chain-grouping;
    }
  }
}


</pre>

=== Creating a single Service Chain ===

<pre>

put /config/service-function-chain:service-function-chains/

{
  "service-function-chains ": {
    "service-function-chain": [
      {
        "name": "Chain-1",
        "sfc-service-function" : [
          {
          "name" : "dpi-ut",
          "type" : "dpi"
          },
          {
          "name" : "fw-ca",
          "type" : "firewall"
          }
        ]
      }
    ]
  }
}

2014-07-07 21:19:28.261 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfcDataListener -
########## Start: org.opendaylight.sfc.provider.SfcProviderSfcDataListener.onDataChanged(SfcProviderSfcDataListener.java:43)
2014-07-07 21:19:28.275 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfcDataListener -
########## getUpdatedConfigurationData
2014-07-07 21:19:28.275 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfcDataListener -
########## Updated ServiceFunctionChain name: Chain-1
2014-07-07 21:19:28.276 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfcDataListener -
########## Updated ServiceFunction name: dpi-ut
2014-07-07 21:19:28.276 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfcDataListener -
########## Updated ServiceFunction name: fw-ca
2014-07-07 21:19:28.276 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfcDataListener -
########## getOriginalConfigurationData
2014-07-07 21:19:28.276 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfcDataListener -
########## Stop: org.opendaylight.sfc.provider.SfcProviderSfcDataListener.onDataChanged(SfcProviderSfcDataListener.java:84)

</pre>

Below you find he code used to actually go through all the data so you can do something useful with it. 

<pre>

    @Override
    public void onDataChanged(
            DataChangeEvent<InstanceIdentifier<?>, DataObject> change) {

        Map<InstanceIdentifier<?>, DataObject> dataUpdatedConfigurationObject = change.getUpdatedConfigurationData();
        LOG.info("\n########## getUpdatedConfigurationData");

        for (Map.Entry<InstanceIdentifier<?>, DataObject> entry : dataUpdatedConfigurationObject.entrySet())
        {
            if( entry.getValue() instanceof ServiceFunctionChains) {
                ServiceFunctionChains updatedServiceFunctionChains = (ServiceFunctionChains) entry.getValue();
                List<ServiceFunctionChain>  serviceFunctionChainList = updatedServiceFunctionChains.getServiceFunctionChain();
                for (ServiceFunctionChain serviceFunctionChain : serviceFunctionChainList) {
                    LOG.info("\n########## Updated ServiceFunctionChain name: {}", serviceFunctionChain.getName());
                    List<SfcServiceFunction>  SfcServiceFunctionList = serviceFunctionChain.getSfcServiceFunction();
                    for (SfcServiceFunction sfcServiceFunction : SfcServiceFunctionList) {
                        LOG.info("\n########## Updated ServiceFunction name: {}", sfcServiceFunction.getName());
                    }
                }
            }
            //System.out.println(entry.getKey() + "/" + entry.getValue());
        }

</pre>

=== Creating another Service Function Chain ===

<pre>

put /config/service-function-chain:service-function-chains/service-function-chain/Chain-2/

{
  "service-function-chain": [
    {
      "name": "Chain-2",
      "sfc-service-function" : [
        {
        "name" : "nat44-nv",
        "type" : "napt44"
        },
        {
        "name" : "proxy-or",
        "type" : "proxy"
        }
      ]
    }
  ]
}

osgi> 2014-07-07 21:46:56.655 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfcDataListener -
########## Start: org.opendaylight.sfc.provider.SfcProviderSfcDataListener.onDataChanged(SfcProviderSfcDataListener.java:43)
2014-07-07 21:46:56.680 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfcDataListener -
########## getUpdatedConfigurationData
2014-07-07 21:46:56.680 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfcDataListener -
########## getOriginalConfigurationData
2014-07-07 21:46:56.680 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfcDataListener -
########## getCreatedConfigurationData
2014-07-07 21:46:56.680 PDT [pool-14-thread-2] INFO  o.o.s.p.SfcProviderSfcDataListener -
########## Stop: org.opendaylight.sfc.provider.SfcProviderSfcDataListener.onDataChanged(SfcProviderSfcDataListener.java:104)

</pre>

'''Oops. Something went wrong. getUpdatedConfigurationData, getOriginalConfigurationData nor getCreatedConfigurationData gave me any data!''' 

And the Chain was certainly created

<pre>

{
  "service-function-chains": {
    "service-function-chain": [
      {
        "name": "Chain-1",
        "sfc-service-function": [
          {
            "type": "dpi",
            "name": "dpi-ut"
          },
          {
            "type": "firewall",
            "name": "fw-ca"
          }
        ]
      },
      {
        "name": "Chain-2",
        "sfc-service-function": [
          {
            "type": "napt44",
            "name": "nat44-nv"
          },
          {
            "type": "proxy",
            "name": "proxy-or"
          }
        ]
      }
    ]
  }
}

</pre>

==== Retrying creation of another service Function chain ====

The previous result is certainly bad since in all other tests I got some data from at least one of those two APIs. The question is then how to get access to the Service Function Chain that was added after the first one.

Hummm...Looking around I see that in the first test I get four entries in the map set

<pre>
dataCreatedConfigurationObject = {java.util.Collections$UnmodifiableMap@11537} size = 4
[0] = {java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry@11541}"KeyedInstanceIdentifier{targetType=interface
org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sfc.rev140701.service.function.chain.grouping.service.function.chain
.SfcServiceFunction, path=[org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns...
[1] = {java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry@11542}"KeyedInstanceIdentifier{targetType=interface
org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sfc.rev140701.service.function.chain.grouping.service.function.chain
.SfcServiceFunction, path=[org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns...
[2] = {java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry@11543}"InstanceIdentifier{targetType=interface
org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sfc.rev140701.ServiceFunctionChains,
path=[org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sfc.rev140701.ServiceFunctionChains]}" -> "Serv...
[3] = {java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry@11544}"KeyedInstanceIdentifier{targetType=interface
org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sfc.rev140701.service.function.chain.grouping.ServiceFunctionChain,
path=[org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sfc.rev1407...

</pre>

'''But only one is instanceof ServiceFunctionChains!''' That's the one that tripped my code, all the others are the pieces that together make up [2]. 

We are getting closer now. We will redo the second test and pay close attention to the object types we get in the map set. The capture of such map can be seen below.

<pre>

dataCreatedConfigurationObject = {java.util.Collections$UnmodifiableMap@11667} size = 3
[0] = {java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry@11679}"KeyedInstanceIdentifier{targetType=interface
org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sfc.rev140701.service.function.chain.grouping.service.function.chain
.SfcServiceFunction, path=[org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns...
[1] = {java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry@11680}"KeyedInstanceIdentifier{targetType=interface
org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sfc.rev140701.service.function.chain.grouping.ServiceFunctionChain,
path=[org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sfc.rev1407...
[2] = {java.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry@11681}"KeyedInstanceIdentifier{targetType=interface
org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns.yang.sfc.sfc.rev140701.service.function.chain.grouping.service.function.chain
.SfcServiceFunction, path=[org.opendaylight.yang.gen.v1.urn.cisco.params.xml.ns...

</pre>

It is easy to see now why the code did not work. When I add a ServiceFunctionChain with the full path the code is not tripped since the check is against ServiceFunctionChains (container) and not ServiceFunctionChain (list) .  ''So, although the listener is on the container level the actual objects I get on the map set are below the container level.''

'''Summary: Since the events between ServiceFunctionChains and ServiceFunctionChain are partially overlapping this creates issues. if I check for both container and list level objects on the listener callback certain objects will be processed multiple times, creating multiple messages to possible consumers or inconsistencies. Moreover, what happens if I add a single chain with an entire URL such as 
put /config/service-function-chain:service-function-chains/service-function-chain/{name}/sfc-service-function/{name}/? What kind of events I need to check for and how to make sure I do not double or triple process certain object?''' 

=== Discussion ===

A possible solution would be to attach the listeners to the list level (but see bug [https://bugs.opendaylight.org/show_bug.cgi?id=1329 Entry deserialization failed]) , or maybe to every level that internally is represented by an class. This might or might not work. But the bigger question given complex Yang modules is whether such callback design is appropriate, and if yes, what sort of guidelines need to be in place.
