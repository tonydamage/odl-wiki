=Configuration and Transaction=
The '''Configuration''' operation has three stages. First, a '''Proposed''' configuration is created; its target is to replace the old configuration. Second, the Proposed configuration must be validated before it can be committed. If it passes validation successfully, the Proposed configuration's state will be changed to '''Validated'''. Finally, a Validated configuration can be '''Committed''' and the affected modules can be reconfigured.

In fact, each configuration operation is wrapped in a '''transaction'''. Once a transaction is created, it can be '''configured''', i.e. a user can '''abort''' the transaction during this stage. After the transaction configuration is done, it is committed to the '''validation''' stage. In this stage the validation procedures are invoked. If one or more validations fail, the transaction can be reconfigured. On success, the '''second phase commit''' is invoked. If this commit is successful, the transaction enters the last stage - '''committed'''. After that, the desired modules are reconfigured. If the second phase commit fails, it means that the transaction is '''unhealthy''' - basically, a new configuration instance creation failed, and the application can be in an inconsistent state.

<gallery>
File:Configuration.jpg|Configuration states
File:Transaction.jpg|Transaction states
</gallery>

==Validation==
To secure consistency and safety of new configuration and to avoid conflicts, the configuration validation process is necessary. Usually, validation checks input parameters of a new configuration and mostly verifies module-specific relationships. The validation procedure results in a decision whether the proposed configuration is healthy.

==Dependency Resolver==
Since there can be dependencies between modules, a change of a module's configuration can affect the state of other modules. Therefore, we need to verify whether dependencies on other modules can be resolved. The Dependency Resolver acts similar to dependency injectors - basically, a dependency tree is built.

==APIs and SPIs==
In this section configuration system APIs and SPIs will be briefly described.

===SPIs===
'''Module'''
org.opendaylight.controller.config.spi.Module is common interface for all modules - each module must implement it. Module is designated to hold configuration attributes, validate them and create instance of service based on the attributes. This instance must implement AutoCloseable interface, due to resources clean up. If module was created from already running instance, it contains and old instance of module. Module can implement multiple services. if module depends on other modules, setters need to be annotated with @RequireInterface.

'''Module creation'''
Firstly, module needs to be '''configured''' - set all required attributes. Thereafter module is moved to '''commit''' stage, where validation is performed. If fails - module's attributes can be reconfigured, otherwise new instance is '''created''' or old instance is reconfigured. Module instance is identified by '''ModuleIdentifier''' - consists of factory name and instance name.

'''ModuleFactory'''
org.opendaylight.controller.config.spi.ModuleFactory interface must be implemented by each module factory. Module factory can create new module instance in two ways - from existing module instance or pure new instance. Also can return default modules - useful for populating registry with already existing configuration. Module factory implementation must have globally unique name.

===APIs===
'''ConfigRegistry'''<br />
represents functionality provided by configuration transaction (create, destroy module, validate, abort transaction).

'''ConfigTransactionController'''<br />
represents functionality for manipulating with configuration transactions (begin, commit config ).

'''RuntimeBeanRegistratorAwareConfiBean'''<br />
module implementing this interface will recieve RuntimeBeanRegistrator before getInstance is invoked.

===Runtime APIs===

'''RuntimeBean'''<br />
common interface for all runtime beans.

'''RootRuntimeBeanRegistrator'''<br />
represents functionality for root runtime bean registration, which subsequently allows hierarchical registrations.

'''HierarchicalRuntimeBeanRegistration'''<br />
represents functionality for runtime bean registration and unreregistration from hierarchy.

===JMX APIs===
JMX API is purposed as a transition between Client API and JMX platform.

'''ConfigTransactionControllerMXBean'''<br /> 
extends ConfigTransactionController, executed by Jolokia clients on configuration transaction.

'''ConfigRegistryMXBean'''<br />
represents entry point of configuration management for MXBeans.

===Object names===
Object Name is pattern used in JMX to locate JMX beans. It consists of domain and key properties (at least one key-value pair). Domain is defined as "org.opendaylight.controller". The only mandatory property is "type".

==Use case scenarios==
Few samples of successful and unsuccessful transactions scenarios.
===Successful commit scenario===
# User create transaction calling creteTransaction() method on ConfigRegistry.
# ConfigRegisty create transaction controller and registers the transaction as new bean.
# Runtime configurations are copied to the transaction. User can create modules and set their attributes.
# Configuration transaction is to be committed.
# Validation process is performed.
# After successful validation, second phase commit begins.
# Modules proposed to be destroyed are destroyed - their service instances are closed.
# Runtime beans are set to registrator
# Transaction controller invoke method getInstance on each module
# Transaction is committed and resources are closed or released.

===Validation failure scenario===
Transaction is same as previous case until validation process. 
# If validation fails (i.e. illegal input attributes values or dependency resolver failure), ValidationException is thrown and exposed to user.
# User can decide to reconfigure transaction and commit again or abort current transaction.
# On aborted transaction, TransactionController and JMXRegistrator are properly closed.
# Unregistration event is send to ConfigRegistry.

== Default Module Instances ==
Configuration subsystem provides a way for modules to create default instances. Default instance is an instance of a module, that is created at module's bundle startup (module becomes visible for configuration subsystem e.g. its bundle is activated in OSGi environment). By default, no default instances are produced. 

The default instance does not differ from instances created later in module's lifecycle. The only difference is that the configuration for default instance cannot be provided by the configuration subsystem. Module has to acquire the configuration for these instances on its own and it can be acquired from e.g. environment variables. After the creation of a default instance, it acts as a regular instance and fully participates in the configuration subsystem (it can be reconfigured or deleted in following transactions).

= Configuration Persister =
As a part of the configuration subsystem, purpose of the persister is to save and load a permanent copy of a configuration. The '''Persister''' interface represents basic operations over a storage - persist configuration and load last config, configuration snapshot is represented as string and set of it's capabilities. '''StorageAdapter''' represents an adapter interface to the '''ConfigProvider''' - subset of BundleContext, allowing access to the OSGi framework  system properties. 

== Persister Implementation ==
Configuration persister implementation is part of the Controller Netconf. '''PersisterAggregator''' class is implemenataion of Presister interface. Functionality is delegated to the storage adapters. Storage adapters are low level persisters that do the heavy lifting for this class. Instances of storage adapters can be injected directly via constructor or instantiated from a full name of its class provided in a properties file. There can be many persisters configured and various number of them can be used. 

Example of presisters configuration :

 netconf.config.persister.active=2,3
 # read startup configuration
 netconf.config.persister.1.storageAdapterClass=org.opendaylight.controller.config.persist.storage.directory.xml.XmlDirectoryStorageAdapter
 netconf.config.persister.1.properties.fileStorage=configuration/initial/

 netconf.config.persister.2.storageAdapterClass=org.opendaylight.controller.config.persist.storage.file.FileStorageAdapter
 netconf.config.persister.2.readonly=true
 netconf.config.persister.2.properties.fileStorage=configuration/current/controller.config.1.txt

 netconf.config.persister.3.storageAdapterClass=org.opendaylight.controller.config.persist.storage.file.FileStorageAdapter
 netconf.config.persister.3.properties.fileStorage=configuration/current/controller.config.2.txt
 netconf.config.persister.3.properties.numberOfBackups=3

During server startup ConfigPersisterNotificationHandler requests last snapshot from underlying storages. Each storage can respond by giving snapshot or absent response.The PersisterAggregator#loadLastConfigs() will search for first non-absent response from storages ordered backwards as user specified (first '3', then '2'). When a commit notification is received, '2' will be omitted because readonly flag is set to true, so only '3' will have a chance to persist new configuration. If readonly was false or not specified, both storage adapters would be called in order specified by 'netconf.config.persister' property.

== Persister Notification Handler ==
'''ConfigPersisterNotificationHandler''' class is responsible for listening for netconf notifications containing latest committed configuration. The listener can handle incoming notifications, delegates configuration saving/loading to the persister.

== Storage Adapter Implementations ==

=== File Storage ===
'''FileStorageAdapter''' implements StorageAdapter, provides file based configuration persisting. File path and name is stored as a property and a number of stored backups, expressing count of last configurations to be persisted, too. The implementation can handle persisting input configuration and load last configuration.

=== Directory Storage ===
'''DirectoryStorageAdapter''' retrieves initial configuration from a directory. If multiple files are present, snapshot and
required capabilities will be merged together. Writing to this persister is not supported.

=== XML File Storage ===
'''XmlFileStorageAdapter''' implementation stores configuration in an xml file.

=== XML Directory Storage ===
'''XmlDirectoryStorageAdapter''' retrieves initial configuration from a directory. If multiple files are present, snapshot and
required capabilities will be merged together. Writing to this persister is not supported.

=== No-Operation Storage ===
'''NoOpStorageAdapter''' serves as dummy implementation of the storage adapter.
