

== Clustering Scope for Helium ==

# '''Sharding :''' Distribute data in the datastore into shards such that a subset of shards can be located in any cluster member. Distributed transactions across shards NEED NOT be supported. A transaction on a single shard MUST be supported. The Sharding strategy in helium will be fixed i.e all of a modules data will be in a single shard.
# '''Persistence :''' A shard should be backed by a persistent store so that when a cluster member is restarted the shard can be reconstructed from the persisted data
# '''Replication :''' A shard should be replicated to configurable number ( 2 for Helium) of replicas
# '''Clustering Services:''' A service which provides information about an akka cluster
# '''Monitoring :''' There MUST be logging/monitoring of transactions and data change notifications that would help an app developer tune data access. For example we know that remote-reads could be expensive so we should log reads that took an extra-ordinary amount of time or which is trying to get too much data. Similarly for data change notifications we should log if a registration results in too many notifications or the data delivered by that notification is too much or if delivery is taking too much time.
# '''Remote Rpc :'''  A mechanism to invoke a method on a remote service. 
# '''Remote Notifications :''' A mechanism to notify remote listeners of a notification

== Questions on requirements ==
# What should the data size be?
# What kind of performance is expected? How many data updates/second?

== General Design Principles ==

# The Clustered/Sharded Data Store should be a drop in replacement for the InMemory Data Store
# Reuse the InMemory Data Store to represent a shard because it already takes care of maintaining a tree which contains data for all modules and can therefore be scaled down to deal with data for a single module
# Use Akka for doing operations on remote shards. Akka seems to fit very well with the existing design of md-sal as it is already based on the actor model.
# The sharding strategy should be customizable. ODL should ship with a default sharding strategy (which will be static and pre-determined for a given cluster size, similar to the APIC design; applications will be responsible for determining the sharding of their data). The sharding strategy determines the location of a shard possibly based on the instance identifier of a data object and the collection of the cluster members
# Application/Services reading/writing to the shard should be co-located with the shard to minimize remote transactions as much as possible. Only one application should be the logical owner of a shard. When other applications need that data, they should either utilize the APIs provided by the owner application or subscribe to data change notifications.

==== Problems with Sharding Strategy ====
# Migration of shards based on changes in sharding strategy?
# For Helium - build a REST api to specify the cluster configuration

=== Akka ===

We are going to rely heavily on akka to provide us the building blocks for our clustering solution. The main components of akka that we will use are,

# [http://doc.akka.io/docs/akka/snapshot/java/remoting.html Akka Remoting]
# [http://doc.akka.io/docs/akka/snapshot/java/cluster-usage.html Akka Clustering]
# [http://doc.akka.io/docs/akka/snapshot/java/persistence.html Akka Persistence]

== Design ==

=== Components ===

[[File:High Level Design.png|General Concepts|x600px]]


{| class="wikitable"
|-
! Component Name !! Description
|-
| ClusteringConfiguration || The ClusteringConfiguration represents information about the cluster. The information it provides would be roughly the following,

# What are the member in the cluster?
# Which shards live on each node?
# What data goes in each shard?

|-
| ClusteringService || The ClusteringService would have the following responsibilities

# Read the cluster configuration. Where it reads the cluster configuration from should not matter. Initially we could even read the configuration from the file system. Overtime ofcourse we could have a "primary" node come up with a cluster configuration and distribute it to the other members in the cluster.
# Resolve the node name to actual host name/ip
# Maintain a registration of components that are interested in being notified of member status changes

|-
| DistributedDataStore || The DistributedDataStore would have the following responsibilities

# Implement the DOMDataStore so that we could replace the InMemoryDataStore with the DistributedDataStore
# Create the local shard actors as per the cluster configuration
# Create the listener wrapper actors when a consumer registers a listener. 
|-
| Shard || A Shard would be a '''processor''' which contains some of the data in the system. Since a Shard is an actor you would communicate with it using messages. The messages passed to a shard would for the most part be similar to the operations on the DOMDataStore interface. 

Since the Shard is a '''Processor''' as per akka-persistence it is a special actor which when passed a '''Persistent''' message will log it to a journal. This journal along with snapshots would be used as a method to recover the state of the DataStore. The state of the Shard would be maintained in an InMemoryDataStore object. 

The MD-SAL DataStore supports three phase commit. The Shard will therefore also provide the functions of the ThreePhaseCommitCohort.

|-
| ShardTransaction || A ShardTransaction would be an actor which wraps an InMemoryDataStoreTransaction. Any operation that needs to be done on a transaction - namely ""read"", ""write"", ""delete"" and ""ready"" would be fronted by the ShardTransaction. The ShardTransaction will also maintain the state of any writes/deletes that happen on a transaction. We will call this state the "transactionLog". The transactionLog would then be used during commits to persist a transaction to a journal which will be written onto the disk using akka's persistence module. The journal will then be used when a controller shards up to reconstruct the state of a shard. 

|-
| TransactionProxy || The TransactionProxy will hold a reference to a collection of remote ShardTransaction actor and when returned to the consumer of the DistributedDataStore could be used to invoke the transaction operations on any remote ShardTransaction object depending on the instance identifier of the object.

|-
| ListenerWrapper || The ListenerWrapper is an actor that would represent a local data change listener. It would be created as a remote actor on the node where the Data Change registration is done. 

|-
| ListenerProxy || The ListenerProxy represents a remote data change listener. When the local Shard issues a data change notification it is the ListenerProxy's responsibility to send that data change notification over to the remote ListenerWrapper actor.

|-
| ShardCommitCohort || A ShardCommitCohort would be an actor which wraps he InMemoryDataStoreCommitCohort. Any operation that needs to be done on a three phase commit cohort namely , "canCommit", "preCommit", "commit" and "abort" would be fronted by the ShardCommitCohort

|-
| ThreePhaseCommitCohortProxy || The ThreePhaseCommitCohortProxy holds a reference to a collection of ShardCommitCohorts. It implements the DOMStoreThreePhaseCommitCohort interface and any operation done on the proxy is invoked on every ShardCommitCohort in the collection.

|}

=== Packaging ===

The following osgi bundles should be created,

# MD-SAL InMemoryDataStore Implementation (this needs to be moved out of sal-dom-broker)
# MD-SAL Clustering Service API
# MD-SAL Clustering Service Implementation
# MD-SAL Distributed DataStore

=== Configuration ===

Cluster configuration defines the members of the cluster and what lives within it. This configuration can be static or dynamic. To make things simple we could go with a static configuration for Helium. The configuration could be defined in a file or files which could be put in the ODL distribution. When the ODL controller is started up we would pass the configuration file to it.

When the MD-SAL Clustering Service bundle comes up it could look at which specific configuration needs to be loaded, reads it from disk and initializes itself. 

Clustering configuration would be as follows,

==== modules.conf ====

modules.conf defines all the modules in the system, the shards for those modules and the cluster members on which the replicas of those shards should exist. Which replica would be primary depends on the order of the replica list.

<pre>

modules = [
    {
        name = "inventory"
        shards = [
            {
                name = "shard-1"
                replicas = [
                    "member-2"
                    "member-1"
                    "member-3"
                ]
            }

            {
                name = "shard-2"
                replicas = [
                    "member-1"
                    "member-2"
                    "member-3"
                ]
            }

        ]
    },
    {
        name = "topology"
        shards = [
            {
                name = "module-shard"
                replicas = [
                    "member-2"
                    "member-1"
                    "member-3"
                ]
            }
        ]
    }

]
</pre>

==== module-sharding-strategies.conf ====

The module-sharding-strategies.conf file defines each module and the strategy that needs to be used for that module. 
<pre>

module-sharding-strategies = [
    {
        module-name : "inventory"
        strategy : "module"
    },
    {
        module-name : "topology"
        strategy : "module"
    }

]
</pre>

Now since we are planning to use akka pay special attention to the ""role-name"". The role-name that one uses should correspond to the role-name specified for this node in the akka-cluster configuration. Right now I can see this as a potential area where mistakes could be made as two separate configuration files need to be kept in sync (need to think of a clean solution for this).

=== Discovery ===

ClusteringService will be responsible for Discovery and all related functions. It will depend on [http://doc.akka.io/docs/akka/snapshot/java/cluster-usage.html akka-clustering] to identify the members of the cluster.

When the ClusteringService comes up it first checks for the state of the cluster. It looks up all the members in the cluster and verifies that all the roles defined in the cluster-configuration are fulfilled by the cluster membership. Once all the members with the required roles are up and running the Clustering Service notifies it's listeners that the controller is now open for business.

=== Sharding (and data access) ===

The DistributedDataStore creates a ShardingManager. The ShardingManager looks at the configuration of the cluster and automatically creates all the local shards. The ShardingManager also provides a mechanism to locate the shard to which a message needs to be sent.

Data is sharded at a sub-tree level.  In other words, If a Tree Node belongs to a shard, All the sub-tree nodes will also belong to the same shard.  Sharding strategy will be pluggable at a module level. Default sharding strategy will be to allocate a shard per top level module. It is expected that few modules such as Inventory and Topology will be the heavy hitters on the data store and data may need to be further sharded at a sub-module level.  In those cases, Sharding strategy can specify the path prefix to shard on. When data needs to be read or written to a shard the ShardingManager will pass the module name of the data and the instance identifier of the data to a ShardingStrategy which will then locate the shard on which the data belongs.

[[File:ShardManagement.png]]

==== Creating a new transaction ====

[[File:Create a new transaction.png|1000x800px]]

In the ""current option"" when a consumer tries to create a new transaction on the DistributedDataStore we have create a transaction on some remote Shard(s). Why do we need to create a transaction on multiple Shards? Because if the transaction is created using the current DOMDataStore API at the outset we are not told which "module" we want to do the transaction on. 

There are a few ways in which we could fix this,

# When creating the transaction pass the instance identifier of the object on which you want to do the transaction. I think this is a simple option because it introduces a more restrictive API that forces the consumer to decide the Shard on which she would like to operate.
# We do not create remote transactions up-front. When a CRUD operation is done on the TransactionProxy then the TransactionProxy could first create a transaction on the remote Shard and then only do that operation. Once the transaction is created though we allow it to live till it is committed. This is also workable and the overall behavior may not be much worse than the current option.

==== Read/Write on a transaction ====

[[File:Read on a transaction.png]]


[[File:Write on a transaction.png]]

==== Readying a transaction for commit ====

[[File:Readying a transaction for commit.png]]

==== Committing a transaction ====

We plan to use 3-phase commit semantics for committing transactions. The 3-phase commit protocol works as shown in the following diagram. This would imply that we do guarantee distributed transactions but in-reality we may not be able to. If 3-phase commit is not important or possible then we should probably not even have it on the DOMStore interfaces.

If 3-phase commit is not to be supported we can simply have a commit on the transaction. 

[[File:Three-phase commit diagram.png]]

The coordinator in our case would be the ThreePhaseCommitCohortProxy (shown as ThreePhaseCommitProxy in the following diagram) and the actual cohorts will be the ShardCommitCohort's.

[[File:Committing a transaction.png|1000x800px]]

==== Replication ====

A Shard may have n-number of replicas. When a transaction is persisted the Shard can notify each of it's replica's with a Persistent message. This would result in the replica updating the InMemoryDataStore associated with it and addition of the Persistent message to the journal.

[[File:Replication.png]]


==== Aggregation ====

If data from a single module is put into multiple shards it is possible that a read may require data from multiple shards to be retrieved aggregated and returned to the consumer.

<TBD>

==== Querying ====

With the current DOM-Store the only type read supported is to read a piece of data based on it's identifier. Querying for data based on attributes of the data is not supported. This capability needs to be added to the DOM-Store interfaces and optimized (indexed) for fast access.

Following types of queries will be supported. 

* Query based on instance identifier
* Query based on object class (Extend YANG with the notion of an Object Class?)
* Query based on attribute filters 
* Scoped query based on Object Class
* Scoped query on attribute filters

Data Store will implement B-Tree Indexes to support efficient queries based on attribute filters.  YANG data modelers are in the best position to define the expected query patterns and therefore define the indexes which need to be created. YANG language extensions will be provided to simplify the definition of query indexes.

==== Data Change Notifications ====

===== Registration =====

Data change notifications can be thought of as continuous queries  where the query is specified once and instead of returning the matching data immediately system sends notifications when matching data appear in the data tree. As such,  data change subscriptions can be customized just like the data queries.

Following types of subscriptions will be supported.

* Query based on instance identifier
* Query based on object class (Extend YANG with the notion of an Object Class?)
* Query based on attribute filters
* Scoped query based on Object Class
* Scoped query on attribute filters

Question: Do we need to support the notion of a custom filter where a piece of java code can be supplied by the consumer which will be invoked for every matching node during notification and only those nodes which pass the filter will be returned

[[File:Register a DataChangeListener.png|1000x800px]]

===== Notification =====

[[File:DataChange notification.png]]

==== Data Validation ====

As data is added into the data store there might be a need for application developers to write a validator to verify that the data being written is correct. While Validators and DataCommitHandlers are both invoked during commit there is a difference between the two. The DataCommitHandler is a broker concept whereas the Validator would be a DataStore concept. Validators would be associated with a single shard and remote registrations of Validators would not be allowed. 

<More TBD>

=== Recovery ===

To enable recovery we could use Akka's persistence module. One caveat to using Akka's persistence module is that it is experimental. Only a POC will determine if it is usable for our purposes. If it is not we may need to roll our own but in general the principles would be the same.

Here is what we need to do to enable proper recovery,

# Write a journal where each successful transaction on a given shard is logged
# From time to time write the state of the datastore as a snapshot. The idea of using a snapshot is to enable faster recovery.
# When the controller is restarted first re-construct the state of the local shard from the saved snapshot. Then play the transactions in the transaction journal onto the datastore. When both are complete the Shard is ready for business.

The above can be provided by Akka.

In addition we will also need to ensure that replica being recovered is in sync with the primary replica. One way to ensure this would be for the primary replica to send all "undelivered" messages from it's transaction log to the current replica.

=== Availability ===

High availability will be enabled by,

# Replicating shard data to a configurable number of replicas
# Detecting failure of nodes and switching the primary replica
# Shard priority order will be fixed for one of the secondary replicas to become leader. 

===== Replication =====

After a successful local commit on the primary replica a replication message would be sent to all the secondary replicas. The secondary replicas would write this message into the journal and then commit the message as a transaction on the InMemoryDataStore. A Transaction is not considered to be complete for external purposes until the data is written to the replication journal on at least one replica.

===== Node Failure detection =====

The ClusteringService would be monitoring the state of all the members of a cluster. When it detects node failure it will notifiy it's listeners of the failure of that node. One of it's listeners would be the DistributedDataStore which on receipt of the failure will then send a message to all it's TransactionProxy's informing it of the failure of that node and that failure would be then propagated forward by the TransactionProxy's to the ThreePhaseCommitCohortProxy. If the node failure affects the transaction - that is if the failure is on a node where one of the transactions shard resides then the transaction will be marked as failed and any further action on it will throw an exception. The same applies on the ThreePhaseCommitCohortProxy.

=== Monitoring ===

An Akka cluster can be monitored using a variety of commercial monitoring software like AppDynamics or NewRelic. TypeSafe used to have a product called TypeSafe Console which has been discontinued.

=== Error Handling ===

# What happens to transactions when a node fails ?
# If a single DistributedDataStore transaction involves multiple shards what happens if a transaction on one of the shard fails?

=== Performance Measurement/Tuning ===

==== Concurrency ====

Akka has the concept of a [http://doc.akka.io/docs/akka/snapshot/java/dispatchers.html dispatcher] which is essentially a means for Akka to process messages for an actor. What this really boils down to is what kind of thread model we want to use with our actors. Akka offers a few configurable choices. 
==== Serialization ====

Serializing objects over the wire is going to likely be an expensive operation. We need to figure out which type of serialization works best for us.

== Open Questions/Random Thoughts ==

=== Why can't we use an existing Distributed Data Store instead of rolling our own? ===

# Most distributed DBs do not support transactions. Not even transactions on a single shard. We do intend to support transactions on a given shard.
# Not sure if the current existing DB's could even perform well - they certainly cannot perform as well as our in-memory data store
# External DBs generally do not do data change notifications
# If we used an external DB that would make deployment a little more complicated - we would have to setup ODL and also the external DB - some people like the current deployment simplicity of ODL
# One of the principles that we want to follow is to discourage data reads and promote data delivery (via change notifications) in this model the advantage of fast reads that a high performing external DB like say Mongo would become irrelevant


=== Notes regarding Sharding design ===

The design of sharding should be done carefully based on the queries applications make and noting down that '''it will be painful(migration involved)''' if we want to change the sharding logic later after release.

== Proof of Concept ==

=== Goals ===

* Figure out if Akka can be leveraged for clustering [Done]
* Validate design concepts  [Done]
* Make design choices  [Done]
* Estimate performance characteristics  [Done]

=== Focus Areas ===

* Data Distribution / Sharding
** Determine location of Shard [Done]
** Akka Clustering [Done]
** Akka Remoting [Done]
** Akka Sharding
** Aggregation (Scatter Gather)
* Persistence / Recovery 
** Akka Persistence [Done]
* Replication / High Availability [Done]
* Querying / Indexing
* Serviceability (Monitoring and Diagnosis)
** Akka atmos
* Data Change Notification (Query like Filters)
* Serialization over the wire
** Google Protocol Buffers
** EXI
** BSON
* Data Validators (nothing to do with DataCommitHandlers)
* Fault Tolerance
** Akka Supervision [Done]
* Remote Rpc
** Remote Rpc Registry and update using Gossip [Done]
* Expose an actor using OSGi [Done]

== References ==

[https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Architecture:DOM_DataStore DOM Data Store ]

== Trello ==
* https://trello.com/b/7oW0V2Yl/opendaylight-clustering
