=Example=
For better understanding of configuration subsystem, few examples are provided. They show what are generated java files good for and how configuration works on running OSGi server.

= Logback Configuration Example =
Logback logger configuration is part of the config subsystem. This module allows to change Logback configuration at runtime. Here it will be used as an example to demonstrate YANG to Java code generator and show how configuration transaction works.

== Java code generating ==
Logging configuration YANG module definition can be found in '''config-logging.yang''' file. Code is generated by '''yang-maven-plugin''' and '''yang-jmx-generator-plugin'''. The output java files are located as defined in plugin configuration, where additional configuration parameters can be set. 
Logback module is defined as identity, with base "config:module-type", it does not provide or depend on any service interface.
<source>
identity logback {
    description
        "Actual state of logback configuration.";
    base config:module-type;
    config:java-name-prefix Logback;
}
</source>

Next logback module attributes are defined in "/config:modules/config:module/config:configuration" augment as snippet bellow shows.
<source>
augment "/config:modules/config:module/config:configuration" {
    case logback {
        when "/config:modules/config:module/config:type = 'logback'";

        list console-appenders {

            leaf encoder-pattern {
                type string;
                mandatory true;
            }

            leaf threshold-filter {
                type string;
                default 'ALL';
            }

            leaf name {
                type string;
                mandatory true;
            }
            config:java-name-prefix ConsoleAppenderTO;
        }
         ...
</source>
Now LogbackModule and LogbackModuleFactory can be generated - in fact there will be generated three more java files related to this module. By the augment definition, '''TypeObjects''' are generated too (i.e. ConsoleAppenderTO). They are regular java classes with getters and setters for arguments defined as leaves.
* '''LogbackModuleMXBean''' is interface containing getters and setters for attributes defined in configuration augment.<br />
* '''AbstractLogbackModule''' is abstract java class, which implements Module, RuntimeBeanRegistratorAwareModule and LogbackModuleMXBean. It contains almost all functionality, expect of '''validate''' and '''createInstance''' methods.
* '''AbstractLogbackModuleFactory''' is abstract java class responsible for creating modules instances. It implements ModuleFactory interface.
* '''LogbackModule''' class extends AbstractLogbackModule. It is located on different place (source/main/java) and can be modified by user, so that abstract method is implemented and validate method is overridden.
* '''LogbackModuleFactory''' class extends AbstractLogbackModuleFactory and overrides it's instantiateModule methods.

Next, runtime bean is defined in "/config:modules/config:module/config:state" augment
<source>
augment "/config:modules/config:module/config:state" {
    case logback {
        when "/config:modules/config:module/config:type = 'logback'";

        rpcx:rpc-context-instance "logback-rpc";

        list status {
            config:java-name-prefix StatusTO;

            leaf level {
                type string;
            }

            leaf message {
                type string;
            }

            leaf date {
                type uint32;
            }
        }
    }
}
</source>
Generator plugin creates another bunch of java files.
* '''LogbackRuntimeMXBean''' is interface extending RuntimeBean. It contains getter method for argument defined in augment.
* '''LogbackRuntimeRegistrator''' class serves as registrator for runtime beans.
* '''LogbackRuntimeRegistration''' class serves as registration ticket, instance is returned after registration.

Logback config also defines '''logback-rpc''' with '''reset''' method. It is also defined in state augment, due to context.
<source>
identity logback-rpc;
rpc reset {
    input {
        uses rpcx:rpc-context-ref {
            refine context-instance {
                rpcx:rpc-context-instance logback-rpc;
            }
        }
    }
}
</source>
Reset method is defined in LogbackRuntimeMXBean interface.

== Logback configuration ==
Now try to create configuration on running OSGi server. We will use '''Jolokia''' (http://www.jolokia.org/) as a JMX-HTTP bridge, which listen at http://localhost:8080/controller/nb/v2/jolokia and '''culr''' to request over HTTP.

* Start up controller. Find more here: https://wiki.opendaylight.org/view/OpenDaylight_Controller:Pulling,_Hacking,_and_Pushing_the_Code_from_the_CLI

* Try to request Jolokia:
<source>
curl http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Response should looks like:
<source>
{
    "timestamp": 1382425537,
    "status": 200,
    "request": {
        "type": "version"
    },
    "value": {
        "protocol": "7.0",
        "agent": "1.1.1",
        "info": {
            "product": "equinox",
            "vendor": "Eclipse",
            "version": "3.8.1.v20120830-144521"
        }
    }
}
</source>
We are sure Jolokia is working.

* To configure Logback, first, we need to create configuration transaction. ConfigResgistryModule offers operation beginConfig(), to invoke it:
<source>
curl -X POST -H "Content-Type: application/json" -d 
'{"type":"exec","mbean":"org.opendaylight.controller:type=ConfigRegistry","arguments":[],"operation":"beginConfig"}'
http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Configuration transaction was created, received response:
<source>
{
    "timestamp": 1382429350,
    "status": 200,
    "request": {
        "operation": "beginConfig",
        "mbean": "org.opendaylight.controller:type=ConfigRegistry",
        "type": "exec"
    },
    "value": {
        "objectName": "org.opendaylight.controller:TransactionName=ConfigTransaction-0-1,type=ConfigTransaction"
    }
}
</source>

* Next we need to create module bean to be configured. In created ConfigTransaction call createModule method, module identifier is '''logback''' and name must be '''singleton''' as we want to have only one instance of Logback configuration.
<source>
curl -X POST -H "Content-Type: application/json" 
-d '{"type":"exec","mbean":"org.opendaylight.controller:TransactionName=ConfigTransaction-0-1,type=ConfigTransaction","arguments":["logback","singleton"],"operation":"createModule"}' 
http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
LogbackModule bean was created, see returned response:
<source>
{
    "timestamp": 1382430092,
    "status": 200,
    "request": {
        "operation": "createModule",
        "mbean": "org.opendaylight.controller:TransactionName=ConfigTransaction-0-1,type=ConfigTransaction",
        "arguments": [
            "logback",
            "singleton"
        ],
        "type": "exec"
    },
    "value": {
        "objectName": "org.opendaylight.controller:TransactionName=ConfigTransaction-0-1,instanceName=singleton,moduleFactoryName=logback,type=Module"
    }
}
</source>

*Configuration bean attributes are set to values obtained from loggers configuration, with which the server was started. To see attributes, request:
<source>
curl -X POST -H "Content-Type: application/json" -d '{"type":"read", 
"mbean":"org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-0-1,type=Module,moduleFactoryName=logback"}' 
http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
In response body, value contains all attributes (CompositeData) and it's nested attributes values.

*Now we can commit proposed configuration
<source>
curl -X POST -H "Content-Type: application/json" 
-d '{"type":"exec","mbean":"org.opendaylight.controller:type=ConfigRegistry","arguments":
["org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-
0-1,type=Module,moduleFactoryName=logback"],"operation":"commitConfig"}' 
http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Configuration was successfully validated and committed and module instance created.
<source>
{
    "timestamp": 1382442419,
    "status": 200,
    "request": {
        "operation": "commitConfig",
        "mbean": "org.opendaylight.controller:type=ConfigRegistry",
        "arguments": [
            "org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-0-1,type=Module,moduleFactoryName=logback"
        ],
        "type": "exec"
    },
    "value": {
        "newInstances": [
            {
                "objectName": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=Module"
            }
        ],
        "reusedInstances": [],
        "recreatedInstances": []
    }
}
</source>

* Runtime bean was registered and can provide status information of configuration and rpc operation '''reset'''. To see status, try it by requesting:
<source>
curl -X POST -H "Content-Type: application/json" -d '{"type":"read","mbean":"org.opendaylight.controller:instanceName=singleton,type=RuntimeBean,moduleFactoryName=logback"}' 
http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Whole logback status is in response body.

*To invoke rpc method '''reset''':
<source>
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec", 
"mbean":"org.opendaylight.controller:instanceName=singleton,type=RuntimeBean,moduleFactoryName=logback", 
"operation":"reset","arguments":[]}' 
http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Now if look at the runtime bean status attribute, it will be empty:
<source>
{
    "timestamp": 1382443911,
    "status": 200,
    "request": {
        "mbean": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=RuntimeBean",
        "type": "read"
    },
    "value": {
        "Status": []
    }
}
</source>

= Sample maven project =
In this example, we will create a maven project that will provide 2 modules each implementing one service. We will design a simple configuration as well as runtime data for each module using yang. <br />
For this demo, we created a sample maven project called config-demo. This project contains 2 Java interfaces: Foo and Bar with one default implementation per interface: FooImpl and BarImpl. Bar is the producer in our example and produces integers when method getNextEvent() is called. Foo is the consumer and its implementation depends on a Bar instance. Both implementations require some configuration that is injected via constructors. <br/> 
* Bar.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public interface Bar {

    int getNextEvent();

}
</source>
* BarImpl.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public class BarImpl implements Bar {

    private final int l1, l2;
    private final boolean b;

    public BarImpl(int l1, int l2, boolean b) {
        this.l1 = l1;
        this.currentL = l1;
        this.l2 = l2;
        this.b = b;
    }

    private int currentL;

    @Override
    public int getNextEvent() {
        if(currentL==l2)
            return -1;
        return currentL++;
    }
}
</source>

* Foo.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public interface Foo {

    int getEventCount();
}
</source>
* FooImpl.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public class FooImpl implements Foo {

    private final String strAttribute;
    private final Bar barDependency;
    private final int intAttribute;

    public FooImpl(String strAttribute, int intAttribute, Bar barDependency) {
        this.strAttribute = strAttribute;
        this.barDependency = barDependency;
        this.intAttribute = intAttribute;
    }

    @Override
    public int getEventCount() {
        int count = 0;
        while(barDependency.getNextEvent() != intAttribute) {
            count++;
        }
        return count;
    }
}
</source>
* pom.xml (config-demo project is defined as a sub-module of the controller project and at this point contains only configuration for maven-bundle-plugin):
<source lang='xml'>
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <artifactId>commons.opendaylight</artifactId>
        <groupId>org.opendaylight.controller</groupId>
        <version>1.4.1-SNAPSHOT</version>
        <relativePath>../commons/opendaylight/pom.xml</relativePath>
    </parent>
    <groupId>org.opendaylight.controller</groupId>
    <version>0.2.1-SNAPSHOT</version>
    <artifactId>config-demo</artifactId>
    <packaging>bundle</packaging>
    <name>${project.artifactId}</name>
    <prerequisites>
        <maven>3.0.4</maven>
    </prerequisites>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.felix</groupId>
                <artifactId>maven-bundle-plugin</artifactId>
                <version>2.3.7</version>
                <extensions>true</extensions>
                <configuration>
                    <instructions>
                        <Bundle-Name>${project.groupId}.${project.artifactId}</Bundle-Name>
                        <Export-Package>
                            org.opendaylight.controller.config.demo,
                        </Export-Package>
                    </instructions>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
</source>
== Describing module configuration using yang ==
In order to fully leverage the utilities of configuration subsystem, we need to describe services, modules, their configuration and runtime state using yang modeling language. We will define 2 services and 2 modules, which will be used to configure instances of FooImpl and BarImpl. This definition will be split into 2 yang files: config-demo.yang (service definition) and config-demo-impl.yang (module definition).
* config-demo.yang
<source>
module config-demo {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:demo";
    prefix "demo";

    import config { prefix config; revision-date 2013-04-05; }

    description
        "Service definition for config-demo";

    revision "2013-10-14" {
        description
            "Initial revision";
    }

    // Service definition for service foo that encapsulates instances of org.opendaylight.controller.config.demo.Foo
    identity foo {
        description
            "Foo service definition";

        base "config:service-type";
        config:java-class "org.opendaylight.controller.config.demo.Foo";
    }

    identity bar {
        description
            "Bar service definition";

        base "config:service-type";
        config:java-class "org.opendaylight.controller.config.demo.Bar";
    }
}
</source>
As you can see, the config yang module needs to be imported in order to define services. There are 2 services defined and these services correspond to Java interfaces Foo and Bar (specified by config:java-class extension).
* config-demo-impl.yang
<source>
module config-demo-impl {

    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:demo:impl";
    prefix "demo-impl";

    // Dependency on service definition for config-demo
    /* Service definitions could be also located in this yang file or even
     * in a separate maven project that is marked as maven dependency
     */
    import config-demo { prefix demo; revision-date 2013-10-14;}

    // Dependencies on config subsystem definition
    import config { prefix config; revision-date 2013-04-05; }
    import rpc-context { prefix rpcx; revision-date 2013-06-17; }


    description
        "Service implementation for config-demo";

    revision "2013-10-14" {
        description
            "Initial revision";
    }
                                                                      //----- module foo-impl ----- //
    // Module implementing foo service                                                              //
    identity foo-impl {                                                                             //
        base config:module-type;                                                                    //
        config:provided-service demo:foo;                                                           //
        config:java-name-prefix FooImpl;                                                            //
    }                                                                                               //
                                                                                                    //
    // Configuration for foo-impl module                                                            //
    augment "/config:modules/config:module/config:configuration" {                                  //
        case foo-impl {                                                                             //
            when "/config:modules/config:module/config:type = 'foo-impl'";                          //
                                                                                                    //
            leaf str-attribute {                                                                    //
                type string;                                                                        //
            }                                                                                       //
                                                                                                    //
            leaf int-attribute {                                                                    //
                type int32;                                                                         //
            }                                                                                       //
                                                                                                    //
                                                                                                    //
            // Dependency on bar service instance                                                   //
            container bar-dependency {                                                              //
                uses config:service-ref {                                                           //
                    refine type {                                                                   //
                        mandatory true;                                                             //
                        config:required-identity demo:bar;                                          //
                    }                                                                               //
                }                                                                                   //
            }                                                                                       //
                                                                                                    //
        }                                                                                           //
    }                                                                                               //
                                                                                                    //
    // Runtime state definition for foo-impl module                                                 //
    augment "/config:modules/config:module/config:state" {                                          //
        case foo-impl {                                                                             //
            when "/config:modules/config:module/config:type = 'foo-impl'";                          //
                                                                                                    //
                                                                                                    //
        }                                                                                           //
    }                                                                                               //
                                                                                      // ---------- //
    // Module implementing bar service
    identity bar-impl {
        base config:module-type;
        config:provided-service demo:foo;
        config:java-name-prefix BarImpl;
    }

    augment "/config:modules/config:module/config:configuration" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

            container dto-attribute {
                leaf int-attribute {
                    type int32;
                }

                leaf int-attribute2 {
                    type int32;
                }

                leaf bool-attribute {
                    type boolean;
                }
            }

        }
    }

    augment "/config:modules/config:module/config:state" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

        }
    }

}
</source>
Again, config yang module as well as config-demo yang module need to be imported. There are 2 modules defined: foo-impl and bar-impl and their configuration (defined in augment "/config:modules/config:module/config:configuration" block) corresponds to the configuration of FooImpl and BarImpl Java classes. If we take a look at FooImpl.java's constructor, we can see that the configuration of foo-impl module defines similar 3 attributes. We will use these arguments to instantiate the FooImpl class. We placed these yang files under src/main/yang folder. </br>

== Updating maven configuration in pom.xml ==
Now we need to add yang-maven-plugin to our pom.xml. This plugin will process yang files and generate configuration code for the defined modules. Plugin's configuration:
<source lang='xml'>
<plugin>
<plugin>
    <groupId>org.opendaylight.yangtools</groupId>
    <artifactId>yang-maven-plugin</artifactId>
    <version>0.5.8</version>
    <executions>
        <execution>
            <goals>
                <goal>generate-sources</goal>
            </goals>
            <configuration>
                <codeGenerators>
                    <generator>
                        <codeGeneratorClass>
                            org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
                        </codeGeneratorClass>
                        <outputBaseDir>${project.build.directory}/generated-sources/config</outputBaseDir>
                        <additionalConfiguration>
                            <namespaceToPackage1>
                                urn:opendaylight:params:xml:ns:yang:controller==org.opendaylight.controller.config.yang
                            </namespaceToPackage1>
                        </additionalConfiguration>
                    </generator>
                </codeGenerators>
                <inspectDependencies>true</inspectDependencies>
            </configuration>
        </execution>
    </executions>
    <dependencies>
        <dependency>
            <groupId>org.opendaylight.controller</groupId>
            <artifactId>yang-jmx-generator-plugin</artifactId>
            <version>0.2.1-SNAPSHOT</version>
        </dependency>
    </dependencies>
</plugin>
</source>
Important configuration for the plugin is: output folder for generated files and mapping between yang namespaces and java packages (Inspect dependencies must be set to true ). The default location for yang files is under src/main/yang folder. This plugin is backed by artifact yang-jmx-generator-plugin and its class org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator is responsible for the code generation. This artifact is part of the configuration subsystem. <br/>

In addition to yang-maven-plugin, it is neccessary to add build-helper-maven-plugin in order to add generated sources to the build process:

 <plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>build-helper-maven-plugin</artifactId>
    <version>1.8</version>
    <executions>
        <execution>
            <id>add-source</id>
            <phase>generate-sources</phase>
            <goals>
                <goal>add-source</goal>
            </goals>
            <configuration>
                <sources>
                   &lt;source>${project.build.directory}/generated-sources/config&lt;/source>;
                </sources>
            </configuration>
        </execution>
    </executions>
 </plugin>

Earlier, we imported config yang module in our yang files. In order to acquire this yang module, we need to add dependency to the pom file:
<source lang='xml'>
<dependency>
    <groupId>org.opendaylight.controller</groupId>
    <artifactId>config-api</artifactId>
    <version>0.2.1-SNAPSHOT</version>
</dependency>
</source>

We are ready to run '''mvn clean install'''.

== Generated java files ==
Now we can see a bunch of new source files divided into 2 groups. First group is located under ${project.build.directory}/generated-sources/config directory, which we specified in yang-maven-plugin's configuration. The second group is located under src/main/java directory. Both groups then define package org.opendaylight.controller.config.yang.config.demo.impl. The first group contains code that should not be edited in any way, since this code can be regenerated by the plugin if necessary. The code that needs to be edited belongs to the second group and is located under src/main/java. <br/>

=== Generated config source files examples ===
* BarImplModuleMXBean.java
<source lang='java'>
public interface BarImplModuleMXBean
{
    public org.opendaylight.controller.config.yang.config.demo.impl.DtoAttribute getDtoAttribute();

    public void setDtoAttribute(org.opendaylight.controller.config.yang.config.demo.impl.DtoAttribute dtoAttribute);

}
</source>
BarImplModuleMXBean interface represents getter and setter for dtoAttribute that will be exported to configuration registry via JMX. Attribute was defined in yang model - in this case it is composite type which was converted to OpenType.
*Attribute definition from config-demo-impl.yang
<source lang='java'>
    
    // Module implementing bar service
    identity bar-impl {
        base config:module-type;
        config:provided-service demo:foo;
        config:java-name-prefix BarImpl;
    }

    augment "/config:modules/config:module/config:configuration" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

            container dto-attribute {
                leaf int-attribute {
                    type int32;
                }

                leaf int-attribute2 {
                    type int32;
                }

                leaf bool-attribute {
                    type boolean;
                }
            }

        }
    }
</source>
From container dto-attribute, DtoAttribute java file was generated. Class contains plain constructor, getters and setters for attributes defined as container leaves.<br />
Not only ModuleMXBean is generated from this module definition, but also BarImplModuleFactory and BarImplModule stubs are generated (in fact AbstractBarImplModuleFactory and AbstractBarImplModule are generated too).

* AbstractBarImplModule.java
This abstract class is almost fully generated, only method validate() has empty body and method createInstance() is abstract. Both methods must be implemented by user, we will show it later. AbstractBarImplModule implements it's ModuleMXBean, Module, RuntimeBeanRegistratorAwareModule and dependent service interface as defined in yang. Moreover class contains two types of constructors - one for module created from old module instance and the second for module creation from scratch.

* AbstractBarImplModuleFactory.java
Unlike AbstractModule, AbstractFactory is fully generated, but still abstract class. The factory is responsible for module instances creation, provides two type of instantiateModule methods for both module constructor types. It implements ModuleFactory interface.

Next we will create runtime bean for FooImplModule. Runtime beans are designated to capture data about running module.
* Add runtime bean definition to config-demo-impl.yang
<source lang='java'>

</source>

=== Modifying generated sources ===
Generated source files:
* src/main/java/BarImplModule
* src/main/java/BarImplModuleFactory
* src/main/java/FooImplModule
* src/main/java/FooImplModuleFactory

'''BarImplModule'''<br />
We will start by modifying BarImplModule. You can see 2 constructors (not interesting at all) and 2 generated methods:
<source lang='java'>
    @Override
    public void validate(){
        super.validate();
        // Add custom validation for module attributes here.
    }

    @Override
    public java.lang.AutoCloseable createInstance() {
        //TODO:implement
        throw new java.lang.UnsupportedOperationException("Unimplemented stub method");
    }
</source>

In '''validate''', you can specify and validation for config attributes e.g.:
<source lang='java'>
    @Override
    public void validate(){
        super.validate();  
        Preconditions.checkNotNull(getDtoAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getBoolAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getIntAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getIntAttribute2());
        Preconditions.checkState(getDtoAttribute().getIntAttribute() > 55);
        Preconditions.checkState(getDtoAttribute().getIntAttribute() > getDtoAttribute().getIntAttribute2());
    }
</source>

and in '''createInstance''' you need to create new instance of the bar service => Bar interface e.g.:
<source lang='java'>
        @Override
    public java.lang.AutoCloseable createInstance() {
        return new BarImpl(getDtoAttribute().getIntAttribute(), getDtoAttribute().getIntAttribute2(), getDtoAttribute()
                .getBoolAttribute());
    }
</source>
A few notes: 
* createInstance returns AutoCloseable so the returned type needs to implement it (you can make BarImpl implement AutoCloseable or create a Wrapper class around BarImpl instance that implements AutoCloseable or even extend BarImpl class and make it implement it),
* you can access all configuration attributes via getter methods, 
* in config-demo-impl.yang, we defined bar-impl's configuration as a container dto-attribute and the code generator create a transfer object DtoAttribute that you can access via getDtoAttribute() method and retrieve configuration data from it. You can even add new constructor to BarImpl that takes this transfer object and reduce the amount of arguments.

'''FooImplModule'''<br />
We will not add any custom validation in this module.
The '''createInstance''' method will look like:
<source lang='java'>
    @Override
    public java.lang.AutoCloseable createInstance() {
        return new FooImpl(getStrAttribute(), getIntAttribute(), getBarDependencyDependency());
    }
</source>
