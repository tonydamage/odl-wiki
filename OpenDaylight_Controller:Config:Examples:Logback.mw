=Example=
For better understanding of configuration subsystem, few examples are provided. They show what are generated java files good for and how configuration works on running OSGi server.

= Logback Configuration Example =
Logback logger configuration is part of the config subsystem. This module allows to change Logback configuration at runtime. Here it will be used as an example to demonstrate YANG to Java code generator and show how configuration transaction works.

== Java code generating ==
Logging configuration YANG module definition can be found in '''config-logging.yang''' file. Code is generated by '''yang-maven-plugin''' and '''yang-jmx-generator-plugin'''. The output java files are located as defined in plugin configuration, where additional configuration parameters can be set. 
Logback module is defined as identity, with base "config:module-type", it does not provide or depend on any service interface.
<source>
identity logback {
    description
        "Actual state of logback configuration.";
    base config:module-type;
    config:java-name-prefix Logback;
}
</source>

Next logback module attributes are defined in "/config:modules/config:module/config:configuration" augment as snippet bellow shows.
<source>
augment "/config:modules/config:module/config:configuration" {
    case logback {
        when "/config:modules/config:module/config:type = 'logback'";

        list console-appenders {

            leaf encoder-pattern {
                type string;
                mandatory true;
            }

            leaf threshold-filter {
                type string;
                default 'ALL';
            }

            leaf name {
                type string;
                mandatory true;
            }
            config:java-name-prefix ConsoleAppenderTO;
        }
         ...
</source>
Now LogbackModule and LogbackModuleFactory can be generated - in fact there will be generated three more java files related to this module. By the augment definition, '''TypeObjects''' are generated too (i.e. ConsoleAppenderTO). They are regular java classes with getters and setters for arguments defined as leaves.
* '''LogbackModuleMXBean''' is interface containing getters and setters for attributes defined in configuration augment.<br />
* '''AbstractLogbackModule''' is abstract java class, which implements Module, RuntimeBeanRegistratorAwareModule and LogbackModuleMXBean. It contains almost all functionality, expect of '''validate''' and '''createInstance''' methods.
* '''AbstractLogbackModuleFactory''' is abstract java class responsible for creating modules instances. It implements ModuleFactory interface.
* '''LogbackModule''' class extends AbstractLogbackModule. It is located on different place (source/main/java) and can be modified by user, so that abstract method is implemented and validate method is overridden.
* '''LogbackModuleFactory''' class extends AbstractLogbackModuleFactory and overrides it's instantiateModule methods.

Next, runtime bean is defined in "/config:modules/config:module/config:state" augment
<source>
augment "/config:modules/config:module/config:state" {
    case logback {
        when "/config:modules/config:module/config:type = 'logback'";

        rpcx:rpc-context-instance "logback-rpc";

        list status {
            config:java-name-prefix StatusTO;

            leaf level {
                type string;
            }

            leaf message {
                type string;
            }

            leaf date {
                type uint32;
            }
        }
    }
}
</source>
Generator plugin creates another bunch of java files.
* '''LogbackRuntimeMXBean''' is interface extending RuntimeBean. It contains getter method for argument defined in augment.
* '''LogbackRuntimeRegistrator''' class serves as registrator for runtime beans.
* '''LogbackRuntimeRegistration''' class serves as registration ticket, instance is returned after registration.

Logback config also defines '''logback-rpc''' with '''reset''' method. It is also defined in state augment, due to context.
<source>
identity logback-rpc;
rpc reset {
    input {
        uses rpcx:rpc-context-ref {
            refine context-instance {
                rpcx:rpc-context-instance logback-rpc;
            }
        }
    }
}
</source>
Reset method is defined in LogbackRuntimeMXBean interface.

== Logback configuration - Jolokia ==
Now try to create configuration on running OSGi server. We will use '''Jolokia''' (http://www.jolokia.org/) as a JMX-HTTP bridge, which listen at http://localhost:8080/controller/nb/v2/jolokia and '''culr''' to request over HTTP.

* Start up controller. Find more here: https://wiki.opendaylight.org/view/OpenDaylight_Controller:Pulling,_Hacking,_and_Pushing_the_Code_from_the_CLI

* Try to request Jolokia:
<source>
curl http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Response should looks like:
<source>
{
    "timestamp": 1382425537,
    "status": 200,
    "request": {
        "type": "version"
    },
    "value": {
        "protocol": "7.0",
        "agent": "1.1.1",
        "info": {
            "product": "equinox",
            "vendor": "Eclipse",
            "version": "3.8.1.v20120830-144521"
        }
    }
}
</source>
We are sure Jolokia is working.

* To configure Logback, first, we need to create configuration transaction. ConfigResgistryModule offers operation beginConfig(), to invoke it:
<source enclose="div">
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec","mbean":"org.opendaylight.controller:type=ConfigRegistry","arguments":[],"operation":"beginConfig"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Configuration transaction was created, received response:
<source>
{
    "timestamp": 1383034210,
    "status": 200,
    "request": {
        "operation": "beginConfig",
        "mbean": "org.opendaylight.controller:type=ConfigRegistry",
        "type": "exec"
    },
    "value": {
        "objectName": "org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,type=ConfigTransaction"
    }
}
</source>

* At this stage transaction can be aborted, but we want to create module bean to be configured. In created ConfigTransaction call createModule method, module identifier is '''logback''' and name must be '''singleton''' as we want to have only one instance of Logback configuration.
<source enclose="div">
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec","mbean":"org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,type=ConfigTransaction","arguments":["logback","singleton"],"operation":"createModule"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
LogbackModule bean was created, see returned response:
<source>
{
    "timestamp": 1383034580,
    "status": 200,
    "request": {
        "operation": "createModule",
        "mbean": "org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,type=ConfigTransaction",
        "arguments": [
            "logback",
            "singleton"
        ],
        "type": "exec"
    },
    "value": {
        "objectName": "org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,instanceName=singleton,moduleFactoryName=logback,type=Module"
    }
}
</source>

*Configuration bean attributes are set to values obtained from loggers configuration, with which the server was started. To see attributes, request:
<source enclose="div">
curl -X POST -H "Content-Type: application/json" -d '{"type":"read", "mbean":"org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-1-2,type=Module,moduleFactoryName=logback"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
In response body, value contains all attributes (CompositeData) and it's nested attributes values.

*Now we can commit proposed configuration
<source enclose="div">
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec","mbean":"org.opendaylight.controller:type=ConfigRegistry","arguments":["org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-1-2,type=Module,moduleFactoryName=logback"],"operation":"commitConfig"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Configuration was successfully validated and committed and module instance created.
<source>
{
    "timestamp": 1383034793,
    "status": 200,
    "request": {
        "operation": "commitConfig",
        "mbean": "org.opendaylight.controller:type=ConfigRegistry",
        "arguments": [
            "org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-1-2,type=Module,moduleFactoryName=logback"
        ],
        "type": "exec"
    },
    "value": {
        "newInstances": [
            {
                "objectName": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=Module"
            }
        ],
        "reusedInstances": [],
        "recreatedInstances": []
    }
}
</source>

* Runtime bean was registered and can provide status information of configuration and rpc operation '''reset'''. To see status, try it by requesting:
<source enclose="div">
curl -X POST -H "Content-Type: application/json" -d '{"type":"read","mbean":"org.opendaylight.controller:instanceName=singleton,type=RuntimeBean,moduleFactoryName=logback"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Whole logback status is in the response body.

*To invoke rpc method '''reset''':
<source enclose="div">
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec",
"mbean":"org.opendaylight.controller:instanceName=singleton,type=RuntimeBean,moduleFactoryName=logback",
"operation":"reset","arguments":[]}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Get answer:
<source>
{
    "timestamp": 1383035001,
    "status": 200,
    "request": {
        "operation": "reset",
        "mbean": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=RuntimeBean",
        "type": "exec"
    },
    "value": null
}
</source>

Now if look at the runtime bean status attribute, it will be empty:
<source>
{
    "timestamp": 1383035126,
    "status": 200,
    "request": {
        "mbean": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=RuntimeBean",
        "type": "read"
    },
    "value": {
        "StatusTO": []
    }
}
</source>

== Logback configuration - Netconf ==
In this case, we will use NETCONF RPCs to configure logback. Netconf server is listening at port 8383. To communicate over TCP, telnet will be used.
More about NETCONF - http://tools.ietf.org/html/rfc6241 and it's implementation is a part of the Controller - netconf-subsystem. Netconf's RPCs are pure XMLs and operations are mapped to JMX's operations. 

* Again need to start server, same as above.

* Open terminal and connect to server:
<source>
telnet localhost 8383
</source>

* Hello message from server was received, it contains server's capabilities and session-id. To establish connection client need to send hello message, to do so type:
<syntaxhighlight lang="xml">
<hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <capabilities>
        <capability>urn:ietf:params:netconf:base:1.0</capability>
    </capabilities>
</hello>
]]>]]>
</syntaxhighlight>

*Now, connection is created, client and server can communicate together. To see running modules and services, send RPC to server:
<syntaxhighlight lang="xml">
<rpc id="a" a="64" xmlnx="a:b:c:d" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <get-config>
        <source>
            <running/>
        </source>
    </get-config>
</rpc>
]]>]]>
</syntaxhighlight>

* To configure logback, first need to create configuration transaction and create configuration module. It can be done in one step (in client point of view):
<syntaxhighlight lang="xml">
<rpc message-id="a" a="64" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
        <target>
            <candidate/>
        </target>
        <default-operation>merge</default-operation>
        <config>
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <module>
                    <name>singleton</name>
                    <type xmlns:logging="urn:opendaylight:params:xml:ns:yang:controller:logback:config">
                        logging:logback
                    </type>
                </module>
            </modules>
        </config>
    </edit-config>
</rpc>
]]>]]>
</syntaxhighlight>
If everihing alright, client receive positive response:
<syntaxhighlight lang="xml">
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
<ok/>
</rpc-reply>
]]>]]>
</syntaxhighlight>

* Logback configuration bean attributes contains values loaded from now running Logback configuration. Request server with RPC:
<syntaxhighlight lang="xml">
<rpc id="a" a="64" xmlnx="a:b:c:d" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <get-config>
        <source>
            <candidate/>
        </source>
    </get-config>
</rpc>
]]>]]>
</syntaxhighlight>

* Reply includes whole configuration as the server was started with. Assume that, we want to change RollingFileAppender named opendaylight.log attributes - maxFileSize, filename, and maxHistory (TimeBasedRollingPolicy's attribute). Propose configuration:
<syntaxhighlight lang="xml">
<rpc message-id="a" a="64" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
        <target>
            <candidate/>
        </target>
        <default-operation>merge</default-operation>
        <config>
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <module>
                    <name>singleton</name>
                    <type xmlns:logging="urn:opendaylight:params:xml:ns:yang:controller:logback:config">
                        logging:logback
                    </type>
		    <rolling-appenders xmlns="urn:opendaylight:params:xml:ns:yang:controller:logback:config">
			<append>true</append>
			<max-file-size>5MB</max-file-size>
			<file-name>logs/opendaylight-new.log</file-name>
			<name>opendaylight.log</name>
			<file-name-pattern>logs/opendaylight.%d.log.zip</file-name-pattern>
			<encoder-pattern>%date{"yyyy-MM-dd HH:mm:ss.SSS z"} [%thread] %-5level %logger{35} - %msg%n</encoder-pattern>
			<clean-history-on-start>false</clean-history-on-start>
			<max-history>7</max-history>
			<rolling-policy-type>TimeBasedRollingPolicy</rolling-policy-type>
		    </rolling-appenders>
                </module>
            </modules>
        </config>
    </edit-config>
</rpc>
]]>]]>
</syntaxhighlight>
This configuration is merged with the module configuration proposed before. If it passes through validation process successfully, "ok" reply is will be received.

* Now we are ready to commit configuration bean:
<syntaxhighlight lang="xml">
<rpc xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <commit></commit>
</rpc>
]]>]]>
</syntaxhighlight>
On succes, ok message obtained and logback configuration is set. As an evidence, take look into logs directory to find new log file named opendaylight-new.log

* Correctly close session with session-id :
<syntaxhighlight lang="xml">
<rpc message-id="2" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <close-session xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"/>
</rpc>
]]>]]>
</syntaxhighlight>

= Sample maven project =
In this example, we will create a maven project that will provide 2 modules each implementing one service. We will design a simple configuration as well as runtime data for each module using yang. <br />
For this demo, we created a sample maven project called config-demo. This project contains 2 Java interfaces: Foo and Bar with one default implementation per interface: FooImpl and BarImpl. Bar is the producer in our example and produces integers when method getNextEvent() is called. Foo is the consumer and its implementation depends on a Bar instance. Both implementations require some configuration that is injected via constructors. <br/> 
* Bar.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public interface Bar {

    int getNextEvent();

}
</source>
* BarImpl.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public class BarImpl implements Bar {

    private final int l1, l2;
    private final boolean b;

    public BarImpl(int l1, int l2, boolean b) {
        this.l1 = l1;
        this.currentL = l1;
        this.l2 = l2;
        this.b = b;
    }

    private int currentL;

    @Override
    public int getNextEvent() {
        if(currentL==l2)
            return -1;
        return currentL++;
    }
}
</source>

* Foo.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public interface Foo {

    int getEventCount();
}
</source>
* FooImpl.java:
<source lang="java">
package org.opendaylight.controller.config.demo;

public class FooImpl implements Foo {

    private final String strAttribute;
    private final Bar barDependency;
    private final int intAttribute;

    public FooImpl(String strAttribute, int intAttribute, Bar barDependency) {
        this.strAttribute = strAttribute;
        this.barDependency = barDependency;
        this.intAttribute = intAttribute;
    }

    @Override
    public int getEventCount() {
        int count = 0;
        while(barDependency.getNextEvent() != intAttribute) {
            count++;
        }
        return count;
    }
}
</source>
* pom.xml (config-demo project is defined as a sub-module of the controller project and at this point contains only configuration for maven-bundle-plugin):
<source lang='xml'>
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <artifactId>commons.opendaylight</artifactId>
        <groupId>org.opendaylight.controller</groupId>
        <version>1.4.1-SNAPSHOT</version>
        <relativePath>../commons/opendaylight/pom.xml</relativePath>
    </parent>
    <groupId>org.opendaylight.controller</groupId>
    <version>0.1.1-SNAPSHOT</version>
    <artifactId>config-demo</artifactId>
    <packaging>bundle</packaging>
    <name>${project.artifactId}</name>
    <prerequisites>
        <maven>3.0.4</maven>
    </prerequisites>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.felix</groupId>
                <artifactId>maven-bundle-plugin</artifactId>
                <version>2.3.7</version>
                <extensions>true</extensions>
                <configuration>
                    <instructions>
                        <Bundle-Name>${project.groupId}.${project.artifactId}</Bundle-Name>
                        <Export-Package>
                            org.opendaylight.controller.config.demo,
                        </Export-Package>
                    </instructions>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
</source>
== Describing module configuration using yang ==
In order to fully leverage the utilities of configuration subsystem, we need to describe services, modules, their configuration and runtime state using yang modeling language. We will define 2 services and 2 modules, which will be used to configure instances of FooImpl and BarImpl. This definition will be split into 2 yang files: config-demo.yang (service definition) and config-demo-impl.yang (module definition).
* config-demo.yang
<source>
module config-demo {
    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:demo";
    prefix "demo";

    import config { prefix config; revision-date 2013-04-05; }

    description
        "Service definition for config-demo";

    revision "2013-10-14" {
        description
            "Initial revision";
    }

    // Service definition for service foo that encapsulates instances of org.opendaylight.controller.config.demo.Foo
    identity foo {
        description
            "Foo service definition";

        base "config:service-type";
        config:java-class "org.opendaylight.controller.config.demo.Foo";
    }

    identity bar {
        description
            "Bar service definition";

        base "config:service-type";
        config:java-class "org.opendaylight.controller.config.demo.Bar";
    }
}
</source>
As you can see, the config yang module needs to be imported in order to define services. There are 2 services defined and these services correspond to Java interfaces Foo and Bar (specified by config:java-class extension).
* config-demo-impl.yang
<source>
module config-demo-impl {

    yang-version 1;
    namespace "urn:opendaylight:params:xml:ns:yang:controller:config:demo:java";
    prefix "demo-java";

    // Dependency on service definition for config-demo
    /* Service definitions could be also located in this yang file or even
     * in a separate maven project that is marked as maven dependency
     */
    import config-demo { prefix demo; revision-date 2013-10-14;}

    // Dependencies on config subsystem definition
    import config { prefix config; revision-date 2013-04-05; }
    import rpc-context { prefix rpcx; revision-date 2013-06-17; }


    description
        "Service implementation for config-demo";

    revision "2013-10-14" {
        description
            "Initial revision";
    }
                                                                      //----- module foo-impl ----- //
    // Module implementing foo service                                                              //
    identity foo-impl {                                                                             //
        base config:module-type;                                                                    //
        config:provided-service demo:foo;                                                           //
        config:java-name-prefix FooImpl;                                                            //
    }                                                                                               //
                                                                                                    //
    // Configuration for foo-impl module                                                            //
    augment "/config:modules/config:module/config:configuration" {                                  //
        case foo-impl {                                                                             //
            when "/config:modules/config:module/config:type = 'foo-impl'";                          //
                                                                                                    //
            leaf str-attribute {                                                                    //
                type string;                                                                        //
            }                                                                                       //
                                                                                                    //
            leaf int-attribute {                                                                    //
                type int32;                                                                         //
            }                                                                                       //
                                                                                                    //
                                                                                                    //
            // Dependency on bar service instance                                                   //
            container bar-dependency {                                                              //
                uses config:service-ref {                                                           //
                    refine type {                                                                   //
                        mandatory true;                                                             //
                        config:required-identity demo:bar;                                          //
                    }                                                                               //
                }                                                                                   //
            }                                                                                       //
                                                                                                    //
        }                                                                                           //
    }                                                                                               //
                                                                                                    //
    // Runtime state definition for foo-impl module                                                 //
    augment "/config:modules/config:module/config:state" {                                          //
        case foo-impl {                                                                             //
            when "/config:modules/config:module/config:type = 'foo-impl'";                          //
                                                                                                    //
                                                                                                    //
        }                                                                                           //
    }                                                                                               //
                                                                                      // ---------- //
    // Module implementing bar service
    identity bar-impl {
        base config:module-type;
        config:provided-service demo:bar;
        config:java-name-prefix BarImpl;
    }

    augment "/config:modules/config:module/config:configuration" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

            container dto-attribute {
                leaf int-attribute {
                    type int32;
                }

                leaf int-attribute2 {
                    type int32;
                }

                leaf bool-attribute {
                    type boolean;
                }
            }

        }
    }

    augment "/config:modules/config:module/config:state" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

        }
    }

}
</source>
Again, config yang module as well as config-demo yang module need to be imported. There are 2 modules defined: foo-impl and bar-impl and their configuration (defined in augment "/config:modules/config:module/config:configuration" block) corresponds to the configuration of FooImpl and BarImpl Java classes. If we take a look at FooImpl.java's constructor, we can see that the configuration of foo-impl module defines similar 3 attributes. We will use these arguments to instantiate the FooImpl class. We placed these yang files under src/main/yang folder. </br>

== Updating maven configuration in pom.xml ==
Now we need to add yang-maven-plugin to our pom.xml. This plugin will process yang files and generate configuration code for the defined modules. Plugin's configuration:
<source lang='xml'>
<plugin>
    <groupId>org.opendaylight.yangtools</groupId>
    <artifactId>yang-maven-plugin</artifactId>
    <version>${yangtools.version}</version>
    <executions>
        <execution>
            <goals>
                <goal>generate-sources</goal>
            </goals>
            <configuration>
                <codeGenerators>
                    <generator>
                        <codeGeneratorClass>
                            org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
                        </codeGeneratorClass>
                        <outputBaseDir>${project.build.directory}/generated-sources/config</outputBaseDir>
                        <additionalConfiguration>
                            <namespaceToPackage1>
                                urn:opendaylight:params:xml:ns:yang:controller==org.opendaylight.controller.config.yang
                            </namespaceToPackage1>
                        </additionalConfiguration>
                    </generator>
                </codeGenerators>
                <inspectDependencies>true</inspectDependencies>
            </configuration>
        </execution>
    </executions>
    <dependencies>
        <dependency>
            <groupId>org.opendaylight.controller</groupId>
            <artifactId>yang-jmx-generator-plugin</artifactId>
            <version>${config.version}</version>
        </dependency>
    </dependencies>
</plugin>
</source>
Important configuration for the plugin is: output folder for generated files and mapping between yang namespaces and java packages (Inspect dependencies must be set to true ). The default location for yang files is under src/main/yang folder. This plugin is backed by artifact yang-jmx-generator-plugin and its class org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator is responsible for the code generation. This artifact is part of the configuration subsystem. <br/>

In addition to yang-maven-plugin, it is neccessary to add build-helper-maven-plugin in order to add generated sources to the build process:

 <plugin>
    <groupId>org.codehaus.mojo</groupId>
    <artifactId>build-helper-maven-plugin</artifactId>
    <version>1.8</version>
    <executions>
        <execution>
            <id>add-source</id>
            <phase>generate-sources</phase>
            <goals>
                <goal>add-source</goal>
            </goals>
            <configuration>
                <sources>
                   &lt;source>${project.build.directory}/generated-sources/config&lt;/source>;
                </sources>
            </configuration>
        </execution>
    </executions>
 </plugin>

Earlier, we imported config yang module in our yang files. In order to acquire this yang module, we need to add dependency to the pom file:
<source lang='xml'>
<dependency>
    <groupId>org.opendaylight.controller</groupId>
    <artifactId>config-api</artifactId>
    <version>${config.version}</version>
</dependency>
</source>

We will also add a couple of utility dependencies:
<source lang='xml'>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
</dependency>
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
</dependency>
</source>

We are now ready to run '''mvn clean install'''.

== Generated java files ==
Now we can see a bunch of new source files divided into 2 groups. First group is located under ${project.build.directory}/generated-sources/config directory, which we specified in yang-maven-plugin's configuration. The second group is located under src/main/java directory. Both groups then define package org.opendaylight.controller.config.yang.config.demo.impl. The first group contains code that should not be edited in any way, since this code can be regenerated by the plugin if necessary. The code that needs to be edited belongs to the second group and is located under src/main/java. <br/>

=== Generated config source files examples ===
* BarImplModuleMXBean.java
<source lang='java'>
public interface BarImplModuleMXBean
{
    public org.opendaylight.controller.config.yang.config.demo.java.DtoAttribute getDtoAttribute();

    public void setDtoAttribute(org.opendaylight.controller.config.yang.config.demo.java.DtoAttribute dtoAttribute);

}
</source>
BarImplModuleMXBean interface represents getter and setter for dtoAttribute that will be exported to configuration registry via JMX. Attribute was defined in yang model - in this case it is composite type which was converted to OpenType.
*Attribute definition from config-demo-impl.yang
<source lang='java'>
    
    // Module implementing bar service
    identity bar-impl {
        base config:module-type;
        config:provided-service demo:foo;
        config:java-name-prefix BarImpl;
    }

    augment "/config:modules/config:module/config:configuration" {
        case bar-impl {
            when "/config:modules/config:module/config:type = 'bar-impl'";

            container dto-attribute {
                leaf int-attribute {
                    type int32;
                }

                leaf int-attribute2 {
                    type int32;
                }

                leaf bool-attribute {
                    type boolean;
                }
            }

        }
    }
</source>
From container dto-attribute, DtoAttribute java file was generated. Class contains plain constructor, getters and setters for attributes defined as container leaves.<br />
Not only ModuleMXBean is generated from this module definition, but also BarImplModuleFactory and BarImplModule stubs are generated (in fact AbstractBarImplModuleFactory and AbstractBarImplModule are generated too).

* AbstractBarImplModule.java
This abstract class is almost fully generated, only method validate() has empty body and method createInstance() is abstract. Both methods must be implemented by user, we will show it later. AbstractBarImplModule implements it's ModuleMXBean, Module, RuntimeBeanRegistratorAwareModule and dependent service interface as defined in yang. Moreover class contains two types of constructors - one for module created from old module instance and the second for module creation from scratch.

* AbstractBarImplModuleFactory.java
Unlike AbstractModule, AbstractFactory is fully generated, but still abstract class. The factory is responsible for module instances creation, provides two type of instantiateModule methods for both module constructor types. It implements ModuleFactory interface.

Next we will create runtime bean for FooImplModule. Runtime beans are designated to capture data about running module.
* Add runtime bean definition to config-demo-impl.yang
<source lang='java'>

</source>

=== Modifying generated sources ===
Generated source files:
* src/main/java/**/BarImplModule
* src/main/java/**/BarImplModuleFactory
* src/main/java/**/FooImplModule
* src/main/java/**/FooImplModuleFactory

'''BarImplModule'''<br />
We will start by modifying BarImplModule. You can see 2 constructors (not interesting at all) and 2 generated methods:
<source lang='java'>
    @Override
    public void validate(){
        super.validate();
        // Add custom validation for module attributes here.
    }

    @Override
    public java.lang.AutoCloseable createInstance() {
        //TODO:implement
        throw new java.lang.UnsupportedOperationException("Unimplemented stub method");
    }
</source>

In '''validate''', you can specify and validation for config attributes e.g.:
<source lang='java'>
    @Override
    public void validate(){
        super.validate();  
        Preconditions.checkNotNull(getDtoAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getBoolAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getIntAttribute());
        Preconditions.checkNotNull(getDtoAttribute().getIntAttribute2());
        Preconditions.checkState(getDtoAttribute().getIntAttribute() > getDtoAttribute().getIntAttribute2());
    }
</source>

and in '''createInstance''' you need to create new instance of the bar service => Bar interface e.g.:
<source lang='java'>
        @Override
    public java.lang.AutoCloseable createInstance() {
        return new BarImpl(getDtoAttribute().getIntAttribute(), getDtoAttribute().getIntAttribute2(), getDtoAttribute()
                .getBoolAttribute());
    }
</source>
A few notes: 
* createInstance returns AutoCloseable so the returned type needs to implement it (you can make BarImpl implement AutoCloseable or create a Wrapper class around BarImpl instance that implements AutoCloseable or even extend BarImpl class and make it implement it),
* you can access all configuration attributes via getter methods, 
* in config-demo-impl.yang, we defined bar-impl's configuration as a container dto-attribute and the code generator create a transfer object DtoAttribute that you can access via getDtoAttribute() method and retrieve configuration data from it. You can even add new constructor to BarImpl that takes this transfer object and reduce the amount of arguments.

'''FooImplModule'''<br />
We will not add any custom validation in this module.
The '''createInstance''' method will look like:
<source lang='java'>
    @Override
    public java.lang.AutoCloseable createInstance() {
        return new FooImpl(getStrAttribute(), getIntAttribute(), getBarDependencyDependency());
    }
</source>

=== Adding support for default instances ===
In order to provide default instance of module bar-impl, we need to further modify generated code by overriding method ''getDefaultModules'' in ''src/main/java/**/BarImplModuleFactory'' class. The body of this class is emtpy so far and it inherits default behaviour from its parent abstract factory. We will replace empty body by this code:

<source lang='java'>
    public static final ModuleIdentifier defaultInstance1Id = new ModuleIdentifier(NAME, "defaultInstance1");

    @Override
    public Set<BarImplModule> getDefaultModules(DependencyResolverFactory dependencyResolverFactory, BundleContext bundleContext) {
        DependencyResolver depResolver1 = dependencyResolverFactory.createDependencyResolver(defaultInstance1Id);
        BarImplModule defaultModule1 = new BarImplModule(defaultInstance1Id, depResolver1);
        defaultModule1.setDtoAttribute(getDefaultConfiguration(bundleContext));

        return Sets.newHashSet(defaultModule1);
    }

    private DtoAttribute getDefaultConfiguration(BundleContext bundleContext) {
        DtoAttribute defaultConfiguration = new DtoAttribute();

        String property = bundleContext.getProperty("default.bool");
        defaultConfiguration.setBoolAttribute(property == null ? false : Boolean.parseBoolean(property));

        property = bundleContext.getProperty("default.int1");
        defaultConfiguration.setIntAttribute(property == null ? 55 : Integer.parseInt(property));

        property = bundleContext.getProperty("default.int2");
        defaultConfiguration.setIntAttribute2(property == null ? 0 : Integer.parseInt(property));

        return defaultConfiguration;
    }
</source>

The ''getDefaultModules'' method now produces an instance of bar-impl module with name ''defaultInstance1'' (it is possible to produce multiple default instances since the return type is a Set of module instances). Notice the ''getDefaultConfiguration'' method, it provides the default configuration for default instances by trying to retrieve system properties from bundleContext (or provides hardcoded values in case system property is not present).

For the controller distribution, system properties can be feeded via ''config.ini'' file.

Method ''getDefaultModules'' is called automatically after a bundle containing this factory is started in the OSGi environment. Its default implementation returns an empty Set.

Default instances approach is similar to the Activator class approach in OSGi with the advantage of default instances being managed by the configuration subsystem. This approach can replace Activator class approach or it can be used along with it.

==== Verifying default instances in distribution ====
If we add config-demo bundle to opendaylight's distribution, we can verify the presence of the default instance. File ''pom.xml'' under ''opendaylight/distribution/opendaylight'' folder needs to be modified by adding config-demo dependency:
<source lang='xml'>
<dependency>
    <groupId>${project.groupId}</groupId>
    <artifactId>config-demo</artifactId>
    <version>0.1.1-SNAPSHOT</version>
</dependency>
</source>

Now we need to rebuild the conf-demo module using mvn clean install. Then we can build the distribution using the same mvn command under ''opendaylight/distribution/opendaylight'' folder. Now if we head to ''opendaylight/distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight'' folder and execute ''run.sh'', the opendaylight distribution should start.

We can check the presence of default instances via JMX using tool such as ''jvisualvm'':
[[File:Default instance verify.PNG|frameless|center|jvisualvm showing the default instance of bar-impl module]]
