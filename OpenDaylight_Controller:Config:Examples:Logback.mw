= Logback Configuration Example =
Logback logger configuration is part of the config subsystem. This module allows to change Logback configuration at runtime. Here it will be used as an example to demonstrate YANG to Java code generator and show how configuration transaction works.

== Java code generating ==
Logging configuration YANG module definition can be found in '''config-logging.yang''' file. Code is generated by '''yang-maven-plugin''' and '''yang-jmx-generator-plugin'''. The output java files are located as defined in plugin configuration, where additional configuration parameters can be set. 
Logback module is defined as identity, with base "config:module-type", it does not provide or depend on any service interface.
<source>
identity logback {
    description
        "Actual state of logback configuration.";
    base config:module-type;
    config:java-name-prefix Logback;
}
</source>

Next logback module attributes are defined in "/config:modules/config:module/config:configuration" augment as snippet bellow shows.
<source>
augment "/config:modules/config:module/config:configuration" {
    case logback {
        when "/config:modules/config:module/config:type = 'logback'";

        list console-appenders {

            leaf encoder-pattern {
                type string;
                mandatory true;
            }

            leaf threshold-filter {
                type string;
                default 'ALL';
            }

            leaf name {
                type string;
                mandatory true;
            }
            config:java-name-prefix ConsoleAppenderTO;
        }
         ...
</source>
Now LogbackModule and LogbackModuleFactory can be generated - in fact there will be generated three more java files related to this module. By the augment definition, '''TypeObjects''' are generated too (i.e. ConsoleAppenderTO). They are regular java classes with getters and setters for arguments defined as leaves.
* '''LogbackModuleMXBean''' is interface containing getters and setters for attributes defined in configuration augment.<br />
* '''AbstractLogbackModule''' is abstract java class, which implements Module, RuntimeBeanRegistratorAwareModule and LogbackModuleMXBean. It contains almost all functionality, expect of '''validate''' and '''createInstance''' methods.
* '''AbstractLogbackModuleFactory''' is abstract java class responsible for creating modules instances. It implements ModuleFactory interface.
* '''LogbackModule''' class extends AbstractLogbackModule. It is located on different place (source/main/java) and can be modified by user, so that abstract method is implemented and validate method is overridden.
* '''LogbackModuleFactory''' class extends AbstractLogbackModuleFactory and overrides it's instantiateModule methods.

Next, runtime bean is defined in "/config:modules/config:module/config:state" augment
<source>
augment "/config:modules/config:module/config:state" {
    case logback {
        when "/config:modules/config:module/config:type = 'logback'";

        rpcx:rpc-context-instance "logback-rpc";

        list status {
            config:java-name-prefix StatusTO;

            leaf level {
                type string;
            }

            leaf message {
                type string;
            }

            leaf date {
                type uint32;
            }
        }
    }
}
</source>
Generator plugin creates another bunch of java files.
* '''LogbackRuntimeMXBean''' is interface extending RuntimeBean. It contains getter method for argument defined in augment.
* '''LogbackRuntimeRegistrator''' class serves as registrator for runtime beans.
* '''LogbackRuntimeRegistration''' class serves as registration ticket, instance is returned after registration.

Logback config also defines '''logback-rpc''' with '''reset''' method. It is also defined in state augment, due to context.
<source>
identity logback-rpc;
rpc reset {
    input {
        uses rpcx:rpc-context-ref {
            refine context-instance {
                rpcx:rpc-context-instance logback-rpc;
            }
        }
    }
}
</source>
Reset method is defined in LogbackRuntimeMXBean interface.

== Logback configuration - Jolokia ==
Now try to create configuration on running OSGi server. We will use '''Jolokia''' (http://www.jolokia.org/) as a JMX-HTTP bridge, which listen at http://localhost:8080/controller/nb/v2/jolokia and '''curl''' to request over HTTP.

* Start up controller. Find more here: https://wiki.opendaylight.org/view/OpenDaylight_Controller:Pulling,_Hacking,_and_Pushing_the_Code_from_the_CLI

* Try to request Jolokia:
<source>
curl http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Response should looks like:
<source>
{
    "timestamp": 1382425537,
    "status": 200,
    "request": {
        "type": "version"
    },
    "value": {
        "protocol": "7.0",
        "agent": "1.1.1",
        "info": {
            "product": "equinox",
            "vendor": "Eclipse",
            "version": "3.8.1.v20120830-144521"
        }
    }
}
</source>
We are sure Jolokia is working.

* To configure Logback, first, we need to create configuration transaction. ConfigResgistryModule offers operation beginConfig(), to invoke it:
<source enclose="div">
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec","mbean":"org.opendaylight.controller:type=ConfigRegistry","arguments":[],"operation":"beginConfig"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Configuration transaction was created, received response:
<source>
{
    "timestamp": 1383034210,
    "status": 200,
    "request": {
        "operation": "beginConfig",
        "mbean": "org.opendaylight.controller:type=ConfigRegistry",
        "type": "exec"
    },
    "value": {
        "objectName": "org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,type=ConfigTransaction"
    }
}
</source>

* At this stage transaction can be aborted, but we want to create module bean to be configured. In created ConfigTransaction call createModule method, module identifier is '''logback''' and name must be '''singleton''' as we want to have only one instance of Logback configuration.
<source enclose="div">
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec","mbean":"org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,type=ConfigTransaction","arguments":["logback","singleton"],"operation":"createModule"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
LogbackModule bean was created, see returned response:
<source>
{
    "timestamp": 1383034580,
    "status": 200,
    "request": {
        "operation": "createModule",
        "mbean": "org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,type=ConfigTransaction",
        "arguments": [
            "logback",
            "singleton"
        ],
        "type": "exec"
    },
    "value": {
        "objectName": "org.opendaylight.controller:TransactionName=ConfigTransaction-1-2,instanceName=singleton,moduleFactoryName=logback,type=Module"
    }
}
</source>

*Configuration bean attributes are set to values obtained from loggers configuration, with which the server was started. To see attributes, request:
<source enclose="div">
curl -X POST -H "Content-Type: application/json" -d '{"type":"read", "mbean":"org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-1-2,type=Module,moduleFactoryName=logback"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
In response body, value contains all attributes (CompositeData) and it's nested attributes values.

*Now we can commit proposed configuration
<source enclose="div">
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec","mbean":"org.opendaylight.controller:type=ConfigRegistry","arguments":["org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-1-2,type=Module,moduleFactoryName=logback"],"operation":"commitConfig"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Configuration was successfully validated and committed and module instance created.
<source>
{
    "timestamp": 1383034793,
    "status": 200,
    "request": {
        "operation": "commitConfig",
        "mbean": "org.opendaylight.controller:type=ConfigRegistry",
        "arguments": [
            "org.opendaylight.controller:instanceName=singleton,TransactionName=ConfigTransaction-1-2,type=Module,moduleFactoryName=logback"
        ],
        "type": "exec"
    },
    "value": {
        "newInstances": [
            {
                "objectName": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=Module"
            }
        ],
        "reusedInstances": [],
        "recreatedInstances": []
    }
}
</source>

* Runtime bean was registered and can provide status information of configuration and rpc operation '''reset'''. To see status, try it by requesting:
<source enclose="div">
curl -X POST -H "Content-Type: application/json" -d '{"type":"read","mbean":"org.opendaylight.controller:instanceName=singleton,type=RuntimeBean,moduleFactoryName=logback"}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Whole logback status is in the response body.

*To invoke rpc method '''reset''':
<source enclose="div">
curl -X POST -H "Content-Type: application/json" -d '{"type":"exec",
"mbean":"org.opendaylight.controller:instanceName=singleton,type=RuntimeBean,moduleFactoryName=logback",
"operation":"reset","arguments":[]}' http://localhost:8080/controller/nb/v2/jolokia --user admin:admin
</source>
Get answer:
<source>
{
    "timestamp": 1383035001,
    "status": 200,
    "request": {
        "operation": "reset",
        "mbean": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=RuntimeBean",
        "type": "exec"
    },
    "value": null
}
</source>

Now if look at the runtime bean status attribute, it will be empty:
<source>
{
    "timestamp": 1383035126,
    "status": 200,
    "request": {
        "mbean": "org.opendaylight.controller:instanceName=singleton,moduleFactoryName=logback,type=RuntimeBean",
        "type": "read"
    },
    "value": {
        "StatusTO": []
    }
}
</source>

== Logback configuration - Netconf ==
In this case, we will use NETCONF RPCs to configure logback. Netconf server is listening at port 8383. To communicate over TCP, telnet will be used.
More about NETCONF - http://tools.ietf.org/html/rfc6241 and it's implementation is a part of the Controller - netconf-subsystem. Netconf's RPCs are pure XMLs and operations are mapped to JMX's operations. 

* Again need to start server, same as above.

* Open terminal and connect to server:
<source>
telnet localhost 8383
</source>

* Hello message from server was received, it contains server's capabilities and session-id. To establish connection client need to send hello message, to do so type:
<syntaxhighlight lang="xml">
<hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <capabilities>
        <capability>urn:ietf:params:netconf:base:1.0</capability>
    </capabilities>
</hello>
]]>]]>
</syntaxhighlight>

*Now, connection is created, client and server can communicate together. To see running modules and services, send RPC to server:
<syntaxhighlight lang="xml">
<rpc id="a" a="64" xmlnx="a:b:c:d" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <get-config>
        <source>
            <running/>
        </source>
    </get-config>
</rpc>
]]>]]>
</syntaxhighlight>

* To configure logback, first need to create configuration transaction and create configuration module. It can be done in one step (in client point of view):
<syntaxhighlight lang="xml">
<rpc message-id="a" a="64" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
        <target>
            <candidate/>
        </target>
        <default-operation>merge</default-operation>
        <config>
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <module>
                    <name>singleton</name>
                    <type xmlns:logging="urn:opendaylight:params:xml:ns:yang:controller:logback:config">
                        logging:logback
                    </type>
                </module>
            </modules>
        </config>
    </edit-config>
</rpc>
]]>]]>
</syntaxhighlight>
If everihing alright, client receive positive response:
<syntaxhighlight lang="xml">
<rpc-reply xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
<ok/>
</rpc-reply>
]]>]]>
</syntaxhighlight>

* Logback configuration bean attributes contains values loaded from now running Logback configuration. Request server with RPC:
<syntaxhighlight lang="xml">
<rpc id="a" a="64" xmlnx="a:b:c:d" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <get-config>
        <source>
            <candidate/>
        </source>
    </get-config>
</rpc>
]]>]]>
</syntaxhighlight>

* Reply includes whole configuration as the server was started with. Assume that, we want to change RollingFileAppender named opendaylight.log attributes - maxFileSize, filename, and maxHistory (TimeBasedRollingPolicy's attribute). Propose configuration:
<syntaxhighlight lang="xml">
<rpc message-id="a" a="64" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <edit-config>
        <target>
            <candidate/>
        </target>
        <default-operation>merge</default-operation>
        <config>
            <modules xmlns="urn:opendaylight:params:xml:ns:yang:controller:config">
                <module>
                    <name>singleton</name>
                    <type xmlns:logging="urn:opendaylight:params:xml:ns:yang:controller:logback:config">
                        logging:logback
                    </type>
		    <rolling-appenders xmlns="urn:opendaylight:params:xml:ns:yang:controller:logback:config">
			<append>true</append>
			<max-file-size>5MB</max-file-size>
			<file-name>logs/opendaylight-new.log</file-name>
			<name>opendaylight.log</name>
			<file-name-pattern>logs/opendaylight.%d.log.zip</file-name-pattern>
			<encoder-pattern>%date{"yyyy-MM-dd HH:mm:ss.SSS z"} [%thread] %-5level %logger{35} - %msg%n</encoder-pattern>
			<clean-history-on-start>false</clean-history-on-start>
			<max-history>7</max-history>
			<rolling-policy-type>TimeBasedRollingPolicy</rolling-policy-type>
		    </rolling-appenders>
                </module>
            </modules>
        </config>
    </edit-config>
</rpc>
]]>]]>
</syntaxhighlight>
This configuration is merged with the module configuration proposed before. If it passes through validation process successfully, "ok" reply is will be received.

* Now we are ready to commit configuration bean:
<syntaxhighlight lang="xml">
<rpc xmlns="urn:ietf:params:xml:ns:netconf:base:1.0" message-id="101">
    <commit></commit>
</rpc>
]]>]]>
</syntaxhighlight>
On succes, ok message obtained and logback configuration is set. As an evidence, take look into logs directory to find new log file named opendaylight-new.log

* Correctly close session with session-id :
<syntaxhighlight lang="xml">
<rpc message-id="2" xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
    <close-session xmlns="urn:ietf:params:xml:ns:netconf:base:1.0"/>
</rpc>
]]>]]>
</syntaxhighlight>

== Logback configuration - Yuma ==
