== Overview ==
This tutorial presents a walk through of the [https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL MD-SAL] based example of the Toaster capability ( this  capability comes from the [http://www.netconfcentral.org/modulereport/toaster YANG module toaster.yang ] schema).
== Objective ==
The main objective is to provide the reader a better understanding of the MD-SAL infrastructure within the OpenDaylight controller. 
The Toaster sample implementation is a suitable example because it provides the model of a programmable toaster, a sample consumer application that uses MD-SAL APIs, a sample service provider that implements Toaster, and a unit test suite.
== Prerequisites ==
The Toaster example is part of the OpenDaylight controller, so in order to access the source code with its dependencies please check [https://wiki.opendaylight.org/view/OpenDaylight_Controller:Installation ODL Installation Guide]

It's located in ''controller.git'' under ''opendaylight/md-sal/samples''.


== Structure ==
We will address three contexts in this tutorial:
# Data Model Context - presents the correlation between the Toaster Yang Model and the generated MD-SAL API
# Plugin Context -  introduces the provider and consumer and interaction with MD-SAL services
# Config-subsystem Context

== Data Model Context ==
=== Yang definition for Toaster ===
The definition of the Toaster capability is defined by it's yang data model, as a Yang ''module'' definition ; the file is located in the ''sample-toaster'' project in: ''src/main/yang/toaster.yang''

The yang schema defines the service, description and state data and functionality of the Toaster: 
# DATA definitions for toaster: (YANG: ''container toaster'')
#* (YANG: ''leaf toasterManufacturer'')
#* (YANG: ''leaf toasterModelNumber'')
#* (YANG: ''leaf toasterStatus'')
# SERVICE RPCs:operations that can be done, they are defined through RPCs, there are two available:
#* (YANG: ''rpc make-toast'') taking input parameters:
#** (YANG: ''leaf toasterDoneness'')
#** (YANG: ''leaf toasterToastType'')
#* (YANG: ''rpc cancel-toast'')
# NOTIFICATIONS: 
#* (YANG: ''notification toastDone'')

=== MD-SAL generated APIs definitions ===
The MD-SAL model-driven infrastructure allows developers of applications and plugins to develop against one set of APIs:
* the  Toaster SAL API is generated from the Toaster Yang model using the [https://wiki.opendaylight.org/view/YANG_Tools YANG Tools]. 
:: this is achieved through the ''yang-maven-plugin'' which uses the ''org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl'' code generator, called from the ''sample-toaster'' project build phase - section of the project's POM file: 
<code>

              <plugin>
                <groupId>org.opendaylight.yangtools</groupId>
                <artifactId>yang-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <goals>
                            <goal>generate-sources</goal>
                        </goals>
                        <configuration>
                            <yangFilesRootDir>src/main/yang</yangFilesRootDir>
                            <codeGenerators>
                                <generator>
                                    <codeGeneratorClass>
                                        org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl
                                    </codeGeneratorClass>
                                    <outputBaseDir>
                                        ${salGeneratorPath}
                                    </outputBaseDir>
                                </generator>
                            </codeGenerators>
                            <inspectDependencies>true</inspectDependencies>
                        </configuration>
                    </execution>
                </executions>
                <dependencies>
                    <dependency>
                        <groupId>org.opendaylight.yangtools</groupId>
                        <artifactId>maven-sal-api-gen-plugin</artifactId>
                        <version>${yangtools.version}</version>
                        <type>jar</type>
                    </dependency>
                </dependencies>
            </plugin>
</code>                
            
* the resulting generated SAL APIs are stored under '''src/main/yang-gen-sal'' (for a complete guide of the code generator mappings see [[https://wiki.opendaylight.org/view/YANG_Tools:YANG_to_Java_Mapping Yang to Java Mapping]])
:: the generated JAVA files contain interfaces and abstract classes (not all of them will be listed below, but those which reflect the correlation with the Yang model described in the Yang definition section above) :
::* '''interface ToasterData extends DataRoot''' (''Toaster.java'')  <- DATA definitions for toaster
::* '''interface ToasterService extends RpcService''' (''ToasterService.java'') <- SERVICE RPCs 
::* '''interface ToasterListener extends NotificationListener''' (''ToasterListener.java'') <- NOTIFICATIONS

=== API OSGI bundle ===
Upon running a build of the ''sample-toaster'' project, the generated SAL APIs are bundled by maven creating an OSGI bundle, which will be referred as the 'API OSGI bundle'.


== Plugin Context ==

=== Toaster Provider ===
 <to be filled on Thursday the 16th of April>
=== Toaster Consumer ===
  <to be filled on Thursday the 16th of April>

=== Diagram ===
[[File:ToasterProviderConsumer.jpg]]

== Config-subsystem Context ==
In order to get the full benefits of the ODL Controller's subsystem (for example access through JMX or NETCONF to the available ''toaster'' services and run-time related data), the toaster provider and consumer plugins in our example have been defined as subsystem modules. 
=== Definitions of service-type/module-type in YANG  ===
Each definition consists of an YANG '''service''' definition file, and an '''module''' definition file (files are located in ''src/main/yang'' folders).
The '''service-type''' acts as an interface while the '''module-type''' acts as the implementation of the interface:
==== Toaster Provider definition ====
* '''service-type''' declaration (in ''toaster-provider.yang''):
<pre>
identity toaster-provider {

        base "config:service-type";

        config:java-class "org.opendaylight.yang.gen.v1.http.netconfcentral.org.ns.toaster.rev091120.ToasterData";
    }
</pre>

* '''module-type''' declaration (in ''toaster-provider-impl.yang'')::
<pre>
identity toaster-provider-impl {
            base config:module-type;
            config:provided-service toaster-provider:toaster-provider;
            config:java-name-prefix ToasterProvider;
    }
</pre>


==== Toaster Consumer definition ====
* '''service-type''' declaration (in ''toaster-consumer.yang''):
<pre>
identity toaster-consumer {

        base "config:service-type";

        config:java-class "org.opendaylight.controller.sample.toaster.provider.api.ToastConsumer";
    }
</pre>

* '''module-type''' declaration (in ''toaster-consumer-impl.yang'')::
<pre>
identity toaster-consumer-impl {
            base config:module-type;
            config:provided-service toaster-consumer:toaster-consumer;
            config:java-name-prefix ToasterConsumer;
    }
</pre>

=== Dependencies with MD-SAL  ===
Both the Toaster-Consumer and Toaster-Provider have 'dependencies' on MD-SAL infrastructure services.
We'll list the types of dependencies involved in our Toaster example:


==== RpcRegistry dependency ====
* Toaster-Provider implements RPCs (ToasterService RPCs) from the generated SAL API, so these implementations have to be  registered with MD-SAL: 
<pre>getRpcRegistryDependency().addRpcImplementation(ToasterService.class, opendaylightToaster);</pre>

* Toaster-Consumer, in order to access the ToasterService instance from MD-SAL uses <pre>getRpcRegistryDependency().getRpcService(ToasterService.class);</pre>

==== NotificationService dependency ====
* Toaster-Provider sends notifications through MD-SAL, so it registers through
<pre>
setNotificationProvider(getNotificationServiceDependency());
</pre>

* Toaster-Consumer, in order to receive notifications from the provider through MD-SAL registers through 
<pre>
setNotificationServiceDependency().registerNotificationListener(ToastDone.class, consumer);
</pre>

==== DataBroker dependency ====
The Toaster-Provider uses the MD-SALs DataBrokerService to write state data to the DataStore , the dependency on this service is through
<pre>
setDataProvider(getDataBrokerDependency());
</pre>

=== Dependencies as Augmentations in YANG ===
The dependencies mentioned in the previous section must be specified in the module configuration yang files, as an '''augment''' of the '''config:configuration''':
* Toaster-Provider (''toaster-provider-impl.yang'')
<pre>
augment "/config:modules/config:module/config:configuration" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";

            container rpc-registry {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-rpc-registry;
                    }
                }
            }

            container notification-service {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-notification-service;
                    }
                }
            }
            container data-broker {
                uses config:service-ref {
                    refine type {
                        mandatory false;
                        config:required-identity mdsal:binding-data-broker;
                    }
                }
            }

           
        }
</pre>
* Toaster-Consumer (''toaster-consumer-impl.yang'')
<pre>
augment "/config:modules/config:module/config:configuration" {
        case toaster-consumer-impl {
            when "/config:modules/config:module/config:type = 'toaster-consumer-impl'";

            container rpc-registry {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-rpc-registry;
                    }
                }
            }

            container notification-service {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-notification-service;
                    }
                }
            }

        }
    }
</pre>

'''For a detailed walk-through on how to make a 'config-subsystem aware' project please visit''' https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Examples:Sample_Project

=== Extra configuration ===
Our Toaster example (for demo purposes) has been designed to have some additional features:
* Toaster Provider provides access through JMX/config-subsystem to some additional data -  '''toasts-made''', this is achieved by augmenting the '''config-state''' in ''toaster-provider-impl.yang'':
<pre>
augment "/config:modules/config:module/config:state" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";

            leaf toasts-made {
                type uint32;
            }

        }
    }
</pre>
* Toaster Consumer provides access through JMX/config-subsystem to a specific RPC - '''make-hash-brown-toast-rpc''', this is achieved by augmenting the config-state in ''toaster-consumer-impl.yang'':

<pre>
augment "/config:modules/config:module/config:state" {
        case toaster-consumer-impl {
            when "/config:modules/config:module/config:type = 'toaster-consumer-impl'";
            rpcx:rpc-context-instance "make-hash-brown-toast-rpc";
        }
    }

    identity make-hash-brown-toast-rpc;

    rpc make-hash-brown-toast {
        input {
            uses rpcx:rpc-context-ref {
                refine context-instance {
                    rpcx:rpc-context-instance make-hash-brown-toast-rpc;
                }
            }
            leaf doneness {
                type uint16;
            }
        }
        output {
            leaf result {
                type boolean;
            }
        }
    }
</pre>

=== Generated Java classes ===

The Yang files   
*''toaster-provider.yang'', ''toaster-provider-impl.yang'' and 
*''toaster-consumer.yang'', ''toaster-consumer-impl.yang''
are converted to java files from which Java code for configuration system is generated by yang-maven-plugin and yang-jmx-generator-plugin.

To run the converter , the below code has to be added to the (''toaster-provider'' and ''toaster-consumer'' projects) POM files:
<pre>
            <plugin>
                <groupId>org.opendaylight.yangtools</groupId>
                <artifactId>yang-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>config</id>
                        <goals>
                            <goal>generate-sources</goal>
                        </goals>
                        <configuration>
                            <codeGenerators>
                                <generator>
                                    <codeGeneratorClass>
                                        org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
                                    </codeGeneratorClass>
                                    <outputBaseDir>${jmxGeneratorPath}</outputBaseDir>
                                    <additionalConfiguration>
                                        <namespaceToPackage1>
                                            urn:opendaylight:params:xml:ns:yang:controller==org.opendaylight.controller.config.yang
                                        </namespaceToPackage1>
                                    </additionalConfiguration>
                                </generator>
                                <generator>
                                    <codeGeneratorClass>
                                        org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl
                                    </codeGeneratorClass>
                                    <outputBaseDir>
                                        ${salGeneratorPath}
                                    </outputBaseDir>
                                </generator>
                            </codeGenerators>
                            <inspectDependencies>true</inspectDependencies>
                        </configuration>
                    </execution>
                </executions>
                <dependencies>
                    <dependency>
                        <groupId>org.opendaylight.controller</groupId>
                        <artifactId>yang-jmx-generator-plugin</artifactId>
                        <version>${config.version}</version>
                    </dependency>
                    <dependency>
                        <groupId>org.opendaylight.yangtools</groupId>
                        <artifactId>maven-sal-api-gen-plugin</artifactId>
                        <version>${yangtools.version}</version>
                    </dependency>
                </dependencies>
            </plugin>
</pre>

This will generate Java files  and place them in ''src/main/yang-gen-config'' and ''src/main/yang-gen-sal'' folders.
* The generated files to note, located in ''generated-sources/config'' folders are ''ToasterProviderModule.java'' respectively ''ToasterConsumerModule.java'', these are initially generated but once manually edited they don't get overwritten by the code generator. 


* The '''createInstance()'''  method of the generated file is implemented manually, and this is where the dependencies methods mentioned in the [[#Dependencies with MD-SAL| Dependencies with MD-SAL]] section are manually added.

== The unit test ==
The toaster example contains a unit test located under the''sample-toaster-it'' project, ''src/main/test'' folder.
=== Controller configuration ===
* It uses the Pax Exam to define a configuration of the controller in the OSGI container. This loads the minimum required bundles, standard MD-SAL bundles 
*  +  Toaster bundles:
<pre>           
                mavenBundle("org.opendaylight.controller.samples", "sample-toaster-provider").versionAsInProject(),
                mavenBundle("org.opendaylight.controller.samples", "sample-toaster-consumer").versionAsInProject(),
                mavenBundle("org.opendaylight.controller.samples", "sample-toaster").versionAsInProject()
</pre>

=== Testing Consumer API through OSGI ===
The '''createToast''' is invoked:
<pre>toastConsumer.createToast(HashBrown.class, 4);</pre>
=== Calling Consumer  RPC  exposed to config-subsystem ===
The 'special' RPC '''make-hash-brown-toast-rpc''' declared in the ''toaster-consumer-impl.yang'' is invoked through JMX:
<pre>platformMBeanServer.invoke(consumerOn, "makeHashBrownToast", ...);</pre>
=== Getting Provider Runtime data exposed to config-subsystem ===
The '''toasts-made''' declared in the ''toaster-provider-impl.yang'' is accessed through JMX:
<pre>platformMBeanServer.getAttribute(providerOn, "ToastsMade");</pre>

==Making Some Toast - i.e. Running the Toaster==
There are four bundles providing different functionality for the toaster.

To simply expose your toaster via rest conf and use the MD-SAL as a simple repository for config / data you only need to have the sample-toaster bundle deployed. To do this:

==== Start the Controller ====
*Build a controller and start it via the run.sh
*:''Note: All four toaster bundles are shipped automatically with the default controller distribution. You can delete the sample-toaster bundles from the controller/opendaylight/distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight/plugins directory if you want only load the required bundle.
====Create a toaster via Restconf====
To create the controller you will do a REST post (you will need a rest client such as PostMan for google chrome).
:<code>HTTP Method => POST
 URL => http://localhost:8080/restconf/config 
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster:toaster" :
    {
      "toaster:toasterManufacturer" : "General Electric",
      "toaster:toasterModelNumber" : "123",
      "toaster:toasterStatus" : "up"
     }
 }
 </code>
:''Note: You will likely see an exception on the OSGi terminal, and the return error code will be a 204, "No data returned". This means it succeeded!''
==== Get the existing toaster via Restconf ====
To get the current toaster via REST conf you will do an HTTP get.
:<code>HTTP Method => GET
 URL => http://localhost:8080/restconf/config/toaster:toaster 
 </code>
This should return json defining the toaster, and should provide similar values to what you posted.
==== Modify the existing toaster ====
:<code>HTTP Method => PUT
 URL => http://localhost:8080/restconf/config/toaster:toaster
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster:toaster" :
    {
      "toaster:toasterManufacturer" : "kkoushik",
      "toaster:toasterModelNumber" : "123",
      "toaster:toasterStatus" : "up"
     }
 }
 </code>
====To Delete the Toaster====
To delete the current toaster via REST conf you will do an HTTP DELETE.
:<code>HTTP Method => DELETE
 URL => http://localhost:8080/restconf/config/toaster:toaster 
 </code>
==== To Make Toast (i.e. invoke the make-toast rpc call)====
To make toast via the Restconf you will perform an HTTP POST to an operations URL.
:<code>HTTP Method => POST
 URL => http://localhost:8080/restconf/operations/toaster:make-toast 
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
   "input" :
   {
      "toaster:toasterDoneness" : "10",
      "toaster:toasterToastType":"wheat-bread" 
   }
 }
 </code>
''even thought the toast type is defaulted in the yang model, you still have to provide it.''
====To Cancel Toast (i.e. invoke the cancel-toast which hs no arguments)====
To cancel toast is very similar to make toast, except you need to REMOVE the content-type header. If you provide it there is a bug that will route the call to the wrong http method which expects valid input arguments. Also note an additional bug will actually still result in an exception being returned to REST, however the cancelToast method will now actually get called.
