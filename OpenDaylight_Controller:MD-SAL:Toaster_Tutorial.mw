== Overview ==
This tutorial presents a walk through of the [https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL MD-SAL] based example of the Toaster capability ( this  capability comes from the [http://www.netconfcentral.org/modulereport/toaster YANG module toaster.yang ] schema).
== Objective ==
The main objective is to provide the reader a better understanding of the MD-SAL infrastructure within the OpenDaylight controller. 
The Toaster sample implementation is a suitable example because it provides the model of a programmable toaster, a sample consumer application that uses MD-SAL APIs, a sample service provider that implements Toaster, and a unit test suite.

== Overview of Yang ==
If you are new to Yang, the below links contain various overviews that you may find useful.

*Yang Central: http://www.yang-central.org/twiki/bin/view/Main/YangDocuments - the first section  lists a bunch of tutorials.
*Netconf Central: http://www.netconfcentral.org/ - this is more netconf oriented, but still contains useful information
*Tail-F: a fairly good paper: http://www.tail-f.com/wordpress/wp-content/uploads/2013/02/Tail-f-Presentation-Netconf-Yang.pdf
*http://www.slideshare.net/tailfsystems/netconf-yang-tutorial
*A bunch of interesting netconf/yang pointers: http://trac.tools.ietf.org/wg/netconf/trac/wiki

== Toaster Step-By-Step==
We are putting together documentation where we build up the toaster from scratch to cover different scenarios ( much like the [https://wiki.opendaylight.org/view/Ping Ping] example ). 

The below remaining documentation provides an overview of the complete toaster example, along with instructions on how to interact with the pre-built toaster in the product.

This page will help provide context about what code needs to be added / modified depending on what you want to accomplish. If you would like to see how we can progress from a simple Toaster model, to an advanced modeling structure, head over to [[OpenDaylight Controller:MD-SAL:Toaster Step-By-Step]]

== Prerequisites ==
The Toaster example is part of the OpenDaylight controller, so in order to access the source code with its dependencies please check [https://wiki.opendaylight.org/view/OpenDaylight_Controller:Installation ODL Installation Guide]

It's located in ''controller.git'' under ''opendaylight/md-sal/samples''.

== Structure ==
We will address three contexts in this tutorial:
# Data Model and SAL API Context - presents the correlation between the Toaster Yang Model and the generated MD-SAL API
# Plugin Context -  introduces the provider and consumer and interaction with MD-SAL services
# Config-subsystem Context

== Data Model and SAL API Context ==
=== API Types ===

MD-SAL provides three API types:

* Java generated APIs :
:*The functionality of the toaster from our example is based on Java generated APIs. From the Toaster's yang data model, the MD-SAL will generate a set of Java APIs against which the ''provider'' and ''consumer'' plugins will be developed.
* DOM APIs - these are mostly used by infrastucture components and are usuful for XML-driven plugin and application types
* REST APIs - [[OpenDaylight Controller:MD-SAL:Restconf|Restconf]] - these APIs are available to consumer type applications and provides access to RPC and data stores:
:*This documentation includes an example describing how the toaster's functionality can be accessed through the RESTCONF API.

=== Yang definition for Toaster ===
The definition of the Toaster capability is defined by it's yang data model ; the file is located in the ''sample-toaster'' project in: ''src/main/yang/toaster.yang''

The yang schema defines the toaster service (YANG RPCs), the toaster description and state data (YANG Container), notifications from the toaster (YANG Notifications): 
# DATA definitions for toaster: (YANG: ''container toaster'')
#* (YANG: ''leaf toasterManufacturer'')
#* (YANG: ''leaf toasterModelNumber'')
#* (YANG: ''leaf toasterStatus'')
# SERVICE RPCs: operations that can be done, they are defined through RPCs, there are two available:
#* (YANG: ''rpc make-toast'') taking input parameters:
#** (YANG: ''leaf toasterDoneness'')
#** (YANG: ''leaf toasterToastType'')
#* (YANG: ''rpc cancel-toast'')
# NOTIFICATIONS: 
#* (YANG: ''notification toastDone'')

=== MD-SAL generated APIs definitions ===


In our example, the API that covers the toaster functionality (the Java generated API, we will refer to it as the  'Toaster SAL API') is generated from the Toaster Yang model using the [https://wiki.opendaylight.org/view/YANG_Tools YANG Tools]. 
:: this is achieved through the ''yang-maven-plugin'' which uses the ''org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl'' code generator, called from the ''sample-toaster'' project build phase - section of the project's POM file: 
<code>

              <plugin>
                <groupId>org.opendaylight.yangtools</groupId>
                <artifactId>yang-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <goals>
                            <goal>generate-sources</goal>
                        </goals>
                        <configuration>
                            <yangFilesRootDir>src/main/yang</yangFilesRootDir>
                            <codeGenerators>
                                <generator>
                                    <codeGeneratorClass>
                                        org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl
                                    </codeGeneratorClass>
                                    <outputBaseDir>
                                        ${salGeneratorPath}
                                    </outputBaseDir>
                                </generator>
                            </codeGenerators>
                            <inspectDependencies>true</inspectDependencies>
                        </configuration>
                    </execution>
                </executions>
                <dependencies>
                    <dependency>
                        <groupId>org.opendaylight.yangtools</groupId>
                        <artifactId>maven-sal-api-gen-plugin</artifactId>
                        <version>${yangtools.version}</version>
                        <type>jar</type>
                    </dependency>
                </dependencies>
            </plugin>
</code>                
            
* the resulting generated SAL APIs are stored under '''src/main/yang-gen-sal'' (for a complete guide of the code generator mappings see [[https://wiki.opendaylight.org/view/YANG_Tools:YANG_to_Java_Mapping Yang to Java Mapping]])
:: the generated JAVA files contain interfaces and abstract classes (not all of them will be listed below, but those which reflect the correlation with the Yang model described in the Yang definition section above) :
::* '''interface ToasterData extends DataRoot''' (''Toaster.java'')  <- DATA definitions for toaster
::* '''interface ToasterService extends RpcService''' (''ToasterService.java'') <- SERVICE RPCs 
::* '''interface ToasterListener extends NotificationListener''' (''ToasterListener.java'') <- NOTIFICATIONS

=== API OSGI bundle ===
Upon running a build of the ''sample-toaster'' project, the generated SAL APIs are bundled by maven creating an OSGI bundle, which will be referred as the 'API OSGI bundle'.


== Plugin Context ==

=== Toaster Provider ===
The set of JAVA interfaces (constituting the SAL API) generated from the Toaster's Yang data model in the previous section must be implemented, and this is the point where the '''provider plugin''' ( the ''toaster-provider'' project) comes into play.
: We basically need a plugin that:
* implements the generated interfaces ( in our case this is done by the '''OpendaylightToaster.java''', this is done manually) , and
* provides the 'wiring' with the rest of the ODL through the config-subsystem  ( in our case this is done by the '''ToasterProviderModule.java''' , file is generated once, and further completed manually  - more details on are presented in the [[[https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Toaster_Tutorial#Config-subsystem_Context | Config-subsystem_Context]]])

Below we highlight the implemented RPCs and notifications from the toaster that are being published:
* the OpendaylightToaster class:

<code>
   ''' public class OpendaylightToaster implements '''ToasterService,''' AutoCloseable {  
   '''   .....
</code> 
* The makeToast(...) RPC implementation with a following 'toastDone' notification being sent:
<code>
   '''@Override
   '''public Future<RpcResult<Void>> makeToast(MakeToastInput input) {
   '''    ...
   '''    currentTask = executor.submit(new MakeToastTask(input));
   '''    ...
   '''    return currentTask;
   '''}
   ''' ...
   ''' private class MakeToastTask implements Callable<RpcResult<Void>> {
   '''
   '''        final MakeToastInput toastRequest;
   '''
   '''        public MakeToastTask(MakeToastInput toast) {
   '''            toastRequest = toast;
   '''        }
   '''
   '''        @Override
   '''        public RpcResult<Void> call() throws InterruptedException {
   '''            ...
   '''            notifyBuilder.setToastStatus(ToastStatus.Done);
   '''            notificationProvider.publish(notifyBuilder.build());
   '''            ...
   '''            toastsMade.incrementAndGet();
   '''           ...
   '''
   '''            return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
   '''        }
   '''    }   
  '''  } 
</code>
* the cancelToast() RPC implementation with a following 'toastDone' notification being sent: 
<code>  
   '''@Override
   '''public Future<RpcResult<Void>> cancelToast() {
   '''    ...
   '''    cancelToastImpl();
   '''    ...
   '''    return Futures.immediateFuture(Rpcs.<Void> getRpcResult(true, Collections.<RpcError> emptySet()));
   '''}
   '''       private void cancelToastImpl() {
   '''        currentTask.cancel(true);
   '''        ToastDoneBuilder toastDone = new ToastDoneBuilder();
   '''        toastDone.setToastStatus(ToastStatus.Cancelled);
   '''        notificationProvider.publish(toastDone.build());
   '''    }
</code>

=== Toaster Consumer ===
  <to be filled on Thursday the 16th of April>

=== Diagram ===
[[File:ToasterProviderConsumer.jpg]]

== Config-subsystem Context ==
In order to get the full benefits of the ODL Controller's subsystem (for example access through JMX or NETCONF to the available ''toaster'' services and run-time related data), the toaster provider and consumer plugins in our example have been configured as subsystem modules. This configuration is done as a YANG module definition per each plugin, each configuration specifies the dependencies between our plugins and the rest of ODL (mainly with MD-SAL infrastructure services):
=== Definitions of module-type in YANG  ===
Each configuration file appears as a '''module''' definition (files are located in ''src/main/yang'' folders).

* '''module-type''' declaration (in ''toaster-provider-impl.yang'')::
<pre>
identity toaster-provider-impl {
            base config:module-type;
            config:provided-service toaster-provider:toaster-provider;
            config:java-name-prefix ToasterProvider;
    }
</pre>

* '''module-type''' declaration (in ''toaster-consumer-impl.yang'')::
<pre>
identity toaster-consumer-impl {
            base config:module-type;
            config:provided-service toaster-consumer:toaster-consumer;
            config:java-name-prefix ToasterConsumer;
    }
</pre>

=== Dependencies with MD-SAL  ===
As mentioned in the above section, the main purpose of creating the module's configuration files is to specify dependencies between our Toaster plugins and MD-SAL. 

Both the Toaster-Consumer and Toaster-Provider have 'dependencies' on MD-SAL infrastructure services.
We'll list the types of dependencies involved in our Toaster example:


==== RpcRegistry dependency ====
* Toaster-Provider implements RPCs (ToasterService RPCs) from the generated SAL API, so these implementations have to be  registered with MD-SAL: 
<pre>getRpcRegistryDependency().addRpcImplementation(ToasterService.class, opendaylightToaster);</pre>

* Toaster-Consumer, in order to access the ToasterService instance from MD-SAL uses <pre>getRpcRegistryDependency().getRpcService(ToasterService.class);</pre>

==== NotificationService dependency ====
* Toaster-Provider sends notifications through MD-SAL, so it registers through
<pre>
setNotificationProvider(getNotificationServiceDependency());
</pre>

* Toaster-Consumer, in order to receive notifications from the provider through MD-SAL registers through 
<pre>
getNotificationServiceDependency().registerNotificationListener(ToastDone.class, consumer);
</pre>

==== DataBroker dependency ====
The Toaster-Provider uses the MD-SALs DataBrokerService to write state data to the DataStore , the dependency on this service is through
<pre>
setDataProvider(getDataBrokerDependency());
</pre>

=== Dependencies as Augmentations in YANG ===
The dependencies mentioned in the previous section must be specified in the module configuration yang files, as an '''augment''' of the '''config:configuration''':
* Toaster-Provider (''toaster-provider-impl.yang'')
<pre>
augment "/config:modules/config:module/config:configuration" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";

            container rpc-registry {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-rpc-registry;
                    }
                }
            }

            container notification-service {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-notification-service;
                    }
                }
            }
            container data-broker {
                uses config:service-ref {
                    refine type {
                        mandatory false;
                        config:required-identity mdsal:binding-data-broker;
                    }
                }
            }

           
        }
</pre>
* Toaster-Consumer (''toaster-consumer-impl.yang'')
<pre>
augment "/config:modules/config:module/config:configuration" {
        case toaster-consumer-impl {
            when "/config:modules/config:module/config:type = 'toaster-consumer-impl'";

            container rpc-registry {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-rpc-registry;
                    }
                }
            }

            container notification-service {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-notification-service;
                    }
                }
            }

        }
    }
</pre>

'''For a detailed walk-through on how to make a 'config-subsystem aware' project please visit''' https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Examples:Sample_Project

=== Extra configuration ===
Our Toaster example (for demo purposes) has been designed to have some additional features:
* Toaster Provider provides access through JMX/config-subsystem to some additional data -  '''toasts-made''', this is achieved by augmenting the '''config-state''' in ''toaster-provider-impl.yang'':
<pre>
augment "/config:modules/config:module/config:state" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";

            leaf toasts-made {
                type uint32;
            }

        }
    }
</pre>
* Toaster Consumer provides access through JMX/config-subsystem to a specific RPC - '''make-hash-brown-toast-rpc''', this is achieved by augmenting the config-state in ''toaster-consumer-impl.yang'':

<pre>
augment "/config:modules/config:module/config:state" {
        case toaster-consumer-impl {
            when "/config:modules/config:module/config:type = 'toaster-consumer-impl'";
            rpcx:rpc-context-instance "make-hash-brown-toast-rpc";
        }
    }

    identity make-hash-brown-toast-rpc;

    rpc make-hash-brown-toast {
        input {
            uses rpcx:rpc-context-ref {
                refine context-instance {
                    rpcx:rpc-context-instance make-hash-brown-toast-rpc;
                }
            }
            leaf doneness {
                type uint16;
            }
        }
        output {
            leaf result {
                type boolean;
            }
        }
    }
</pre>

=== Generated Java classes ===

The Yang files   
* ''toaster-provider-impl.yang'' and 
* ''toaster-consumer-impl.yang''
are converted to java files from which Java code for configuration system is generated by yang-maven-plugin and yang-jmx-generator-plugin.

To run the converter , the below code has to be added to the (''toaster-provider'' and ''toaster-consumer'' projects) POM files:
<pre>
            <plugin>
                <groupId>org.opendaylight.yangtools</groupId>
                <artifactId>yang-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>config</id>
                        <goals>
                            <goal>generate-sources</goal>
                        </goals>
                        <configuration>
                            <codeGenerators>
                                <generator>
                                    <codeGeneratorClass>
                                        org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
                                    </codeGeneratorClass>
                                    <outputBaseDir>${jmxGeneratorPath}</outputBaseDir>
                                    <additionalConfiguration>
                                        <namespaceToPackage1>
                                            urn:opendaylight:params:xml:ns:yang:controller==org.opendaylight.controller.config.yang
                                        </namespaceToPackage1>
                                    </additionalConfiguration>
                                </generator>
                                <generator>
                                    <codeGeneratorClass>
                                        org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl
                                    </codeGeneratorClass>
                                    <outputBaseDir>
                                        ${salGeneratorPath}
                                    </outputBaseDir>
                                </generator>
                            </codeGenerators>
                            <inspectDependencies>true</inspectDependencies>
                        </configuration>
                    </execution>
                </executions>
                <dependencies>
                    <dependency>
                        <groupId>org.opendaylight.controller</groupId>
                        <artifactId>yang-jmx-generator-plugin</artifactId>
                        <version>${config.version}</version>
                    </dependency>
                    <dependency>
                        <groupId>org.opendaylight.yangtools</groupId>
                        <artifactId>maven-sal-api-gen-plugin</artifactId>
                        <version>${yangtools.version}</version>
                    </dependency>
                </dependencies>
            </plugin>
</pre>

This will generate Java files  and place them in ''src/main/yang-gen-config'' and ''src/main/yang-gen-sal'' folders.
* The generated files to note, located in ''generated-sources/config'' folders are ''ToasterProviderModule.java'' respectively ''ToasterConsumerModule.java'', these are initially generated but once manually edited they don't get overwritten by the code generator. 


* The '''createInstance()'''  method of the generated file is implemented manually, and this is where the dependencies methods mentioned in the [[#Dependencies with MD-SAL| Dependencies with MD-SAL]] section are manually added.

== The unit test ==
The toaster example contains a unit test located under the''sample-toaster-it'' project, ''src/main/test'' folder.
=== Controller configuration ===
* It uses the Pax Exam to define a configuration of the controller in the OSGI container. This loads the minimum required bundles, standard MD-SAL bundles 
*  +  Toaster bundles:
<pre>           
                mavenBundle("org.opendaylight.controller.samples", "sample-toaster-provider").versionAsInProject(),
                mavenBundle("org.opendaylight.controller.samples", "sample-toaster-consumer").versionAsInProject(),
                mavenBundle("org.opendaylight.controller.samples", "sample-toaster").versionAsInProject()
</pre>

=== Testing Consumer API through OSGI ===
The '''createToast''' is invoked:
<pre>toastConsumer.createToast(HashBrown.class, 4);</pre>
=== Calling Consumer  RPC  exposed to config-subsystem ===
The 'special' RPC '''make-hash-brown-toast-rpc''' declared in the ''toaster-consumer-impl.yang'' is invoked through JMX:
<pre>platformMBeanServer.invoke(consumerOn, "makeHashBrownToast", ...);</pre>
=== Getting Provider Runtime data exposed to config-subsystem ===
The '''toasts-made''' declared in the ''toaster-provider-impl.yang'' is accessed through JMX:
<pre>platformMBeanServer.getAttribute(providerOn, "ToastsMade");</pre>

==Making Some Toast - i.e. Running the Toaster==
There are four bundles providing different functionality for the toaster.

To simply expose your toaster via rest conf and use the MD-SAL as a simple repository for config / data you only need to have the sample-toaster bundle deployed. To do this:

==== Start the Controller ====
*Build a controller and start it via the run.sh
*:''Note: All four toaster bundles are shipped automatically with the default controller distribution. You can delete the sample-toaster bundles from the controller/opendaylight/distribution/opendaylight/target/distribution.opendaylight-osgipackage/opendaylight/plugins directory if you want only load the required bundle.
====Create a toaster via Restconf====
To create the controller you will do a REST post (you will need a rest client such as PostMan for google chrome).
:<code>HTTP Method => POST
 URL => http://localhost:8080/restconf/config 
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster:toaster" :
    {
      "toaster:toasterManufacturer" : "General Electric",
      "toaster:toasterModelNumber" : "123",
      "toaster:toasterStatus" : "up"
     }
 }
 </code>
:''Note: You will likely see an exception on the OSGi terminal, and the return error code will be a 204, "No data returned". This means it succeeded!''
==== Get the existing toaster via Restconf ====
To get the current toaster via REST conf you will do an HTTP get.
:<code>HTTP Method => GET
 URL => http://localhost:8080/restconf/config/toaster:toaster 
 </code>
This should return json defining the toaster, and should provide similar values to what you posted.
==== Modify the existing toaster ====
:<code>HTTP Method => PUT
 URL => http://localhost:8080/restconf/config/toaster:toaster
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster": {
        "toasterStatus": "up",
        "toasterManufacturer": "kkoushik",
        "toasterModelNumber": "123"
    }
 }
 </code>

====To Delete the Toaster====
To delete the current toaster via REST conf you will do an HTTP DELETE.
:<code>HTTP Method => DELETE
 URL => http://localhost:8080/restconf/config/toaster:toaster 
 </code>
==== To Make Toast (i.e. invoke the make-toast rpc call)====
To make toast via the Restconf you will perform an HTTP POST to an operations URL.
:<code>HTTP Method => POST
 URL => http://localhost:8080/restconf/operations/toaster:make-toast 
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
   "input" :
   {
      "toaster:toasterDoneness" : "10",
      "toaster:toasterToastType":"wheat-bread" 
   }
 }
 </code>
''even thought the toast type is defaulted in the yang model, you still have to provide it.''
====To Cancel Toast (i.e. invoke the cancel-toast which hs no arguments)====
You may want to cancel the make-toast operation part of the way through! You do this by invoking a restconf REST call in a very similar way as you invoke the make-toast.
<pre>
URL => http://localhost:8080/restconf/operations/toaster:cancel-toast
HTTP Method => POST
</pre>

Note: There is a bug in the way the RestconfImpl class processes / routes the REST requests. If you define the Content-Type header, then the rest call is routed to a method which expects a non-empty body. In this case though we don't have any input, so our body should be empty. Thus an exception is thrown. In order to make the cancel-toast call work successfully, you need to invoke the above call, with NO content-type define. By doing that you route the request to a different method, which expects an empty body.<br>
Note 2: When you successfully invoke this call with no headers, you will still get an error. This is due to a null future being returned in our implementation above. You can though put a breakpoint in the cancel toast call at this point and have that breakpoint activated.
