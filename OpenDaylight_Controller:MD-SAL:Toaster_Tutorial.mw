= Overview =
This tutorial presents a walk through of the [https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL MD-SAL] based example of the Toaster capability ( this  capability comes from the [http://www.netconfcentral.org/modulereport/toaster YANG module toaster.yang ] schema).

= Objective =
The main objective is to provide the reader a better understanding of the MD-SAL infrastructure within the OpenDaylight controller. 
The Toaster sample implementation is a suitable example because it provides the model of a programmable toaster, a sample consumer application that uses MD-SAL APIs, a sample service provider that implements Toaster, and a unit test suite.

= Overview of Yang =
If you are new to Yang, the below links contain various overviews that you may find useful.

*Yang Central: http://www.yang-central.org/twiki/bin/view/Main/YangDocuments - the first section  lists a bunch of tutorials.
*Netconf Central: http://www.netconfcentral.org/ - this is more netconf oriented, but still contains useful information
*Tail-F: a fairly good paper: http://www.tail-f.com/wordpress/wp-content/uploads/2013/02/Tail-f-Presentation-Netconf-Yang.pdf
*http://www.slideshare.net/tailfsystems/netconf-yang-tutorial
*A bunch of interesting netconf/yang pointers: http://trac.tools.ietf.org/wg/netconf/trac/wiki

= Toaster Step-By-Step=
We are putting together documentation where we build up the toaster from scratch to cover different scenarios ( much like the [https://wiki.opendaylight.org/view/Ping Ping] example ). 

The below documentation isn't a guide on how to write the toaster example from scratch. It provides an overview of the toaster example architecture, explanation of the API, the description of individual plugins, their configuration and interaction with the MD-SAL.

This page will help provide context about what code and configuration needs to be considered when you plan to develop your own application / plugin within ODL.

If you would like to see how we can progress from a simple Toaster model, to an advanced modeling structure, head over to [[OpenDaylight Controller:MD-SAL:Toaster Step-By-Step]]

= Prerequisites =
The Toaster example is part of the OpenDaylight controller, so in order to access the source code with its dependencies please check [https://wiki.opendaylight.org/view/OpenDaylight_Controller:Installation ODL Installation Guide]

It's located in ''controller.git'' under ''opendaylight/md-sal/samples''.

= Structure =
We will address four contexts in this tutorial:
# Toaster's YANG Data Model - we have the model, where do we move from here ?
# Binding Aware Context -  the generated MD-SAL API, the binding aware provider and consumer and interaction with MD-SAL services
# Binding Independent Context -  the RESTConf API and interaction with DataStore
# Config-subsystem Context - plugin-level and system-level configurations

= YANG Data Model of Toaster =
The definition of the Toaster capability is defined by it's yang data model ; the file is located in the ''sample-toaster'' project in: ''src/main/yang/toaster.yang''

The yang schema defines the toaster service (YANG RPCs), the toaster description and state data (YANG Container), notifications from the toaster (YANG Notifications): 
# DATA definitions for toaster: (YANG: ''container toaster'')
#* (YANG: ''leaf toasterManufacturer'')
#* (YANG: ''leaf toasterModelNumber'')
#* (YANG: ''leaf toasterStatus'')
# SERVICE RPCs: operations that can be done, they are defined through RPCs, there are two available:
#* (YANG: ''rpc make-toast'') taking input parameters:
#** (YANG: ''leaf toasterDoneness'')
#** (YANG: ''leaf toasterToastType'')
#* (YANG: ''rpc cancel-toast'')
# NOTIFICATIONS: 
#* (YANG: ''notification toastDone'')

Now that we have defined the functionality that has to be implemented, we have to consider the type of APIs that will have to be created:

== API Types ==

MD-SAL provides three API types:

* Java generated APIs : 

:In our example, from the Toaster's yang data model, the MD-SAL will generate a set of Java APIs against which the ''provider'' and ''consumer'' plugins will be developed. 

* DOM APIs - these are mostly used by infrastructure components and are useful for XML-driven plugin and application types
* REST APIs - [[OpenDaylight Controller:MD-SAL:Restconf|Restconf]] - these APIs are available to consumer type applications and provides access to RPC and data store - consumers invoke RPCs by invoking POST operation to /restconf/operations/model-name:rpc-name. Notifications aren't currently supported. We'll show how to invoke toaster's RPCs through the RESTCONF API in the Binding Independent context section.


== Binding Aware vs Binding Independent ==

All providers and consumers that use Java generated APIs, whether they implement (providers) or make use of implemented functionality (consumers) are denoted as '''binding aware'''. 

In our toaster example, we'll develop: 
* one '''binding aware''' provider (implementing the toaster service declared in the generated API) and 
* one '''binding aware''' consumer, which uses the service implemented by the above '''binding aware''' provider.

Binding independent consumers and providers are those which are not developed against a Java generated API, but use the Binding Independent Data format. This format is basically a '''normalized''' data tree derived/mapped (during system startup, when the ''.yang'' file is loaded ) from the YANG schema :
* Simple Nodes  - these are mappings of Yang ''leaf'' and items in a ''leaf-list''
* Composite Nodes -  these are mappings of Yang ''container'' and items in a ''list'' 

MD-SAL provides the infrastructure necessary to address the individual data tree nodes both from within binding aware and binding independent components through '''instance identifiers'''. The instance identifier is basically the '''path''' to a specific node in the data tree. In our example we'll use the instance identifier to update the status of the toaster in the data store.

The MD-SAL Data Store can be viewed as a '''binding independent''' provider that holds data (the state of the system, so it stores ''instances of classes not classes'' ) in the binding independent data format. 

When ODL loads a bundle it searches that bundle (JAR) for files that end in “*.yang”. For each YANG file found it processes that file and builds several things dynamically including the structures to expose that as a RESTCONF compliant YANG interface.

In our toaster example, we'll see that we can access through RESTConf the individual toaster container items mapped from the YANG model( perform Create/Retrieve/Update/Delete -CRUD- operations on the toaster container)  and even invoke the toaster's RPCs in the form of POST http requests.

= Binding Aware context =

== Generated APIs and the Binding Model ==

:In our example, the API that covers the toaster functionality (the Java generated API, we will refer to it as the  'Toaster SAL API') is generated from the Toaster Yang model using the [https://wiki.opendaylight.org/view/YANG_Tools YANG Tools]. 
:This is achieved by using the ''yang-maven-plugin'' with the ''org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl'' code generator, called from the ''sample-toaster'' project build phase - section of the project's POM file: 
<code>

              <plugin>
                <groupId>org.opendaylight.yangtools</groupId>
                <artifactId>yang-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <goals>
                            <goal>generate-sources</goal>
                        </goals>
                        <configuration>
                            <yangFilesRootDir>src/main/yang</yangFilesRootDir>
                            <codeGenerators>
                                <generator>
                                    <codeGeneratorClass>
                                        org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl
                                    </codeGeneratorClass>
                                    <outputBaseDir>
                                        ${salGeneratorPath}
                                    </outputBaseDir>
                                </generator>
                            </codeGenerators>
                            <inspectDependencies>true</inspectDependencies>
                        </configuration>
                    </execution>
                </executions>
                <dependencies>
                    <dependency>
                        <groupId>org.opendaylight.yangtools</groupId>
                        <artifactId>maven-sal-api-gen-plugin</artifactId>
                        <version>${yangtools.version}</version>
                        <type>jar</type>
                    </dependency>
                </dependencies>
            </plugin>
</code>                
            
* the resulting generated SAL APIs are stored under '''src/main/yang-gen-sal'' (for a complete guide of the code generator mappings see [[https://wiki.opendaylight.org/view/YANG_Tools:YANG_to_Java_Mapping Yang to Java Mapping]])
*The ''src/main/yang/toaster.yang'' file is copied to ''target/classes/META-INF/yang/toaster.yang''. 
*The ''org.opendaylight.yangtools.yang.binding.YangModelBindingProvider'' file is generated in ''target/classes/META-INF/services'' and contains the fully-qualfied name of the toaster's generated '''$YangModelBindingProvider''' class. This will be used by the MD-SAL's '''ModuleInfoBundleTracker''' class in the config subsystem (more details on this in the Config subsystem context section).

=== MD-SAL Bindings ===
The generated JAVA files constitute the Bindings that MD-SAL uses as part of its [https://wiki.opendaylight.org/view/OpenDaylight_Controller:Binding_Model Binding Model]. This is referred as 'Consumer & Provider binding' – A subset of the binding model which is directly visible to 'binding aware' Consumers and Providers.

There are three types of files that make up the binding:
:* Data Transfer Objects represent the instances of data nodes defined by YANG Schema and are used to store and transfer data (in our example ''Toaster'',''ToastDone'',''MakeToastInput'')
::* '''interface ToasterData extends DataRoot''' (''Toaster.java'')  <- DATA definitions for toaster
:* DTO Builders are objects that create DTOs (in our example ''ToasterBuilder'',''ToastDoneBuilder'',''MakeToastInputBuilder'')
:* RPC interfaces represent the programmatic API to invoking RPCs (in our example ''ToasterService'')
::* '''interface ToasterService extends RpcService''' (''ToasterService.java'') <- SERVICE RPCs
:* Listener interfaces:
::* '''interface ToasterListener extends NotificationListener''' (''ToasterListener.java'') <- NOTIFICATIONS

=== API OSGI bundle ===
Upon running a build of the ''sample-toaster'' project, the generated SAL APIs are bundled by maven creating an OSGI bundle, which will be referred as the 'API OSGI bundle'.

== Toaster Provider ==
==== The API ====
The set of generated JAVA interfaces (constituting the SAL API) from the Toaster's Yang data model (previous section) must be implemented, and this is the point where the '''provider plugin''' ( the ''sample-toaster-provider'' maven project) comes into play:

==== The Plugin ====
: We basically need a plugin that:
* implements the generated interfaces (OpendaylightToaster class, this class is done manually / not a generated class) , and
* provides the 'wiring' with the rest of the ODL through the config-subsystem  ( in our case this is done by the '''ToasterProviderModule.java''' , this file is generated once, and further completed manually  - more details on are presented in the [https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Toaster_Tutorial#Config-subsystem_Context  Config Subsystem Context ])

Below we highlight the implemented RPCs and notifications from the toaster that are being published:
* the OpendaylightToaster class:

<code>
   ''' public class OpendaylightToaster implements '''ToasterService,''' AutoCloseable {  
   '''   .....
</code> 
* The makeToast(...) RPC implementation with a following 'ToastStatus.Done' notification being sent:
<code>
   '''@Override
   '''public Future<RpcResult<Void>> makeToast(MakeToastInput input) {
   '''    ...
   '''    currentTask = executor.submit(new MakeToastTask(input));
   '''    ...
   '''    return currentTask;
   '''}
   ''' ...
   ''' private class MakeToastTask implements Callable<RpcResult<Void>> {
   '''
   '''        final MakeToastInput toastRequest;
   '''
   '''        public MakeToastTask(MakeToastInput toast) {
   '''            toastRequest = toast;
   '''        }
   '''
   '''        @Override
   '''        public RpcResult<Void> call() throws InterruptedException {
   '''            ...
   '''            notifyBuilder.setToastStatus(ToastStatus.Done);
   '''            notificationProvider.publish(notifyBuilder.build());
   '''            ...
   '''            toastsMade.incrementAndGet();
   '''           ...
   '''
   '''            return Rpcs.<Void> getRpcResult(true, null, Collections.<RpcError> emptySet());
   '''        }
   '''    }   
  '''  } 
</code>
* the cancelToast() RPC implementation with a following 'ToastStatus.Cancelled' notification being sent: 
<code>  
   '''@Override
   '''public Future<RpcResult<Void>> cancelToast() {
   '''    ...
   '''    cancelToastImpl();
   '''    ...
   '''    return Futures.immediateFuture(Rpcs.<Void> getRpcResult(true, Collections.<RpcError> emptySet()));
   '''}
   '''       private void cancelToastImpl() {
   '''        currentTask.cancel(true);
   '''        ToastDoneBuilder toastDone = new ToastDoneBuilder();
   '''        toastDone.setToastStatus(ToastStatus.Cancelled);
   '''        notificationProvider.publish(toastDone.build());
   '''    }
</code>
==== Provider plugin - what has been achieved ? ====
Once the Toaster provider bundle has been deployed, we can 'use' the Toaster Service: both 
* through RESTCONF ( REST API) , and
* programatically ( as a Consumer plugin).

The next section - the Toaster Consumer shows how we can access the Toaster Service programatically.

== Toaster Consumer ==
The toaster consumer plugin uses the Toaster Service (API) implemented by the ''toaster provider'' to create a new service (API). 
This is in fact an example of 'service chaining' where a consumer using a provider, becomes itself a provider of another service.
==== The API ====

The new service  ( defined in the KitchenService API ''org.opendaylight.controller.sample.kitchen.api'' ) defines a new method '''makeBreakfast''' that uses '''makeToast''' from the Toaster Service API:
<pre>
public interface KitchenService {
  
    boolean makeBreakfast( EggsType eggs, Class<? extends ToastType> toast, int toastDoneness );
   
}
</pre>
Note that the makeBreakfast service includes also ''eggs'', on top of the toast, for example the ''eggs'' could be made by another 'EggsService' defined similarly as the Toaster Service.

==== The Plugin ====
* implements the KitchenService interface (KitchenServiceImpl class, this class is created manually / not a generated class) , and
* provides the 'wiring' with the rest of the ODL through the config-subsystem  ( in our case this is done by the '''KitchenServiceModule.java''' , this file is generated once, and further completed manually  - more details on are presented in the [https://wiki.opendaylight.org/view/OpenDaylight_Controller:MD-SAL:Toaster_Tutorial#Config-subsystem_Context  Config Subsystem Context ])

Below we highlight the '''makeBreakfast(...)''' method belonging to the KitchenService API, using the '''makeToast(...)''' RPC 

<pre>
public boolean makeBreakfast( EggsType eggs, Class<? extends ToastType> toast, int toastDoneness ) {

       ...
            RpcResult<Void> result = toaster.makeToast( toastInput.build() ).get();
       ...
            
            return result.isSuccessful();
    }
</pre>

== Diagram ==
[[File:updclass.png]]

= Binding Independent context =
==RESTConf and the DataStore ==



====Create a toaster via Restconf====
To create the controller you will do a REST post (you will need a rest client such as PostMan for google chrome).
:<code>HTTP Method => POST
 URL => http://localhost:8080/restconf/config 
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster:toaster" :
    {
      "toaster:toasterManufacturer" : "General Electric",
      "toaster:toasterModelNumber" : "123",
      "toaster:toasterStatus" : "up"
     }
 }
 </code>
:''Note: You will likely see an exception on the OSGi terminal, and the return error code will be a 204, "No data returned". This means it succeeded!''
==== Get the existing toaster via Restconf ====
To get the current toaster via REST conf you will do an HTTP get.
:<code>HTTP Method => GET
 URL => http://localhost:8080/restconf/config/toaster:toaster 
 </code>
This should return json defining the toaster, and should provide similar values to what you posted.
==== Modify the existing toaster ====
:<code>HTTP Method => PUT
 URL => http://localhost:8080/restconf/config/toaster:toaster
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
    "toaster": {
        "toasterStatus": "up",
        "toasterManufacturer": "kkoushik",
        "toasterModelNumber": "123"
    }
 }
 </code>

====To Delete the Toaster====
To delete the current toaster via REST conf you will do an HTTP DELETE.
:<code>HTTP Method => DELETE
 URL => http://localhost:8080/restconf/config/toaster:toaster 
 </code>
==== To Make Toast (i.e. invoke the make-toast rpc call)====
To make toast via the Restconf you will perform an HTTP POST to an operations URL.
:<code>HTTP Method => POST
 URL => http://localhost:8080/restconf/operations/toaster:make-toast 
 Header =>   Content-Type: application/yang.data+json  
 Body =>  
 {
   "input" :
   {
      "toaster:toasterDoneness" : "10",
      "toaster:toasterToastType":"wheat-bread" 
   }
 }
 </code>
''even thought the toast type is defaulted in the yang model, you still have to provide it.''
====To Cancel Toast (i.e. invoke the cancel-toast which hs no arguments)====
You may want to cancel the make-toast operation part of the way through! You do this by invoking a restconf REST call in a very similar way as you invoke the make-toast.
<pre>
URL => http://localhost:8080/restconf/operations/toaster:cancel-toast
HTTP Method => POST
</pre>

Note: There is a bug in the way the RestconfImpl class processes / routes the REST requests. If you define the Content-Type header, then the rest call is routed to a method which expects a non-empty body. In this case though we don't have any input, so our body should be empty. Thus an exception is thrown. In order to make the cancel-toast call work successfully, you need to invoke the above call, with NO content-type define. By doing that you route the request to a different method, which expects an empty body.<br>
Note 2: When you successfully invoke this call with no headers, you will still get an error. This is due to a null future being returned in our implementation above. You can though put a breakpoint in the cancel toast call at this point and have that breakpoint activated.

= Config-subsystem Context =
In order to get the full benefits of the ODL Controller's subsystem (for example access through JMX or NETCONF to the available ''toaster'' services and run-time related data), the toaster provider and consumer plugins in our example have been configured as subsystem modules. This configuration is done as a YANG module definition per each plugin, each configuration specifies the dependencies between our plugins and the rest of ODL (mainly with MD-SAL infrastructure services):
=== Configuring dependencies ( using... YANG)  ===
Each configuration file appears as a '''module''' definition (files are located in ''src/main/yang'' folders).

* '''module-type''' declaration (in ''toaster-provider-impl.yang'')::
<pre>
identity toaster-provider-impl {
            base config:module-type;
            config:provided-service toaster-provider:toaster-provider;
            config:java-name-prefix ToasterProvider;
    }
</pre>

* '''module-type''' declaration (in ''toaster-consumer-impl.yang'')::
<pre>
identity toaster-consumer-impl {
            base config:module-type;
            config:provided-service toaster-consumer:toaster-consumer;
            config:java-name-prefix ToasterConsumer;
    }
</pre>

=== Dependencies with MD-SAL  ===
As mentioned in the above section, the main purpose of creating the module's configuration files is to specify dependencies between our Toaster plugins and MD-SAL. 

Both the Toaster-Consumer and Toaster-Provider have 'dependencies' on MD-SAL infrastructure services.
We'll list the types of dependencies involved in our Toaster example:


==== RpcRegistry dependency ====
* Toaster-Provider implements RPCs (ToasterService RPCs) from the generated SAL API, so these implementations have to be  registered with MD-SAL: 
<pre>getRpcRegistryDependency().addRpcImplementation(ToasterService.class, opendaylightToaster);</pre>

* Toaster-Consumer, in order to access the ToasterService instance from MD-SAL uses <pre>getRpcRegistryDependency().getRpcService(ToasterService.class);</pre>

==== NotificationService dependency ====
* Toaster-Provider sends notifications through MD-SAL, so it registers through
<pre>
setNotificationProvider(getNotificationServiceDependency());
</pre>

* Toaster-Consumer, in order to receive notifications from the provider through MD-SAL registers through 
<pre>
getNotificationServiceDependency().registerNotificationListener(ToastDone.class, consumer);
</pre>

==== DataBroker dependency ====
The Toaster-Provider uses the MD-SALs DataBrokerService to write state data to the DataStore , the dependency on this service is through
<pre>
setDataProvider(getDataBrokerDependency());
</pre>

=== Dependencies as Augmentations in YANG ===
The dependencies mentioned in the previous section must be specified in the module configuration yang files, as an '''augment''' of the '''config:configuration''':
* Toaster-Provider (''toaster-provider-impl.yang'')
<pre>
augment "/config:modules/config:module/config:configuration" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";

            container rpc-registry {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-rpc-registry;
                    }
                }
            }

            container notification-service {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-notification-service;
                    }
                }
            }
            container data-broker {
                uses config:service-ref {
                    refine type {
                        mandatory false;
                        config:required-identity mdsal:binding-data-broker;
                    }
                }
            }

           
        }
</pre>
* Toaster-Consumer (''toaster-consumer-impl.yang'')
<pre>
augment "/config:modules/config:module/config:configuration" {
        case toaster-consumer-impl {
            when "/config:modules/config:module/config:type = 'toaster-consumer-impl'";

            container rpc-registry {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-rpc-registry;
                    }
                }
            }

            container notification-service {
                uses config:service-ref {
                    refine type {
                        mandatory true;
                        config:required-identity mdsal:binding-notification-service;
                    }
                }
            }

        }
    }
</pre>

'''For a detailed walk-through on how to make a 'config-subsystem aware' project please visit''' https://wiki.opendaylight.org/view/OpenDaylight_Controller:Config:Examples:Sample_Project

=== Extra configuration ===
Our Toaster example (for demo purposes) has been designed to have some additional features:
* Toaster Provider provides access through JMX/config-subsystem to some additional data -  '''toasts-made''', this is achieved by augmenting the '''config-state''' in ''toaster-provider-impl.yang'':
<pre>
augment "/config:modules/config:module/config:state" {
        case toaster-provider-impl {
            when "/config:modules/config:module/config:type = 'toaster-provider-impl'";

            leaf toasts-made {
                type uint32;
            }

        }
    }
</pre>
* Toaster Consumer provides access through JMX/config-subsystem to a specific RPC - '''make-hash-brown-toast-rpc''', this is achieved by augmenting the config-state in ''toaster-consumer-impl.yang'':

<pre>
augment "/config:modules/config:module/config:state" {
        case toaster-consumer-impl {
            when "/config:modules/config:module/config:type = 'toaster-consumer-impl'";
            rpcx:rpc-context-instance "make-hash-brown-toast-rpc";
        }
    }

    identity make-hash-brown-toast-rpc;

    rpc make-hash-brown-toast {
        input {
            uses rpcx:rpc-context-ref {
                refine context-instance {
                    rpcx:rpc-context-instance make-hash-brown-toast-rpc;
                }
            }
            leaf doneness {
                type uint16;
            }
        }
        output {
            leaf result {
                type boolean;
            }
        }
    }
</pre>

=== Generated Java classes ===

The Yang files   
* ''toaster-provider-impl.yang'' and 
* ''toaster-consumer-impl.yang''
are converted to java files from which Java code for configuration system is generated by yang-maven-plugin and yang-jmx-generator-plugin.

To run the converter , the below code has to be added to the (''toaster-provider'' and ''toaster-consumer'' projects) POM files:
<pre>
            <plugin>
                <groupId>org.opendaylight.yangtools</groupId>
                <artifactId>yang-maven-plugin</artifactId>
                <executions>
                    <execution>
                        <id>config</id>
                        <goals>
                            <goal>generate-sources</goal>
                        </goals>
                        <configuration>
                            <codeGenerators>
                                <generator>
                                    <codeGeneratorClass>
                                        org.opendaylight.controller.config.yangjmxgenerator.plugin.JMXGenerator
                                    </codeGeneratorClass>
                                    <outputBaseDir>${jmxGeneratorPath}</outputBaseDir>
                                    <additionalConfiguration>
                                        <namespaceToPackage1>
                                            urn:opendaylight:params:xml:ns:yang:controller==org.opendaylight.controller.config.yang
                                        </namespaceToPackage1>
                                    </additionalConfiguration>
                                </generator>
                                <generator>
                                    <codeGeneratorClass>
                                        org.opendaylight.yangtools.maven.sal.api.gen.plugin.CodeGeneratorImpl
                                    </codeGeneratorClass>
                                    <outputBaseDir>
                                        ${salGeneratorPath}
                                    </outputBaseDir>
                                </generator>
                            </codeGenerators>
                            <inspectDependencies>true</inspectDependencies>
                        </configuration>
                    </execution>
                </executions>
                <dependencies>
                    <dependency>
                        <groupId>org.opendaylight.controller</groupId>
                        <artifactId>yang-jmx-generator-plugin</artifactId>
                        <version>${config.version}</version>
                    </dependency>
                    <dependency>
                        <groupId>org.opendaylight.yangtools</groupId>
                        <artifactId>maven-sal-api-gen-plugin</artifactId>
                        <version>${yangtools.version}</version>
                    </dependency>
                </dependencies>
            </plugin>
</pre>

This will generate Java files  and place them in ''src/main/yang-gen-config'' and ''src/main/yang-gen-sal'' folders.
* The generated files to note, located in ''generated-sources/config'' folders are ''ToasterProviderModule.java'' respectively ''KitchenServiceModule.java'', these are initially generated but once manually edited they don't get overwritten by the code generator. 


* The '''createInstance()'''  method of the generated file is implemented manually, and this is where the dependencies methods mentioned in the [[#Dependencies with MD-SAL| Dependencies with MD-SAL]] section are manually added.

= The unit test =
The toaster example contains a unit test located under the''sample-toaster-it'' project, ''src/main/test'' folder.
=== Controller configuration ===
* It uses the Pax Exam to define a configuration of the controller in the OSGI container. This loads the minimum required bundles, standard MD-SAL bundles 
*  +  Toaster bundles:
<pre>           
                mavenBundle("org.opendaylight.controller.samples", "sample-toaster-provider").versionAsInProject(),
                mavenBundle("org.opendaylight.controller.samples", "sample-toaster-consumer").versionAsInProject(),
                mavenBundle("org.opendaylight.controller.samples", "sample-toaster").versionAsInProject()
</pre>

=== Testing Consumer API through OSGI ===
The '''createToast''' is invoked:
<pre>kitchenService.makeBreakfast( EggsType.SCRAMBLED, HashBrown.class, 4);</pre>

=== Getting Provider Runtime data exposed to config-subsystem ===
The '''toasts-made''' declared in the ''toaster-provider-impl.yang'' is accessed through JMX:
<pre>platformMBeanServer.getAttribute(providerOn, "ToastsMade");</pre>
