
In Helium timeframe MD-SAL is going to change Data Broker APIs based on user feedback,
and new Data Broker APIs we're designed with community.

All Data APIs from package org.opendaylight.controller.sal.binding.api.data and org.opendaylight.controller.sal.core.api.data
are going to be deprecated and replaced with  org.opendaylight.controller.md.sal.binding.api and org.opendaylight.controller.md.sal.dom.api

Implementation of MD-SAL already uses new DOM Data Broker and DOM APIs and provides support for legacy APIs for more then two months.

== Important changes ==
- Any data operations must be done using Transactions
- Transaction Chaining
- Read are not blocking, but asynchronous
- Clarified difference between put (add/replace) and merge
- Clarified APIs
- Granular registration options for data change listeners.

== Migration Guide  ==

=== Reading Data ===

New DataBroker APIs requires all reads to happen inside transaction, and provides specific transaction type
only for reading which could be allocated by invoking #newReadOnlyTransaction() on DataBroker.



===== Legacy API =====

Example bellow illustrates legacy read of data, which required null pointers check
and was blocking (even if read was remote - e.g. Netconf Device).

<pre>
        DataModificationTransaction readTx = legacyBroker.beginTransaction();
        DataObject data = readTx.readConfigurationData(PATH);

        if(data != null) {
            // data are present in data store.
            doSomething(data);
        } else {
            // data are not present in data store.
        }
</pre>

===== New API =====

====== Blocking read ======

Note: Blocking reads are discouraged, try to use non-blocking reads as much as possible.

<pre>
        ReadOnlyTransaction readTx = dataBroker.newReadOnlyTransaction();
        Optional<DataObject> data = readTx.read(LogicalDatastoreType.CONFIGURATION,PATH).get();
       
        if(data.isPresent()) {
           // data are present in data store.
            doSomething(result.get());
        } else {
            // data are not present in data store.
        }
</pre>


====== Non-blocking read ======

<pre>
        ReadOnlyTransaction readTx = dataBroker.newReadOnlyTransaction();
        ListenableFuture<Optional<DataObject>> dataFuture = readTx.read(LogicalDatastoreType.CONFIGURATION,PATH);
        Futures.addCallback(dataFuture, new FutureCallback<Optional<DataObject>>() {
            @Override
            public void onSuccess(final Optional<DataObject> result) {
                if(result.isPresent()) {
                 // data are present in data store.
                    doSomething(result.get());
                } else {
                    // data are not present in data store.
                }
            }
            @Override
            public void onFailure(final Throwable t) {
                // Error during read
            }
</pre>

* onSuccess() will be invoked once read is done and result is returned.


=== Modifying data ===

Behaviour of some methods in legacy API was not well-documented and naming of
operations was sometimes missleading users who were used to REST operations.

New APIs have better documented APIs and better naming for operations.


==== Adding Data ====
===== Legacy API =====
<pre>
        DataModificationTransaction writeTx = legacyBroker.beginTransaction();
        // write to configuration store
        writeTx.putConfigurationData(PATH, DATA);
        // write to operation store
        writeTx.putOperationalData(PATH, DATA);     
</pre>

===== New API =====

<pre>
        ReadWriteTransaction writeTx = dataBroker.newReadWriteTransaction();
        // replace in configuration store
        writeTx.put(LogicalDatastoreType.CONFIGURATION,PATH, DATA);
        // replace in operational store
        writeTx.put(LogicalDatastoreType.OPERATIONAL,PATH, DATA);       
</pre>

==== Replacing Data ====

Put method in legacy APIs was used as "merge" method, which did not replace
data, but merged them with previous state, which is inconsistent with expection
of clients. replace was always done by remove/put combination.

===== Legacy API =====
<pre>
        DataModificationTransaction writeTx = legacyBroker.beginTransaction();
        // replace in configuration store
        writeTx.removeConfigurationData(PATH);
        writeTx.putConfigurationData(PATH, DATA);
        // replace in operation store
        writeTx.removeOperationalData(PATH);
        writeTx.putOperationalData(PATH, DATA);
        
</pre>

===== New API =====
<pre>
        ReadWriteTransaction writeTx = dataBroker.newReadWriteTransaction();
        // replace in configuration store
        writeTx.put(LogicalDatastoreType.CONFIGURATION,PATH, DATA);
        // replace in operational store
        writeTx.put(LogicalDatastoreType.OPERATIONAL,PATH, DATA);
</pre>


==== Merging Data ====

===== Legacy API =====
<pre>
        DataModificationTransaction writeTx = legacyBroker.beginTransaction();
        // merge in configuration store
        writeTx.putConfigurationData(PATH, DATA);
        // merge in operational store
        writeTx.putOperationalData(PATH, DATA);
</pre>

===== New API =====
<pre>
        ReadWriteTransaction writeTx = dataBroker.newReadWriteTransaction();
        // merge in configuration store
        writeTx.merge(LogicalDatastoreType.CONFIGURATION,PATH, DATA);
        // merge in configuration store
        writeTx.merge(LogicalDatastoreType.OPERATIONAL,PATH, DATA);
</pre>


==== Commiting Transaction ====

New Data Broker APIs provides better visibility into transaction eg. reason of failure
and also ListenableFuture as result, which makes it easier to listen on asynchronous
commit and its state. 

===== API - Asynchronous Commit state =====
<pre>
        ReadWriteTransaction writeTx = dataBroker.newReadWriteTransaction();

        ListenableFuture<RpcResult<TransactionStatus>> commitFuture = writeTx.commit();

        Futures.addCallback(commitFuture, new FutureCallback<RpcResult<TransactionStatus>>() {

            @Override
            public void onSuccess(final RpcResult<TransactionStatus> result) {
                // Commited successfully
            }

            @Override
            public void onFailure(final Throwable t) {
                // Transaction failed

                if(t instanceof OptimisticLockFailedException) {
                    // Failed because of concurrent transaction modifying same data
                }

            }

        });
</pre>

===== New API - Write/Commit/Retry Example =====

This example illustrates simple write/commit/retry example,
when we are writing same data, but if commit failed because of concurrent modification,
we will retry same transaction.


<pre>
    private void writeData(final boolean isRetry) {
        ReadWriteTransaction writeTx = dataBroker.newReadWriteTransaction();
        writeTx.put(LogicalDatastoreType.OPERATIONAL, PATH, DATA);
        
        ListenableFuture<RpcResult<TransactionStatus>> future = writeTx.commit();
        Futures.addCallback(future, new FutureCallback<RpcResult<TransactionStatus>>() {

            @Override
            public void onSuccess(final RpcResult<TransactionStatus> result) {
                // Commited successfully
            }

            @Override
            public void onFailure(final Throwable t) {
                // Transaction failed

                if(t instanceof OptimisticLockFailedException) {
                    LOG.error("Concurrent modification of data",e);
                    if(!isRetry) {
                        LOG.info("Going to retry transaction.");
                        writeData(true);
                    }
                }

            }
        });

    }
</pre>
