= OpenDove's Data Model =

OpenDove has an L3 view in that we define virtual networks (collections of endpoints) grouped into administrative groups called domains
we also define IPv4 subnets, and in OpenDove the mapping between network and subnet is many to many. 

Further, OpenDove allows traffic between endpoints within a virtual network, but traffic between endpoints on separate virtual networks is denied *unless* a OpenDove policy has been configured to allow the traffic to flow

Lastly, there are three objects related to the oDGW:
# Each oDGW has an external facing IPv4 address
# When a virtual network is attached to a particular oDGW, an SNAT pool object is created for that network and oDGW pair to support sNAT
# Finnaly, for dNAT OpenDove uses a forward rule object

= Mapping from Neutron Objects =

== Tenants to Domains ==

This is implicit because the OpenStack tenant api isn't part of Neutron and so there is no explicit creation of tenants that the ODL Neutron Service receives.

Instead, the mapping is handled implicitly in that when a network create operation is received, if necessary, an OpenDove domain is created for the OpenStack tenant that is referred to by the Network create operation.

== Networks ==
for neutron networks, it's pretty straightforward from neutron network to opendove network
but the semantic is slightly different and that leads to some corner cases
in openstack, a network is an L2 broadcast domain, while (as I said) in opendove we have a bit more freedom
the other semantic is that neutron includes the concept of a shared network while OpenDove doesn't
on the other hand OpenDove supports the concept of a shared subnet, while neutron doesn't
so, let's take three different types of networks that Neutron can create and look at each of them
for a dedicated neutron network, it maps into an OpenDove Network
ekarlso-
wonder how OD / all the stuff in OD will compare to NSX from VMware for NFV for hydrogen
regXboi
(digression, this is all done via the Neutron service and the INeutron*Aware contracts built in for downstream mapping)
== ppallamr [~ppallamr@nat/cisco/x-lmxsfiahudhjasfd] has joined
regXboi
(so that's why you don't see NB code right now relating to this - it's all in the OpenDoveNeutronCallbacks class)
now for a Neutron network that is decorated as "router:external" it represents a network outside the overlay
and so we don't create an OpenDove network for that. Rather, we hold on to that information for configuring the oDGW later on in the mapping process. 
The last part is the shared neutron network
regXboi
and for that, things get a little tricky because OpenDove supports a concept called "domain separation" through the OpenDoveNeutron control block
er I mean OpenDoveNeutronControlBlock
now, if domain are not being separated, then there is a special "shared domain" and "shared network" created and the neutron network is mapped to that (we'll talk about the subnet in a little bit)
if domains are being separated, then we use delayed binding to only create the domain/network/subnet when a port request is received for a tenant on that shared network as that acts as a contract to use the resources. 

so at least for the mapping to opendove, we maintain that many-to-one mapping in Hydrogen. In Helium, if/when there is an ODL CLI, that will be revisited
anyway, in OpenDove we have the concepts of both dedicated and shared subnets.
the difference is that a dedicated subnet is only used by the overlay
while a shared subnet is used by both the overlay and the underlay
and this lets us approximate the concept of the shared Neutron network
by using a shared subnet when mapping the Neutron subnet associated with a shared Neutron network
but it is an approximation and the semantics are different
otherwise, it's pretty much a one-to-one mapping, along with the case that for a subnet on a router:external network, we don't create an OpenDove subnet object, we just cache the information for later 
Ports are a little tricky in that the oDMC itself doesn't track endpoints, but leaves that to other components of the OpenDOVE system
so we track ports for two reasons: one is the delayed binding case stated above
== ermagan [~vermagan@nat/cisco/x-xmavqgwesocpgjqj] has joined
regXboi
and the other is so that we can map a portUUID to a VNID so that an opendove switch handles an attached VM correctly.
(actually there is a third reason)

we also need to track them so that we can handle neutron router interface attachments/detachments properly 
we'll quickly talk about router objects because we track those for handling neutron router interfaces attach/detach operations, which is where the interesting stuff happens
beyond that, there is not mapping done for a router operation


ok, now for the fun part - router interface attachments
regXboi
which spin out both opendove policies as well as oDGW snat pools
regXboi
In neutron, the router object has the semantic of providing connectivity between all of its attached interfaces.
regXboi
so on each interface attach operation, we first look at the associated port and network that is being attached
regXboi
and then depending on whether it is "router:external" or not, we handle setting up opendove objects for all the other interfaces that were previously attached
regXboi
obviously, this means we don't start doing anything until the second interface is attached.
regXboi
when we do a pairwise compare of the interfaces, if both are internal, then we create opendove policies to allow traffic to flow between the opendove virtual networks that were created for those neutron networks
regXboi
if one interface is external, then we create first (if necessary) find available oEGWs to associate with the internal opendove network, then (if necessary) assign an external IP to the oDGW from the external subnet space
regXboi
and then lastly, create an SNAT pool for the oDGW to use for that internal network
regXboi
the size of the SNAT pool and the number of oDGWs used for each network are determined by other parameters of the OpenDoveNeutronControlBlock 

ok, last is floatingip
regXboi
neutron floating ips are used to provide dnat services for the neutron router model
regXboi
so that is pretty much a direct map to the opendove external forwarding rule for an oDGW
