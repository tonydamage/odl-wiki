= Current Mode of Operation=
==Data Store Read Operation==
The data store read operation is shown in the following figure:

[[File:DS-Data-Read-OP.jpg]]

The sequence is as follows:
# baDataBroker.readOperationalData(yang.binding.InstanceIdentifier<Node>)
# connector.readOperationalData(...)
# domInstanceIdentifier = mappingService.toDataDom(bindingInstanceIdentifier)
# biDataBroker.readOperationalData(domInstanceIdentifier)
# domData = dataStore.readOperationalData(domInstanceIdentifier)
# domData is returned to caller
# domData is returned to caller
# baData = mappingService.toDataObject (bindingInstanceIdentifier, domData)
# baData is returned to caller
# baData is returned to caller
# baData is returned to caller



=Transaction-Based Operation=
==Create a BA-to-DOM Transaction==
First a transaction object needs to be created, as shown in the following sequence:

[[File:DS-Create-Tx.jpg]]

The sequence is as follows:
# baDataBroker.beginTransaction()
# connector.beginForwardedTransaction()
# biDataBroker.beginTransaction()
# storeTx = dataStore.beginTransaction() // storeTx contains snapshot
# storeTx is returned to caller
# domTx = createDomTx(storeTx)
# return domTx to caller
# baDomTx = createForwardedTransaction(domTx)
# Return baDomTx to ForwardedDataBroker
# Return baDomTx to client
# Return baDomTx to client


==Data Read Operation on a Transaction==
An application can issue multiple reads on a previously created transaction, as shown in the following sequence:

[[File:DS-Data-Read-Tx.jpg]]

The sequence is as follows:
# baDomTx.readOperationalData(yang.binding.InstanceIdentifier<Node>)
# // lookup in local cache, asume fail – performance optimalization
# domInstanceIdentifier = mappingService.toDataDom(bindingInstanceIdentifier)
# domTx.readOperationalData(domInstanceIdentifier)
# domData = storeTx.readOperationalData(domInstanceIdentifier)
# domData is returned to caller
# domData is returned to caller
# baData = mappingService.toDataDom(bindingInstanceIdentifier, domData)
# baData is returned to caller
# baData is returned to caller
# baData is returned to caller


==Cancel a Transaction==
An application can cancel a transaction. A transaction is cancelled, for example, if all operations on the transaction were read.

[[File:DS-Cancel-Tx.jpg]]

The sequence is as follows:
# baDomTx.cancel()
# baDomTx clean ups all local state (cache of DTO, references to services)
# domTx.cancel()
# dataBroker.cancel(domTx)
# domTx clean ups all local state (cache of DTO, references to services)
# storeTx.cancel() // Asynchronous – need to keep track of
# storeTx clean ups all local state (modifications, snapshot)


==Data Write Operation on a Transaction==
In additions to reads, an application can issue multiple writes on a previously created transaction, as shown in the following sequence:

[[File:DS-Data-Write-Tx.jpg]]

The sequence is as follows:
# baDomTx.putOperationalData(yang.binding.InstanceIdentifier<Node>,Node)
# // Cache cleanup of subtree and parent nodes
# domII,domData = mappingService.toDataDom(bindingInstanceIdentifier,baData)
# domTx.putOperationalData(domInstanceIdentifier,domData)
# storeTx.replaceData(domInstanceIdentifier,domData)
# storeTx updates modification index


==Transaction Commit==
The commit operation is shown in the following sequence:

[[File:DS-Commit-Tx.jpg]]

The sequence is as follows:
# baDomTx.commit() // Submits to commit queue
# domTx.commit()
# dataBroker.commit(domTx)
# Start of two Phase commit – requestCommit on Commit Handlers
# storeTx.requestCommit() // Asynchronous – need to keep track of
# storeTx creates optimistic snapshot 
# dataTx returns goAhead
# End of Two phace commit – finish callback on Commit Handlers
# storeTx.finish()
# dataStore.finish(storeTx)
# dataStore replaces snapshot
