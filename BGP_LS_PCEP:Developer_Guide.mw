==Technical Architecture==
FIXME: add a high-level picture of what we BGP/LS and PCEP do.
A detailed description of the project likely including both high-level and lower-level architecture diagrams

==Configuration ==

* Basic configuration - [[BGP LS PCEP:User Guide]]

==Tutorial / How-To==
=== Introduction ===

An extension to a protocol means basically adding parsers and serializers for
new elements, such as messages, objects, tlvs or subobjects. This is 
usually necessary when you are extending the protocol with another RFC or draft.
Both BGP and PCEP parsers are pluggable and you can specify which extensions to 
load alongside to the base parser in the configuration file.

==== Writing an extension to PCE protocol ====

===== Current standards support =====
Current pcep base-parser implementation supports following RFCs:

'''[http://tools.ietf.org/html/rfc5440 RFC5440]''' - Path Computation Element (PCE) Communication Protocol (PCEP) <br />
'''[http://tools.ietf.org/html/rfc5541 RFC5541]''' - Encoding of Objective Functions in the Path Computation Element Communication Protocol (PCEP) <br />
'''[http://tools.ietf.org/html/rfc5455 RFC5455]''' - Diffserv-Aware Class-Type Object for the Path Computation Element Communication Protocol <br />
'''[http://tools.ietf.org/html/rfc5521 RFC5521]''' - Extensions to the Path Computation Element Communication Protocol (PCEP) for Route Exclusions <br />
'''[http://tools.ietf.org/html/rfc5557 RFC5557]''' - Path Computation Element Communication Protocol (PCEP) Requirements and Protocol Extensions in Support of Global Concurrent Optimization <br />

There are already two extensions for: <br />
'''[http://tools.ietf.org/html/draft-ietf-pce-stateful-pce draft-ietf-pce-stateful-pce]''' - in versions 02 and 07 <br />
'''[http://tools.ietf.org/html/draft-ietf-pce-pce-initiated-lsp draft-ietf-pce-pce-initiated-lsp]''' - versions crabbe-initiated-00 and ietf-initiated-00 <br />
 <dependency>
     <groupId>${project.groupId}</groupId>
     <artifactId>pcep-ietf-stateful02</artifactId>
 </dependency>

 <dependency>
     <groupId>${project.groupId}</groupId>
     <artifactId>pcep-ietf-stateful07</artifactId>
 </dependency>

Note, that they extend each other, so it is vital to load the extensions with compatible versions.
In this case crabbe-initiated-00 is compatible with stateful-02 and ietf-initiated-00 is compatible
with stateful-07.

===== How to implement an extension to PCEP =====

* Create a separate artefact (eclipse project) for your extension. Make sure it depends on pcep-api and pcep-spi.

* Write yang model for new elements or augment existing ones. Perform 'mvn install' to generate files from the model.

* Write parsers and serializers. All parsers need to implement *Parser and *Serializer interfaces from pcep-spi (e.g. if you are writing a new TLV, your parser should implement TlvParser and TlvSerializer). Add Activator, that extends AbstractPCEPExtensionProviderActivator, where you register your parsers and serializers.

====== Update configuration ======

* Update 32-pcep.xml. Register your parser as a module in pcep-impl:
 <module>
 	<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:pcep:impl">prefix:pcep-parser-new-parser</type>
 	<name>pcep-parser-new-parser</name>
 </module>
* Add it as an extension to pcep-parser-base:
 <extension>
 	<type xmlns:pcepspi="urn:opendaylight:params:xml:ns:yang:controller:pcep:spi">pcepspi:extension</type>
 	<name>pcep-parser-new-parser</name>
 </extension>
* Add it's instance to services:
 <instance>
 	<name>pcep-parser-new-parser</name>
 	<provider>/config/modules/module[name='pcep-parser-new-parser']/instance[name='pcep-parser-new-parser']</provider>
 </instance>
* Update odl-pcep-impl-cfg.yang so that it generates Module and ModuleFactory classes for your new parser.
 identity pcep-parser-new-parser {
 	base config:module-type;
 	config:provided-service spi:extension;
 	config:java-name-prefix NewParserPCEPParser;
 }

 augment "/config:modules/config:module/config:configuration" {
 	case pcep-parser-new-parser {
 		when "/config:modules/config:module/config:type = 'pcep-parser-new-parser'";
 	}
 }
Run mvn install on pcep-impl-config to generate Module and ModuleFactory files.

* Update Module to start your NewParserPCEPParserModule.java whent it's created.
 @Override
 public java.lang.AutoCloseable createInstance() {
 	return new InitiatedActivator();
 }

==== Writing an extension to BGP ====

===== Current standards support =====
Current bgp base-parser implementation supports following RFCs:

'''[http://tools.ietf.org/html/rfc4271 RFC4271]''' - A Border Gateway Protocol 4 (BGP-4) <br />
'''[http://tools.ietf.org/html/rfc4724 RFC4724]''' - Graceful Restart Mechanism for BGP <br />
'''[http://tools.ietf.org/html/rfc4760 RFC4760]''' - Multiprotocol Extensions for BGP-4 <br />
'''[http://tools.ietf.org/html/rfc1997 RFC1997]''' - BGP Communities Attribute <br />
'''[http://tools.ietf.org/html/rfc4360 RFC4360]''' - BGP Extended Communities Attribute <br />
'''[http://tools.ietf.org/html/rfc6793 RFC6793]''' - BGP Support for Four-Octet Autonomous System (AS) Number Space (NEW speaker only) <br />

There is already one extension for: <br />
'''[http://tools.ietf.org/html/draft-ietf-idr-ls-distribution draft-ietf-idr-ls-distribution]''' - in version 04 <br />

 <dependency>
    <groupId>${project.groupId}</groupId>
    <artifactId>bgp-linkstate</artifactId>
 </dependency>

===== How to implement an extension to BGP =====

* Create a separate artefact (eclipse project) for your extension. Make sure it depends on pcep-api and pcep-spi.

* Write yang model for new elements or augment existing ones. Perform 'mvn install' to generate files from the model.

* Write parsers and serializers. All parsers need to implement *Parser and *Serializer interfaces from bgp-spi (e.g. if you are writing a new Capability, your parser should implement CapabilityParser and CapabilitySerializer). 

* Add Activator, that extends AbstractBGPExtensionProviderActivator, where you register your parsers and serializers. If your extension adds another AFI/SAFI you also habe to add another Activator that extends AbstractRIBExtensionProviderActivator and registrate new address family and subsequent address family.

====== Update configuration ======

* Update 31-bgp.xml. Register your parser as a module in bgp-impl:
 <module>
 	<type xmlns:prefix="urn:opendaylight:params:xml:ns:yang:controller:bgp:new-parser">prefix:bgp-new-parser</type>
 	<name>bgp-new-parser</name>
 </module>
* Add it as an extension to bgp-parser-base:
 <extension>
 	<type xmlns:bgpspi="urn:opendaylight:params:xml:ns:yang:controller:bgp:parser:spi">bgpspi:extension</type>
 	<name>bgp-new-parser</name>
 </extension>
* Add it's instance to services:
 <instance>
 	<name>bgp-new-parser</name>
 	<provider>/modules/module[type='bgp-new-parser'][name='bgp-new-parser']</provider>
 </instance>
 
Also, if you are introducing new AFI/SAFI, don't forget to registrate your extension also to RIB.
 
* Create your own configuration file so that it generates Module and ModuleFactory classes for your new parser.
 identity bgp-new-parser {
        base config:module-type;
        config:provided-service bgpspi:extension;
        config:provided-service ribspi:extension; // for new AFI/SAFI
        config:java-name-prefix NewParser;
 }

 augment "/config:modules/config:module/config:configuration" {
        case bgp-new-parser {
                when "/config:modules/config:module/config:type = 'bgp-new-parser'";
        }
 }
Run mvn install on your extension artefact to generate Module and ModuleFactory files.

* Update Module to start your NewParserModule.java whent it's created.
 @Override
 public java.lang.AutoCloseable createInstance() {
 	return new NewParserActivator();
 }


==Programmatic Interface(s)==

* YANG Models - [[BGP LS PCEP:Models]]

* API Documentation â€“ [https://jenkins.opendaylight.org/bgpcep/job/bgpcep-nightly/lastSuccessfulBuild/artifact/target/staging/releasepom/apidocs/index.html Javadoc API]

For debugging purposes, set lower log levels for bgpcep project in logback.xml .

 <logger name="org.opendaylight.protocol" level="TRACE" />

 <logger name="org.opendaylight.bgpcep" level="TRACE" />
