'''Note: This document is work in progress, parts of it may be changed, because it depends on API contracts, which are to be frozen by [[Simultaneous Release:Simultaneous Release Plan 2013|M4 Milestone]]'''

Southbound controller plugin is a functional component which provides an 
abstraction of network devices functionality, normalization of their APIs to
common contracts, handles session and connections to them. In general development process consists of following steps:

1. '''Definition of YANG models''' (API contracts) - for Model-Driven SAL, the API contracts are defined by YANG models and Java interfaces generated for these models. In this steps developers selects existing models which he wants to comfort to, writes own models or augment (extend) existing one.

2. '''Code Generation''' - Java Interfaces, implementation of Transfer Objects and mapping to Binding-Independent form is generated for the plugin. this phase requires proper configuration of Maven build and YANG Maven Tools.

3. '''Implementation of plugin''' - Actual implementation of plugin functionality and plugin components.

The order of steps is not definitive and it is up to developer to find out the workflow which suits him best. 
See also Best Practices for additional information.

== Definition of YANG models ==

In this step developer selects existing models, writes own models or augment
existing ones, which are provided by controller or other plugins. The partial
list of available models could be found at [[YANG Tools:Available Models]].

The mapping of YANG to Java is documented at [[Yang Tools:YANG to Java Mapping]].
This mapping provides an overview how YANG is mapped to Java.

In general there are multiple approaches how to model functionality of Southbound Plugin:

# Using RPCs and Notifications
# Using Configuration Data Description
# Using Runtime Data Description
# Combined

=== RPCs ===

RPCs are used to model functionality which could be invoked by consumers (applications) which uses Southbound Plugin.
RPCs are suitable to model any functionality, but usually are used to model functionality which could not be abstracted
as configuration data - such as PacketOut, initiating a new session to device (controller-to-device session), etc.

RPCs are modeled with rpc statement in the following form:

   rpc foo {}

This one is mapped to method

====RPC Input====

To define RPC input use input statement inside RPC. The structure of input is defined with same statements as structure
of notifications, configuration and so on.

  rpc foo {
     input {
        ...
     }
  }

====RPC Output====
To define RPC output (structure of result) use RPC output statement

  rpc foo {
    output {
       ...
    }
  }

=== Notifications ===

Notifications are used to model events originating in network device or southbound plugin which are exposed to consumers to 
listen on.

Notification is defined with '''notification''' statement:

    notification foo {
       ...
    }

=== Configuration Data ===

Configuration data are good to model / provide CRUD access to the state of protocol plugin 
and/or network devices or to model any functionality which could be exposed as a configuration
to the consumers / applications.

Configuration data in YANG are defined by using config substatement with true argument. E.g.
   
   container foo {
      config true;
      ...
   }
   

=== Runtime (read-only) Data ===

Runtime (read-only) data are good to model / provide read access to the state of protocol plugin
and/or networtk devices. This type of data is good to model statistics or any state data, which
could not be modified by the consumers (applications), but are necessary to be exposed (e.g.
learned topology, list of connected switches).

Runtime data in YANG are defined by using config subsatement with false argument:

   container foo {
      config false;
   }

=== Structural Elements ===

Structure of RPCs, notifications, configuration data and runtime data is modeled using structural elements (data schema nodes) which defines actual structure of XML, DataDOM documents and Java APIs for accessing / storing this elements. Most commonly used ones are:

* container
* list
* leaf
* leaf-list
* choice

=== Augmentations ===

Augmentations are used to extend existing models from different models by providing additional structural elements and semantics. Augmentation could not change mandatory status
of nodes in original model, nor introduce any new mandatory statements.

=== Modeling Best Practices ===

* YANG models should be located under src/main/yang folder in your project.
* Design your models to be reusable and extendable by third-parties
* Always try to reuse existing models and types provided by these models. See [[YANG Tools:Available Models]] or others if there is not a model which could provide you with data structures and types you need.

== Code Generation ==

To configure your project for code generation your build system is currently required to use Maven. For configuration of java API generation see [[Yang Tools:Maven Plugin Guide]]

Artefacts generated at compile time:

* Service interfaces
* Transfer Object interfaces
* Builders for Transfer Objects and immutable versions of transfer objects

== Implementation ==

In this step developer implements intended functionality of southbound plugin using generated artefacts.

=== Provider implementation ===

To expose functionality via binding-aware MD-SAL plugin needs to be compiled against these APIs and at least 
implement ''BindingAwareProvider'' interface.

The provider uses an APIs which  are avaible in sal-binding-api Maven artifact. To use this dependencies
insert following dependency into your pom.xml:

		<dependency>
			<groupId>org.opendaylight.controller</groupId>
			<artifactId>sal-binding-api</artifactId>
			<version>1.0-SNAPSHOT</version>
		</dependency>

==== BindingAwareProvider implementation ====

BindingAwareProvider interface requires you to implement 4 methods, and register an instance with BindingAwareBroker, use AbstractBindingAwareProvider to simplify implementation of this. 

* void onSessionInitialized(ConsumerContext ctx) - this callback is called when Binding-Aware Provider is initialized and ConsumerContext is injected into it, ConsumerContext serves to access all functionality which plugin is to consume from other controller components.
* void onSessionInitialized(ProviderContext ctx) - this callback is called when Binding-Aware Provider is initialized and ProviderContext is injected into it, ProviderContext serves to access all functionality which plugin could use to provide its funcitonality to controller components.
* Collection<? extends RpcService> getImplementations() - shorthand registration of already instantiated implementations of global RPC services. Automated registration is currently not supported.
* public Collection<? extends ProviderFunctionality> getFunctionality() - shorthand registration of already instatiated implementations of ProviderFunctionality. Automated registration is currently not supported.

You need also set your implementation of AbstractBindingAwareProvider set as Bundle Activator to be properly loaded by MD-SAL.

=== Notifications ===

To publish events you need to request an instance of NotificationProviderService from ProviderContext, you can achieve this with following:

    ExampleNotification notification = (new ExampleNotificationBuilder()).build();
    NotificationProviderService notificationProvider = providerContext.getSALService(NotificationProviderService.class);
    notificationProvider.notify(notification);

=== RPC implementations ===

To implement functionality exposed as RPCs you are required to implement generated RpcService interface and register that implementation
within ProviderContext which was injected into provider.

Lets consider that generated RpcInterface is FooService and your implementation is FooServiceImpl:

    @Override
    public void onSessionInitiated(ProviderContext context) {
        context.addRpcImplementation(FooService.class, new FooServiceImpl());
    }

=== Best Practices ===

* RPC Service interface contract requires you to return [http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Future.html Future] object (to make it obvious that call may be asynchronous), but it is not specified how this Future is implemented. Consider using existing implementations provided by JDK
or Google Guava. Implement your own Future only if necessary.
** Consider using [http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/SettableFuture.html SettableFuture] if you intend to not use [http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/FutureTask.html FutureTask] or submitting [http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Callable.html Callable]s to [http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html ExecutorService].
* DO NOT implement transfer object interfaces unless necessary. Prefer using already generated builders and immutable versions. If you decided to implement transfer objects, make sure that instances exposed outside plugin are immutable.

==== Recommended Third-party Libraries for implementation ====

==== SLF4J ====
TBD: Usage notes for SLF4J
==== Google Guava ====
TBD: Usage notes and pointers to useful classes from Google Guava 14
==== Netty.io ====
TBD: Usage notes and pointers to useful classes from Netty.io 4
