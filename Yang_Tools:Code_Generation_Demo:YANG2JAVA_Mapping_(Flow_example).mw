= opendaylight-flow-types module =
Following pieces of YANG code are copied from:<br />
'''module:''' ''opendaylight-flow-types''<br />
'''namespace:''' ''urn:opendaylight:flow:types''<br />
'''revision:''' ''2013-10-26''<br />
The complete source code of this module can be found at this [[Yang_Tools:Code_Generation_Demo:YANG2JAVA_Mapping:opendaylight-flow-types_module | page]].
== mapping of flow grouping ==
The module ''opendaylight-flow-types'' contains except others the statement <code>grouping</code> '''flow''' which is mapped to JAVA <code>interface</code> '''Flow'''. 
=== YANG grouping mapping ===
For every YANG child element of <code>grouping</code> '''flow'''(e. g. <code>leaf, container</code>...) corresponding JAVA methods are generated.<br />
For example:<br />
* YANG <code>leaf</code> '''container-name''' is mapped to JAVA ''getter'' method <code>String '''get'''ContainerName();</code>.
* YANG <code>leaf</code> '''strict''' which is of boolean type is mapped to JAVA ''is'' method <code>Boolean '''is'''Strict();</code>.
Mapping from YANG grouping flow to JAVA code is in following table:<br />
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
    <td>
<source>
    grouping flow {
        container match {
            uses match:match;
        }
        
        container instructions {
            uses instruction-list;
        }          
         
        uses generic_flow_attributes;
        
        leaf container-name {
            type string; 
        }
        
        leaf cookie_mask {
            type uint64;
        }
        
        leaf buffer_id {
            type uint32;
        }
        
        leaf out_port {
            type uint64;
        }
        
        leaf out_group {
            type uint32;
        }
        
        leaf flags {
            type flow-mod-flags;
        }
        
        leaf flow-name {
            type string;
        }
        
        leaf installHw {
            type boolean;
        }

        leaf barrier {
            type boolean;
        }

        leaf strict {
            type boolean;
            default "false";
        }

    }
</source>
</td>
<td>
<source lang="java">

package org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026;
import java.math.BigInteger;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.FlowModFlags;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.flow.Instructions;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.flow.Match;
import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.GenericFlowAttributes;
import org.opendaylight.yangtools.yang.common.QName;


/**
**/
public interface Flow
    extends
    DataObject,
    GenericFlowAttributes
{



    public static final QName QNAME = org.opendaylight.yangtools.yang.common.QName.create("urn:opendaylight:flow:types","2013-10-26","flow")
    ;

    /**
    **/
    Boolean isBarrier();
    
    /**
    **/
    Long getBufferId();
    
    /**
    **/
    String getContainerName();
    
    /**
    **/
    BigInteger getCookieMask();
    
    /**
    **/
    FlowModFlags getFlags();
    
    /**
    **/
    String getFlowName();
    
    /**
    **/
    Boolean isInstallHw();
    
    Instructions getInstructions();
    
    Match getMatch();
    
    /**
    **/
    Long getOutGroup();
    
    /**
    **/
    BigInteger getOutPort();
    
    /**
    **/
    Boolean isStrict();

}
</source>
</td>
</table>

=== YANG leaf with not build-in type mapping ===
In <code>grouping</code> '''flow''' there is <code>leaf</code> '''flags''' which has type ''flow-mod-flags''. It isn't YANG built-in type. ''flow-mod-flags'' type is specified in module '''[[Yang_Tools:Code_Generation_Demo:YANG2JAVA_Mapping:opendaylight-flow-types_module | opendaylight-flow-types]]''' and is mapped to JAVA class '''FlowModFlags''' as shown in following table. '''FlowModFlags''' type is used as return value for method '''getFlags''' - <code>FlowModFlags getFlags();</code> - in Flow interface (see previous table).
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
<td>
<source>
typedef flow-mod-flags {
    type bits {
        bit CHECK_OVERLAP;
        bit RESET_COUNTS;
        bit NO_PKT_COUNTS;
        bit NO_BYT_COUNTS;
        bit SEND_FLOW_REM;
    }
}
</source>
</td>
<td>
<source lang="java">
package org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026;
import java.util.List;
import com.google.common.collect.Lists;


/**
**/
public class FlowModFlags
 {
    final private Boolean _cHECKOVERLAP;
    final private Boolean _rESETCOUNTS;
    final private Boolean _nOPKTCOUNTS;
    final private Boolean _nOBYTCOUNTS;
    final private Boolean _sENDFLOWREM;

    public FlowModFlags(Boolean _cHECKOVERLAP, Boolean _nOBYTCOUNTS, Boolean _nOPKTCOUNTS, Boolean _rESETCOUNTS, Boolean _sENDFLOWREM) {
        this._cHECKOVERLAP = _cHECKOVERLAP;
        this._rESETCOUNTS = _rESETCOUNTS;
        this._nOPKTCOUNTS = _nOPKTCOUNTS;
        this._nOBYTCOUNTS = _nOBYTCOUNTS;
        this._sENDFLOWREM = _sENDFLOWREM;
    }
    /**
     * Creates a copy from Source Object.
     *
     * @param source Source object
     */
    public FlowModFlags(FlowModFlags source) {
        this._cHECKOVERLAP = source._cHECKOVERLAP;
        this._rESETCOUNTS = source._rESETCOUNTS;
        this._nOPKTCOUNTS = source._nOPKTCOUNTS;
        this._nOBYTCOUNTS = source._nOBYTCOUNTS;
        this._sENDFLOWREM = source._sENDFLOWREM;
    }
    
    public static FlowModFlags getDefaultInstance(String defaultValue) {
        List<String> properties = Lists.newArrayList("cHECKOVERLAP",
        "nOBYTCOUNTS",
        "nOPKTCOUNTS",
        "rESETCOUNTS",
        "sENDFLOWREM"
        );
        if (!properties.contains(defaultValue)) {
            throw new IllegalArgumentException("invalid default parameter");
        }
        int i = 0;
        return new FlowModFlags(
        properties.get(i++).equals(defaultValue) ? new Boolean("true") : null,
        properties.get(i++).equals(defaultValue) ? new Boolean("true") : null,
        properties.get(i++).equals(defaultValue) ? new Boolean("true") : null,
        properties.get(i++).equals(defaultValue) ? new Boolean("true") : null,
        properties.get(i++).equals(defaultValue) ? new Boolean("true") : null
        );
    }

    public Boolean isCHECKOVERLAP() {
        return _cHECKOVERLAP;
    }
    
    public Boolean isRESETCOUNTS() {
        return _rESETCOUNTS;
    }
    
    public Boolean isNOPKTCOUNTS() {
        return _nOPKTCOUNTS;
    }
    
    public Boolean isNOBYTCOUNTS() {
        return _nOBYTCOUNTS;
    }
    
    public Boolean isSENDFLOWREM() {
        return _sENDFLOWREM;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((_cHECKOVERLAP == null) ? 0 : _cHECKOVERLAP.hashCode());
        result = prime * result + ((_rESETCOUNTS == null) ? 0 : _rESETCOUNTS.hashCode());
        result = prime * result + ((_nOPKTCOUNTS == null) ? 0 : _nOPKTCOUNTS.hashCode());
        result = prime * result + ((_nOBYTCOUNTS == null) ? 0 : _nOBYTCOUNTS.hashCode());
        result = prime * result + ((_sENDFLOWREM == null) ? 0 : _sENDFLOWREM.hashCode());
        return result;
    }

    @Override
    public boolean equals(java.lang.Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        FlowModFlags other = (FlowModFlags) obj;
        if (_cHECKOVERLAP == null) {
            if (other._cHECKOVERLAP != null) {
                return false;
            }
        } else if(!_cHECKOVERLAP.equals(other._cHECKOVERLAP)) {
            return false;
        }
        if (_rESETCOUNTS == null) {
            if (other._rESETCOUNTS != null) {
                return false;
            }
        } else if(!_rESETCOUNTS.equals(other._rESETCOUNTS)) {
            return false;
        }
        if (_nOPKTCOUNTS == null) {
            if (other._nOPKTCOUNTS != null) {
                return false;
            }
        } else if(!_nOPKTCOUNTS.equals(other._nOPKTCOUNTS)) {
            return false;
        }
        if (_nOBYTCOUNTS == null) {
            if (other._nOBYTCOUNTS != null) {
                return false;
            }
        } else if(!_nOBYTCOUNTS.equals(other._nOBYTCOUNTS)) {
            return false;
        }
        if (_sENDFLOWREM == null) {
            if (other._sENDFLOWREM != null) {
                return false;
            }
        } else if(!_sENDFLOWREM.equals(other._sENDFLOWREM)) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder("FlowModFlags [");
        boolean first = true;
    
        if (_cHECKOVERLAP != null) {
            if (first) {
                first = false;
            } else {
                builder.append(", ");
            }
            builder.append("_cHECKOVERLAP=");
            builder.append(_cHECKOVERLAP);
         }
        if (_rESETCOUNTS != null) {
            if (first) {
                first = false;
            } else {
                builder.append(", ");
            }
            builder.append("_rESETCOUNTS=");
            builder.append(_rESETCOUNTS);
         }
        if (_nOPKTCOUNTS != null) {
            if (first) {
                first = false;
            } else {
                builder.append(", ");
            }
            builder.append("_nOPKTCOUNTS=");
            builder.append(_nOPKTCOUNTS);
         }
        if (_nOBYTCOUNTS != null) {
            if (first) {
                first = false;
            } else {
                builder.append(", ");
            }
            builder.append("_nOBYTCOUNTS=");
            builder.append(_nOBYTCOUNTS);
         }
        if (_sENDFLOWREM != null) {
            if (first) {
                first = false;
            } else {
                builder.append(", ");
            }
            builder.append("_sENDFLOWREM=");
            builder.append(_sENDFLOWREM);
         }
        return builder.append(']').toString();
    }


}
</source>
</td>
</tr>
</table>

=== YANG container with uses mapping ===
For YANG <code>container</code> '''match''' which is element of <code>grouping</code> '''Flow''' is generated as JAVA <code>interface</code> '''Match''':<br />
</table>
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
<td>
<source>
//code omitted
//grouping flow {
   container match {
      uses match:match;
   }
//code omitted
//}
//code omitted
</source>
</td>
<td>
<source lang="java">
package org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.flow;
import org.opendaylight.yangtools.yang.binding.ChildOf;
import org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.Flow;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import org.opendaylight.yangtools.yang.common.QName;


/**
**/
public interface Match
    extends
    ChildOf<Flow>,
    Augmentable<org.opendaylight.yang.gen.v1.urn.opendaylight.flow.types.rev131026.flow.Match>,
    org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026.Match
{



    public static final QName QNAME = org.opendaylight.yangtools.yang.common.QName.create("urn:opendaylight:flow:types","2013-10-26","match")
    ;


}
</source>
</td>
</tr>
</table>

=== YANG Uses mapping ===
In YANG element <code>container</code> '''match''' the child subelements are added via YANG keyword <code>uses</code> and reference '''<font color="red">match:</font color>match'''. This subelements are exactly specified in the module referenced through prefix '''<font color="red">match:</font color>'''.<br />
The prefix is specified in haed part of [[Yang_Tools:Code_Generation_Demo:YANG2JAVA_Mapping:opendaylight-flow-types_module | yang file]] through YANG <code>import</code> keyword<br />
<code>import ''opendaylight-match-types'' {prefix <font color="red">'''match'''</font color>; revision-date "2013-10-26";}</code><br />
which is reference to  <code>grouping</code> - '''match:match''' of ''[[Yang_Tools:Code_Generation_Demo:YANG2JAVA_Mapping:opendaylight-match-types_module |opendaylight-match-types module]]''.<br />
The YANG <code>uses</code> keyword is mapped to JAVA as extension of interface '''Match'''. In the JAVA interface '''Match''' there is behind the <code>extends</code> word specified interface <code>org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026.Match</code> which contains concrete child elements. The mapping from referenced YANG '''match''' <code>grouping</code> to JAVA code is in following table.<br />
<table border="1">
<tr>
    <th>YANG - module opendaylight-match-types</th>
    <th>JAVA</th>
</tr>
<tr>
<td>
<source>
    grouping match {
        leaf in-port {
            type inv:node-connector-id;
        }

        leaf in-phy-port {
            type inv:node-connector-id;
        }

        container "metadata" {
            uses of-metadata;
        }

        container "tunnel" {
            leaf tunnel-id {
                description "Metadata associated in the logical port";
                type uint64;
            }

            leaf tunnel-mask {
                type uint64;
            }
        }

        container "ethernet-match" {
            uses "ethernet-match-fields";
        }

        container "vlan-match" {
            uses "vlan-match-fields";
        }

        container "ip-match" {
            uses "ip-match-fields";
        }

        choice layer-3-match {
            case "ipv4-match" {
                uses "ipv4-match-fields";
            }
            case "ipv6-match" {
                uses "ipv6-match-fields";
            }
            case "arp-match" {
                uses "arp-match-fields";
            }
        }

        choice layer-4-match {
            case "udp-match" {
                uses "udp-match-fields";
            }
            case "tcp-match" {
                uses "tcp-match-fields";
            }
            case "sctp-match" {
                uses "sctp-match-fields";
            }
        }

        container "icmpv4-match" {
            uses "icmpv4-match-fields";
        }

        container "icmpv6-match" {
            uses "icmpv6-match-fields";
        }

        container "protocol-match-fields" {
            uses "protocol-match-fields";
        }
    }
</source>
</td>
<td>
<source lang="java">
package org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026;
import org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026.match.EthernetMatch;
import org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026.match.Icmpv4Match;
import org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026.match.Icmpv6Match;
import org.opendaylight.yang.gen.v1.urn.opendaylight.inventory.rev130819.NodeConnectorId;
import org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026.match.IpMatch;
import org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026.match.Layer3Match;
import org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026.match.Layer4Match;
import org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026.match.Metadata;
import org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026.match.ProtocolMatchFields;
import org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026.match.Tunnel;
import org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026.match.VlanMatch;
import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.common.QName;


/**
**/
public interface Match
    extends
    DataObject
{



    public static final QName QNAME = org.opendaylight.yangtools.yang.common.QName.create("urn:opendaylight:model:match:types","2013-10-26","match")
    ;

    EthernetMatch getEthernetMatch();
    
    Icmpv4Match getIcmpv4Match();
    
    Icmpv6Match getIcmpv6Match();
    
    /**
    **/
    NodeConnectorId getInPhyPort();
    
    /**
    **/
    NodeConnectorId getInPort();
    
    IpMatch getIpMatch();
    
    Layer3Match getLayer3Match();
    
    Layer4Match getLayer4Match();
    
    Metadata getMetadata();
    
    ProtocolMatchFields getProtocolMatchFields();
    
    Tunnel getTunnel();
    
    VlanMatch getVlanMatch();

}

</source>
</td>
</tr>
</table>

= opendaylight-action-types module =
The pieces of code used in following examples are from:<br />
'''module:''' ''opendaylight-action-types''<br />
'''namespace:''' ''urn:opendaylight:action:types''<br />
'''revision:''' ''2013-11-12''.<br />
The complete source code of this module can be found at this [[Yang_Tools:Code_Generation_Demo:YANG2JAVA_Mapping:opendaylight-action-types_module | page]]
== mapping of action grouping ==
In following sections the mapping of YANG <code>grouping</code> '''action''' statement will be detailed discussed. Because of its big complexity the whole grouping is shown in following table in three columns and in following sections irrelevant parts of the model are omitted.
<table border="1">
<tr>
    <th>YANG (part1)</th>
    <th>YANG (part2)</th>
    <th>YANG (part3)</th>
</tr>
<tr>
<td>
<source>

grouping action {
    choice action {
        case output-action-case {
            container output-action {
                leaf output-node-connector {
                    type inet:uri;
                }
                
                leaf max-length {
                    type uint16;
                }
            }
        }

        case controller-action-case {
            container controller-action {
             leaf max-length {
                 type uint16;
             }
         }
        }
         


        case set-field-case {
            container set-field {
                 uses match:match;
             }
         }
         

        case set-queue-action-case {
            container set-queue-action {
             leaf queue {
                 type string; 
             }
             leaf queue-id {
                 type uint32; 
             }
         }
        }

        case pop-mpls-action-case {
            container pop-mpls-action {
             leaf ethernet-type {
                 type uint16; // TODO: define ethertype type
             }
         }
        }


        case set-mpls-ttl-action-case {
            container set-mpls-ttl-action {
             leaf mpls-ttl {
                 type uint8;
             }
         }
        }

        case set-nw-ttl-action-case {
            container set-nw-ttl-action {
             leaf nw-ttl {
                 type uint8;
             }
         }
        }


        case push-pbb-action-case {
            container push-pbb-action {
             leaf ethernet-type {
                 type uint16; // TODO: define ethertype type
             }
         }
        }


        case pop-pbb-action-case {
            container pop-pbb-action {
             
         }
        }
         

        case push-mpls-action-case {
            container push-mpls-action {
             leaf ethernet-type {
                 type uint16; // TODO: define ethertype type
             }
         }
        }
         

        case dec-mpls-ttl-case {
            container dec-mpls-ttl {
            }
         }
      

        case dec-nw-ttl-case {
            container dec-nw-ttl {
            }
         }
         

        case drop-action-case {
            container drop-action {
            }
         }
</source>
</td>
<td>
<source>            

        case flood-action-case {
            container flood-action {
            }
         }
         

        case flood-all-action-case {
            container flood-all-action {
            }
         }
         

        case hw-path-action-case {
            container hw-path-action {
            }
         }
         

        case loopback-action-case {
            container loopback-action {
            }
         }
         

        case pop-vlan-action-case {
            container pop-vlan-action {
            }
         }
         
        
        
        case push-vlan-action-case {
            container push-vlan-action {
                leaf ethernet-type {
                     type uint16; // TODO: define ethertype type
                }
                leaf tag {               // TPID - 16 bits
                    type int32;
                } 
                leaf pcp {               // PCP - 3 bits
                    type int32;
                }
                leaf cfi {               // CFI - 1 bit (drop eligible)
                    type vlan-cfi;
                }
                leaf vlan-id {           // VID - 12 bits
                    type l2t:vlan-id;
                }
            }
         }
        
        case copy-ttl-out-case {
            container copy-ttl-out {
            }
         }
         

        case copy-ttl-in-case {
            container copy-ttl-in {
            }
         }
         

        case set-dl-dst-action-case {
            container set-dl-dst-action {
             leaf address {
                 type yang:mac-address;
             }
            }  
        }
         

        case set-dl-src-action-case {
            container set-dl-src-action {
             leaf address {
                 type yang:mac-address;
             }
         }

        }
        case group-action-case {
            container group-action {
             leaf group {
                 type string;
             }
            
            leaf group-id {
                type uint32;
            }
         }
        }
        
        case set-dl-type-action-case {
            container set-dl-type-action {
             leaf dl-type {
                 type l2t:ether-type;
             }
         }
        }
        

        case set-next-hop-action-case {
            container set-next-hop-action {
             uses address;
         }
        }
</source>
</td>
<td>
<source>          

        case set-nw-dst-action-case {
            container set-nw-dst-action {
             uses address;            
         }
        }
         

        case set-nw-src-action-case {
            container set-nw-src-action {
             uses address;            
         }
        }
         

        case set-nw-tos-action-case {
            container set-nw-tos-action {
             leaf tos {
                 type int32;
             }
         }
        }
         

        case set-tp-dst-action-case {
            container set-tp-dst-action {
             leaf port {
                 type inet:port-number;
             }                
         }

        }
        case set-tp-src-action-case {
            container set-tp-src-action {
             leaf port {
                 type inet:port-number;
             }                
         }

        }
        case set-vlan-cfi-action-case {
            container set-vlan-cfi-action {
             leaf vlan-cfi {
                 type vlan-cfi;
             }
         }
        }
         

        case set-vlan-id-action-case {
            container set-vlan-id-action {
             leaf vlan-id {
                 type l2t:vlan-id;
             } 
         }
        }
         

        case set-vlan-pcp-action-case {
            container set-vlan-pcp-action {
             leaf vlan-pcp {
                 type l2t:vlan-pcp;
             }            
         }
        }

        case strip-vlan-action-case {
            container strip-vlan-action {
            }
         }

        case sw-path-action-case {            
            container sw-path-action {
            }  
         }  
     }
 }

</source>
</td>
</tr>
</table>
The <code>grouping</code> '''action''' contains only one child node - YANG <code>choice</code> '''action'''. The <code>choice</code> contains many cases which will be discussed latter.<br />
<code>grouping</code> '''action''' with <code>choice</code> is mapped to JAVA <code>interface</code> '''Action''' with only one getter method<br /> <code>org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.Action getAction()</code>. The returning value of this method represents YANG <code>choice</code> '''action''' statement.<br /> 
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
<td>
<source>
//code omitted
grouping action {
    choice action {
//contains several cases, will be discussed later
    }
}
//code omitted
</source>
</td>
<td>
<source lang="java">
package org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112;
import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.common.QName;


/**
**/
public interface Action
    extends
    DataObject
{



    public static final QName QNAME = org.opendaylight.yangtools.yang.common.QName.create("urn:opendaylight:action:types","2013-11-12","action")
    ;

    org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.Action getAction();

}

</source>
</td>
</tr>
</table> 
=== YANG choice and case mapping ===
YANG <code>choice</code> '''action''' statement which is included in <code>grouping</code> '''action''' is mapped to other JAVA <code>interface</code> also with name '''Action''' as shown below.
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
<td>
<source>
//code omitted
choice action { 
//    case output-action-case {
// some code omitted. see details in next section
//    } 
}
//code omitted

</source>
</td>
<td>
<source lang="java">
package org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action;
import org.opendaylight.yangtools.yang.binding.DataContainer;


/**
**/
public interface Action
    extends
    DataContainer
{





}
</source>
</td>
</tr>
</table>

The YANG <code>case</code> statement is mapped to JAVA <code>interface</code> which extends JAVA <code>interface</code> generated for YANG <code>choice</code>.<br /> For example YANG <code>case</code> '''output-action-case''' is mapped to JAVA <code>interface</code> '''OutputActionCase''' which extends <code>org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.Action</code> which is generated for YANG <code>choice</code> '''Action''' (see table below). JAVA <code>interface</code> '''OutputActionCase''' also contains getter method <code>OutputAction getOutputAction()</code>. JAVA '''OutputAction''' return type will be discussed in next section.<br />
Remaining YANG <code>case</code>s which are specified at section [[#mapping of action grouping |mapping of action grouping]] will be mapped in similar way.

<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
<td>
<source>
//choice action { 
    case output-action-case {
        container output-action {
// some code omitted. see details in next section
        }
    }
//}
</source>
</td>
<td>
<source lang="java">
package org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.action;
import org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.action.output.action._case.OutputAction;
import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.Action;
import org.opendaylight.yangtools.yang.common.QName;


/**
**/
public interface OutputActionCase
    extends
    DataObject,
    Augmentable<org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.action.OutputActionCase>,
    Action
{



    public static final QName QNAME = org.opendaylight.yangtools.yang.common.QName.create("urn:opendaylight:action:types","2013-11-12","output-action-case")
    ;

    OutputAction getOutputAction();

}


</source>
</td>
</tr>
</table>

=== YANG container mapping ===
YANG <code>container</code> '''output-action''' is mapped to JAVA <code>interface</code> '''OutputAction'''. For each YANG child node of this container (in this example just leaf but in general also e.g. leaf-list, list or other container are permitted) is generated concrete getter method:

*<code>Integer getMaxLength();</code> - for YANG <code>leaf</code> '''max-length'''. The type for this leaf (<code>uint16</code>) is YANG built-in type.
*<code>Uri getOutputNodeConnector();</code> - for YANG <code>leaf</code> '''output-node-connector'''. The type for this leaf (<code>inet:uri</code>) <span style="color:red">'''is not'''</span> YANG built-in type and mapping is explained in following section.

See the complete mapping of <code>container</code> '''output-action''' in table below:
{| class="wikitable"
|-
! YANG
! JAVA
|-
|
<source>
// code omitted
//case output-action-case {
    container output-action {
        leaf output-node-connector {
            type inet:uri;
        }
    
        leaf max-length {
            type uint16;
        }
    }
//}
/// code omitted
</source>
|<source lang="java">
package org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.action.output.action._case;
import org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924.Uri;
import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import org.opendaylight.yangtools.yang.common.QName;


/**
**/
public interface OutputAction
    extends
    DataObject,
    Augmentable<org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.action.output.action._case.OutputAction>
{



    public static final QName QNAME = org.opendaylight.yangtools.yang.common.QName.create("urn:opendaylight:action:types","2013-11-12","output-action")
    ;

    /**
    **/
    Integer getMaxLength();
    
    /**
    **/
    Uri getOutputNodeConnector();

}

</source>

|}

=== YANG leaf with <font color="red">not build-in type</font color> mapping ===
For YANG leaf and leaf-list can be used in type substatement type which isn't from set of built-in type. Not built-in type has to be defined through YANG <code>typedef</code> keyword in:
* the same module - referenced only with its name
* the other module - referenced in format <code>module_prefix_id:type_name_id</code>

Below are two tables. In first one is example of using type from other module. The type is referenced as <code>inet:uri</code>. <code>inet</code> represents prefix identificator of module and which is specified at the begining of YANG module. <br />
In second table is concrete mapping of <code>typedef</code> '''uri''' to JAVA code.
The YANG <code>typedef</code> is mapped to JAVA class. <code>typedef</code> substatement <code>type</code> is mapped to JAVA class attribute which is of type:
<ul>
<li>default JAVA class if YANG <code>type</code> argument is built-in YANG type - according to specified [[YANG_Tools:YANG_to_Java_Mapping#Type's valid arguments | maping]] between built-in YANG types and JAVA </li>
<li>generated JAVA class if YANG <code>type</code> argument <font color="red">isn't</font color> built-in YANG type</li>
</ul>
In this case argument of YANG <code>type</code> substatement is <code>string</code> which is built in type and the class attribute type is mapped according to [[YANG_Tools:YANG_to_Java_Mapping#Type's valid arguments | maping]] to JAVA <code>String</code> class.

<table border="1">
<tr>
    <th colspan="2">module opendaylight-action-types</th>
</tr>
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
<td>
<source>
//code omitted
import ietf-inet-types {prefix inet; revision-date "2010-09-24";}
// code omitted
//        leaf output-node-connector {
            type inet:uri;
//        }
// code omitted
</source>
</td>
<td>
<source lang="java">
</source>
</td>
</tr>
</table>


<table border="1">
<tr>
    <th colspan="2">module ietf-inet-types</th>
</tr>
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
<td>
<source>
//code omitted
   typedef uri {
     type string;
     description
      "The uri type represents a Uniform Resource Identifier
       (URI) as defined by STD 66.

       Objects using the uri type MUST be in US-ASCII encoding,
       and MUST be normalized as described by RFC 3986 Sections
       6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary
       percent-encoding is removed, and all case-insensitive
       characters are set to lowercase except for hexadecimal
       digits, which are normalized to uppercase as described in
       Section 6.2.2.1.

       The purpose of this normalization is to help provide
       unique URIs.  Note that this normalization is not
       sufficient to provide uniqueness.  Two URIs that are
       textually distinct after this normalization may still be
       equivalent.

       Objects using the uri type may restrict the schemes that
       they permit.  For example, 'data:' and 'urn:' schemes
       might not be appropriate.

       A zero-length URI is not a valid URI.  This can be used to
       express 'URI absent' where required.

       In the value set and its semantics, this type is equivalent
       to the Uri SMIv2 textual convention defined in RFC 5017.";
     reference
      "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax
       RFC 3305: Report from the Joint W3C/IETF URI Planning Interest
                 Group: Uniform Resource Identifiers (URIs), URLs,
                 and Uniform Resource Names (URNs): Clarifications
                 and Recommendations
       RFC 5017: MIB Textual Conventions for Uniform Resource
                 Identifiers (URIs)";
   }
// code omitted
</source>
</td>
<td>
<source lang="java">
package org.opendaylight.yang.gen.v1.urn.ietf.params.xml.ns.yang.ietf.inet.types.rev100924;
import java.beans.ConstructorProperties;


/**
  The uri type represents a Uniform Resource Identifier
         (URI) as defined by STD 66.
  
         Objects using the uri type MUST be in US-ASCII encoding,
         and MUST be normalized as described by RFC 3986 Sections
         6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary
         percent-encoding is removed, and all case-insensitive
         characters are set to lowercase except for hexadecimal
         digits, which are normalized to uppercase as described in
         Section 6.2.2.1.
  
         The purpose of this normalization is to help provide
         unique URIs.  Note that this normalization is not
         sufficient to provide uniqueness.  Two URIs that are
         textually distinct after this normalization may still be
         equivalent.
  
         Objects using the uri type may restrict the schemes that
         they permit.  For example, 'data:' and 'urn:' schemes
         might not be appropriate.
  
         A zero-length URI is not a valid URI.  This can be used to
         express 'URI absent' where required.
  
         In the value set and its semantics, this type is equivalent
         to the Uri SMIv2 textual convention defined in RFC 5017.
**/
public class Uri
 {
    final private String _value;

    @ConstructorProperties("value")
    public Uri(String _value) {
        this._value = _value;
    }
    /**
     * Creates a copy from Source Object.
     *
     * @param source Source object
     */
    public Uri(Uri source) {
        this._value = source._value;
    }
    
    public static Uri getDefaultInstance(String defaultValue) {
        return new Uri(defaultValue);
    }

    public String getValue() {
        return _value;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((_value == null) ? 0 : _value.hashCode());
        return result;
    }

    @Override
    public boolean equals(java.lang.Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        Uri other = (Uri) obj;
        if (_value == null) {
            if (other._value != null) {
                return false;
            }
        } else if(!_value.equals(other._value)) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        StringBuilder builder = new StringBuilder("Uri [");
        boolean first = true;
    
        if (_value != null) {
            if (first) {
                first = false;
            } else {
                builder.append(", ");
            }
            builder.append("_value=");
            builder.append(_value);
         }
        return builder.append(']').toString();
    }


}

</source>
</td>
</tr>
</table>

=== YANG uses mapping ===
YANG <code>container</code> which contains <code>uses</code> keyword is mapped to JAVA <code>interface</code> which extends interface specified as <code>uses</code> argument.
In following example <code>container</code> '''set-field-case''' is mapped to JAVA <code>interface</code> '''SetField''' and <code>uses match:match</code> is mapped to '''Match''' word which is in <code>extends</code> part of '''SetField''' class declaration. <code>uses</code> contains as argument name of <code>grouping</code> which is specified in other part of module(s). As was mentioned before <code>grouping</code> is mapped to interface and therefore can be used in <code>extends</code> part of class declaration.
<table border="1">
<tr>
    <th>YANG</th>
    <th>JAVA</th>
</tr>
<tr>
<td>
<source lang="java">
//code omitted
//case set-field-case {
    container set-field {
         uses match:match;
     }
// }
//code omitted
</source>
</td>
<td>
<source lang="java">
package org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.action.set.field._case;
import org.opendaylight.yangtools.yang.binding.DataObject;
import org.opendaylight.yangtools.yang.binding.Augmentable;
import org.opendaylight.yang.gen.v1.urn.opendaylight.model.match.types.rev131026.Match;
import org.opendaylight.yangtools.yang.common.QName;


/**
**/
public interface SetField
    extends
    DataObject,
    Augmentable<org.opendaylight.yang.gen.v1.urn.opendaylight.action.types.rev131112.action.action.set.field._case.SetField>,
    Match
{



    public static final QName QNAME = org.opendaylight.yangtools.yang.common.QName.create("urn:opendaylight:action:types","2013-11-12","set-field")
    ;


}
</source>
</td>
</tr>
</table>
