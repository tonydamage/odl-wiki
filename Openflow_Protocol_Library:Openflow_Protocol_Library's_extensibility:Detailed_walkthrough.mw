= Deserialization extensibility =
=== External interface & class description ===
<u>'''OFGeneralDeserializer:'''</u>
* '''OFDeserializer<E extends DataObject>'''
** ''deserialize(ByteBuf)'' – deserializes given ByteBuf
* '''HeaderDeserializer<E extends DataObject>'''
** ''deserializeHeaders(ByteBuf)'' - deserializes only E headers (used in Multipart TableFeatures messages)


'''DeserializerRegistryInjector'''
* ''injectDeserializerRegistry(DeserializerRegistry)'' – injects deserializer registry into deserializer. Useful when custom deserializer needs access to other deserializers.

'''NOTE:''' DeserializerRegistryInjector is not OFGeneralDeserializer descendand. It is a standalone interface.


'''MessageCodeKey and EnhancedMessageCodeKey''' <br />
These keys are used as for deserializer lookup in DeserializerRegistry. <br />
MessageCodeKey should be used in general, when it is enough to identify corresponding deserializer by its value and Object class. EnhancedMessageCodeKey should be used in cases, when one value for Object class is not enough.

MessageCodeKey has these fields:
* ''short version'' – Openflow wire version number
* ''int value'' – value read from byte message
* ''Class<?> clazz - class of object being creating

EnhancedMessageCodeKey extends MessageCodeKey and has one more field:
* ''int value2'' – more specific distinguisher (usually specific type of ''value'')


=== Scenario walkthrough ===
[1] The scenario starts in a custom bundle which wants to extend library's functionality. The custom bundle creates deserializers which implement exposed OFDeserializer / HeaderDeserializer interfaces (wrapped under OFGeneralDeserializer unifying super interface).

[2] Created deserializers are paired with '''MessageCodeKey'''-s, which are used for deserializer lookup. <br />
In special cases, it might not be enough to have only one distinguishing value. Oxm match fields are such case. One needs to know oxm_class and also oxm_field to be able to determine which match entry it is. In this case, it is needed to use '''EnhancedMessageCodeKey'''.<br />

[3] Paired deserializers are passed to the OF Library via '''SwitchConnectionProvider'''''.registerCustomDeserializer(key, impl)''. Library registers the deserializer.
* While registering, Library checks if the deserializer is an instance of '''DeserializerRegistryInjector''' interface. If yes, the DeserializerRegistry (which stores all deserializer references) is injected into the deserializer.
This is particularly useful when the deserializer needs access to other deserializers. For example IntructionsDeserializer needs access to ActionsDeserializer in order to be able to process OFPIT_WRITE_ACTIONS/OFPIT_APPLY_ACTIONS instructions.
<br />


[[File:Extensibility.png | center | 800px | Deserialization extensibility]]


= Serialization extensibility =
=== External interface & class description ===
<u>'''OFGeneralSerializer:'''</u>
* '''OFSerializer<E extends DataObject>'''
** ''serialize(E,ByteBuf)'' – serializes E into given ByteBuf
* '''HeaderSerializer<E extends DataObject>'''
** ''serializeHeaders(E,ByteBuf)'' – serializes E headers (used in Multipart TableFeatures messages)


'''SerializerRegistryInjector'''
* ''injectSerializerRegistry(SerializerRegistry)'' – injects serializer registry into serializer. Useful when custom serializer needs access to other serializers.

'''NOTE:''' SerializerRegistryInjector is not OFGeneralSerializer descendand.


'''MessageTypeKey and EnhancedMessageTypeKey''' <br />
These keys are used as for serializer lookup in SerializerRegistry. <br />
MessageTypeKey should be used in general, when it is enough to identify corresponding serializer by its DTO class. EnhancedMessageTypeKey should be used in cases, when one DTO class is not enough.

MessageTypeKey has these fields:
* ''short version'' – Openflow wire version number
* ''Class<E> msgType'' – DTO class

EnhancedMessageTypeKey extends MessageTypeKey and has one more field:
* ''Class<E> msgType2'' – more specific distinguisher (usually specific type of msgType)


=== Scenario walkthrough === 
[1] Serialization extensbility principles are similar to the deserialization principles. The scenario starts in a custom bundle. The custom bundle creates serializers which implement exposed OFSerializer / HeaderSerializer interfaces (wrapped under OFGeneralSerializer unifying super interface).

[2] Created serializers are paired with '''MessageTypeKey'''-s, which are used for serializer lookup. <br />
In special cases, it might not be enough to have only one distinguishing type. Oxm match fields are such case. One needs to know oxm_class and also oxm_field to be able to determine which match entry it is. In this case, one can use '''EnhancedMessageTypeKey'''.<br />

[3] Paired serializers are passed to the OF Library via '''SwitchConnectionProvider'''''.registerCustomSerializer(key, impl)''. Library registers the serializer.
* While registering, Library checks if the serializer is an instance of '''SerializerRegistryInjector''' interface. If yes, the SerializerRegistry (which stores all serializer references) is injected into the serializer.
This is particularly useful when the serializer needs access to other deserializers. For example IntructionsSerializer needs access to ActionsSerializer in order to be able to process OFPIT_WRITE_ACTIONS/OFPIT_APPLY_ACTIONS instructions.
<br />


[[File:Extensibility2.png | center | 800px | Serialization extensibility]]


= Internal description =
==== SwitchConnectionProvider ====
SwitchConnectionProvider constructs and
initializes both deserializer and serializer registries with default
(de)serializers. It also injects the DeserializerRegistry into the
DeserializationFactory, the SerializerRegistry into the SerializationFactory. <br />
When call to register custom (de)serializer
is made, SwitchConnectionProvider calls register method on appropriate registry.

==== DeserializerRegistry / SerializerRegistry ====
Both registries contain init() method to initialize default (de)serializers. <br />
Registration checks if key or (de)serializer
implementation are not null. If at least one of the is null,
NullPointerException is thrown. Else the (de)serializer implementation is
checked if it is (De)SerializerRegistryInjector instance. If it is an instance
of this interface, the registry is injected into this (de)serializer
implementation.
 
GetSerializer(key) or GetDeserializer(key)
performs registry lookup. Because there are two separate interfaces that might
be put into the registry, the registry uses their unifying super interface.
Get(De)Serializer(key) method casts the super interface to desired type. There
is also a null check for the (de)serializer received from the registry. If the
deserializer wasn’t found, NullPointerException with key description is thrown.
