==Technical Architecture==
===Overview===
We propose a southbound plugin that can control the off-the-shelf commodity Ethernet switches for the purpose of building SDN using Ethernet switches. For Ethernet switches, forwarding table and ACL are where one can install the flow configuration on, and this is done via SNMP and CLI in the proposed plugin. In addition, extensions to the SAL configuration APIs are needed to provide additional API to support some settings, e.g. disabling STP and flooding, etc, which are required for Ethernet switches in SDN.

[[File:SNMP4SDN_in_ODL_Architecture.jpg|500px]]

'''Figure. SNMP4SDN as a southbound plugin in OpenDaylight architecture'''

===Architecture===
The modules in the plugin are depicted as the following figure. 

[[File:snmp4sdn_modules.jpg|400px]]

'''Figure. Modules in the SNMP4SDN plugin'''

* FlowProgrammerService: to add/modify/remove flows on the switches.
* ReadService: to acquire the flow's or switch's or port's statistics.
* InventoryService: to acquire the switches’ and their ports’ properties.
* DiscoveryService: to probe and resolve the underlying switches as well as the port pairs connecting the switches. The probing is realized by SNMP queries. The updates from discovery will also be reflected to the TopologyService.
* TopologyService: to query and acquire the switches' topology.
* ConfigService: to do kinds of vendor-specific proprietary settings on switches
** Supported vendor-specific proprietary settings, such as: to disable kind of flooding (BPDU flooding, broadcast flooding, multicast flooding, and unknown flooding), disabling source mac check and source learning, and setting SNMP host and community.

For the services above, when they need to read or configure the underlying switches via SNMP or CLI, these queries are dealt with the modules SNMPHandler and CLIHandler which directly talk with the switches.

===Design===
In terms of the architecture of the SNMP4SDN plugin’s features, the features include flow configuration, topology discovery, proprietary configuration, statistic retrieving, and switch/port property retrieving. Their architectures are as follows.

====Flow configuration====
FlowProgrammer implements the SAL API, IPluginInFlowProgrammerService. FlowProgrammer is in charge of listening to the flow given from upper layer and pass it to the MessageReadWriteService, which maintains command sending queue of the specific switch, and then SNMPHandler or CLIHandler will be called to send the command out to the switch. (SNMPHandler is to handle configurations on forwarding table, which can be done via SNMP, CLIHandler is to handle configurations on ACL)

[[File:snmp4sdn_arch_flow_config.jpg|250px]]

'''Figure. Flow configuration'''

====Topology discovery====
A topology consists of the elements, including switches, ports, and edges. For the switches, in the plugin’s initialization, given a switch list (a switch list database file), the plugin’s core would create a SwitchHandler instance for every switch, and inform each SwitchHandler of the new switch. As for the ports of every switch, the plugin’s core uses SNMPHandler to query the number of ports on the switch, and inform the corresponding SwitchHandler of the new ports. As for edges, upon informed of new port, SwitchHandler calls DiscoveryService to read LLDP data on the switch, so the edges are finally resolved.

[[File:SNMP4SDN_TopologyDiscovery.jpg|400px]]

'''Figure. Topology discovery by resolving LLDP data on every switche'''

[[File:snmp4sdn_arch_topo_discover_update.jpg|500px]]

'''Figure. Topology discovery and update'''

====New switch detection====
Ethernet switches were not designed to behave like OpenFlow switches to proactively connect to the controller, since in tradition it is not assumed to have a central controller above. Therefore, the approach for Ethernet switch to proactively notify the controller of its existence could be: using SNMP trap. That is, every Ethernet switch is (1) configured with its SNMP host (i.e. the controller’s IP address) and (2) configured to send SNMP trap when the switch boots up. (1) and (2) are supported in general and needs to be configured manually via CLI for only once. In this way, the controller will know a switch joining in, when receiving the switch’s SNMP trap of booting up.

[[File:SNMP4SDN_SwitchDiscovery.jpg | 500px]]

'''Figure. Switch discovery by means of SNMP trap'''

====Proprietary configuration====
To enable generic Ethernet switch to become SDN device, functions for decentralization purposes, such as broadcast flooding, source learning, etc, needs to be disabled. Especially, these functions are usually configured via CLI. As the figure below, ConfigService exposes all the proprietary functions to users, and from the user input, it retrieves the switch’s IP address and port number to CLIHandler. Then CLIHandler uses then IP address and port number to translate out a CLI command string. This string is passed to ExpectHandler to send to the switch. With this architecture, for different Ethernet switch products, developers only need to rewrite the vendor-specific CLI command strings in CLIHandler.

[[File:snmp4sdn_arch_config_service.jpg|300px]]

'''Figure. Proprietary configuration'''

====Statistic retrieving====
ReadService is in charge of listening to the query from upper layer, and passes the request to the StatisticMangager with the target switch’s ID, then the specific SwitchHandler calls CLIHandler to query the switch for statistics.

[[File:snmp4sdn_arch_statistic_retrive.jpg|250px]]

'''Figure. Statistic retrieving'''

====Switch/port property retrieving====
InventoryService is in charge of listening to the query from upper layer and call CLIHandler to request the switch for properties.

==Installation Guide==
[[SNMP4SDN:Installation_Guide|Installation Guide]]

==Installation Troubleshooting==
None

==Configuration==
[[SNMP4SDN:User_Guide#Configuration|Configuration]]

==Tutorial / How-To==
Step-by-step instructions for doing some basic functionality with this project

==Command Line Interface==
If applicable, hyperlinks to the relevant section(s) of the user guide 

==Programmatic Interface(s)==
If applicable, hyperlink(s) to the relevant sections of the Developer Guide
* Getting Started – Should cover topics like authentication, common error codes, etc.
* API Documentation – Detailed documentation of the API(s) – If this can be auto-generated, try provide the object and verb hierarchy and hyperlinks to the auto-generated documentation
** Per-Object
*** Per-Method / Verb / Operation
**** Description – Brief description of the interface
**** Request – Example request followed by tabular description of the parameters (ex: Name, Format, Required/Optional, Description, Example, Limits)
**** Response –Example response follow by tabular description of the parameters
