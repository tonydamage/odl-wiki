
== REST API recommendations for V2 ==
This document only applies to V2 of the APIs

Given that the resource path hierarchies have already been defined for v2 (version#2) of the controller REST APIs, we are limited in the flexibility that we have in addressing issues.  This document provides general recommendations when updating and adding Noththbound REST APIs to ensure that the APIs are consistent from an end-users perspective when consuming these APIs when addressing the problems.

Currently the following NB modules are using the recommendations. Newer modules can adopt proper recommendations if they are not dependent on the already defined resource types.

=== Components of a NB REST bundle ===

JAX-RS root resource (a java class) annotated with @javax.ws.rs.Path services the requests. This is usually named as <ComponetName>NorthBound.java

* WEB-INF/web.xml - web application configuration
:*  Includes Jersey Servlet registration.
:*  The declaration of the org.opendaylight.controller.northbound.commons.NorthboundApplication
* pom.xml
:* Web-ContextPath - the context path with which the bundle will be registered with Tomcat. This is the name which is used to invoke the service over http.
:* Jaxrs-Resources - The root resource classes (automatically inserted into MANIFEST by BND plugin)
* enunciate.xml
:* Defines the RestSubContext and the title for the auto generated docs.
:* Dependencies of a NB REST bundle

=== commons.northbound bundle - provides common services ===
org.opendaylight.controller.northbound.commons.NorthboundApplication is the core class where most of the magic happens (Jackson JSON Provider registration, auto detection of JAXB types etc.). This class (or a subclass) should be declared as the javax.ws.rs.Application in the web.xml to take advantage of the common services.

Bundle scanner service - Bundles are scanned for JAXB & JAX-RS annotated types during bundle resolution. This allows us to inject these types into the JAXBContext without the user explicitly declaring them using @XmlSeeAlso annotation. The bundle scanner is leveraged in the NorthboundApplication class so any NB bundle extending for this automatically gets the services.

=== Creating a new NB REST bundle ===

The easiest way of introducing a new NB REST API is to copy an existing one and making the relevant changes as below:
# pom.xml – update the artifact-name , Web-ContextPath and dependencies.
# enunciate.xml – update the defaultRestSubContext and the description 
# src/main/java/…/*Northbound*.java – Rename/Update the request handler and the necessary logic as required.
# src/main/test/… - Add necessary unit tests.
# commons/northbound-integrationtest module - Add necessary integration tests.
# Reference the bundle from the distribution assembly descriptor to be included in the distribution.

=== Recommendations ===

* JAX-RS root resources should be named as <ComponentNam>Northbound.java
:* Eg: SubnetsNorthbound, HierarchyNorthbound.
* Resource naming
:* Ensure you use the same name and format if a resource is already being used in the existing NB REST APIs.
::* Eg:  @Path("/{containerName}/subnet/{subnetName}")
::* Eg:  @Path("/{containerName}/node/{nodeType}/{nodeId}/staticFlow/{name}")
:* Ensure you qualify a resource by its type in the URI
::* Eg:  Use /customer/1234/order/666 instead of /customer/order/1234/666
* When retrieving a listing of resources with GET ensure that we use a plural for the resource type being listed
:* Eg:  @Path("/{containerName}/subnets")
:* Eg:  @Path("/{containerName}/userLinks")
* If a resource type is common, attempt to abstract it out to commons-northbound module for reuse.
:* Eg: Specialized aggregation types (StringList, StringProperty etc.)
* Creating a resource (PUT is preferred and recommended. See PUT vs POST discussion below)
:* Use PUT (for most cases) 
::* If resource path of the resource to be created is already known.  
::* Ensure the method is idempotent (from the server state perspective).  
:* Use POST (for limited usecases) 
::* If the resource path of the resource to be created is not known before hand by the client.  
::* Ensure that the response contains a 'Location' header pointing to the URI of the resource(s) created by the server. 
:* Respond with response status 201 when the operation is successful (CREATED) 
:* In case of conflicts respond with an appropriate error message.
* GET, PUT and DELETE are idempotent. Ensure you follow the rules of idempotency when writing the service methods.
* The use of @QueryParams is reserved for filtering and pagination (for retrieve operations) and should be avoided for mutate (PUT, POST, DELETE) operations.
* Avoid the use of @XmlAttribute types
:* JSON handles attributes by prefixing the names with ‘@’. While attributes make XML less verbose, JSON interpretation can be a little confusing when differentiating between elements and attributes. As a general rule we should avoid the use of attributes.

PUT vs POST
Both PUT and POST can be used for creating and modifying resources. The main difference between them is that PUT is idempotent (repeating a request multiple times shouldn't change the state of the server). For this project, we are recommending using PUT for creating resources because looking at all the current usages, in most of the cases the client knows the URL to the resource being created. For the limited cases where the client is unsure about the resource path, POST should be used.

CamelCase vs Snake_case
Always use camelCase to represent data types in the request and response payloads. If a resource type is being used in a URI and it is already represented in a request/resource body, try to use the same representation.
Handling Errors

Use the proper response code when encountering errors.
400 level errors are appropriate in most cases involving user input.
500 (INTERNAL_SERVER_ERROR) should only be used in cases where we are unable to determine the root cause. 
Use org.opendaylight.controller.northbound.commons.utils.NorthboundUtils to convert Status to a proper response messages.
Details on the commonly used HTTP response codes can be found at
http://docs.oracle.com/javaee/6/api/javax/ws/rs/core/Response.Status.html
http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.3
Documentation

We use enunciate to generate the REST API documentation. Enunciate works off the javadoc comments that the JAXB types are annotated with. Its important that all JAXB types hava proper javadoc comments.

Read enunciate generated docs for the REST API you are exposing. (You can locate the generated docs at target/site/wsdocs/index.html after building the module.)
Ensure that all the methods are properly documented with examples. HTTP requests can be sent out by using ‘curl’, ‘wget’ or another tool to get the actual HTTP headers and responses.
Enunciate configuration can be found in enunciate.xml 
References

RESTful Best Practices
RESTFul Web Services
REST cookbook
