== AD-SAL Overview ==
AD-SAL is a flavor of the Service Abstraction Layer created for the Controller project, whose task is primarily to create a layer against which the applications can be developed without assuming the underlying SDN protocol it's talking about. The logic has been created when there has been a need to control two different type of network elements in an SDN fashion, meaning by accessing them in a programmatic way. It was clear that irrespective of the different types of network element certain things would still be applicable, practical and simple examples are:

* Given a Network Element i want to know who my neighbors are and build the network graph
* Given a Network Element i want to know what interfaces are attached to it and what properties they carry
* etc ..... 

Starting from this assumption that certain aspects of the SDN protocols would anyway be common no matter what the actual protocol is doing underneath prompted for the idea those aspects could be described in a generic way via a Java Contract (usually a set of Java Interfaces and supporting Objects that represent the data). This way of creating contracts that allows a consumer of the contract to be insulated by the possible implementation is rather common in the Java world, where for example there are contracts like:

* [https://www.jcp.org/en/jsr/detail?id=315 Servlet 3.0]
* [http://en.wikipedia.org/wiki/Jax-rs JAX-RS]

which are described by a [http://en.wikipedia.org/wiki/Java_Specification_Request JSR] (Java Specification Request) which then can be implemented by different providers. For example Servlet 3.0 contracts could be implemented by Tomcat or Jetty or other servlet container. By going by the same analogy the protocol plugins (i.e. the components that can understand an SDN protocol and convert to the common layer) can implement one or more of these contracts based on the capabilities.
The Service Abstraction Layer defined in AD-SAL is just an adaptation layer to enable the protocol plugins to speak common aspects but only if they can do it. The service abstraction layer in fact doesn't force a lowest common denominator for all to be spoken, but rather given a certain aspect if the protocol plugins supports it it will be supported in a common fashion. Lets take as example the picture below:
