                  
<div  class="WordSection1"> 
[[Image:image002.png]] [[Image:image004.png]]

 
…………………………………………………………

          
'''OpenFlow Protocol Library'''

 
Project
Documentation

             
…………………………………….…………………….

 
michal.polkorab@pantheon.sk 22 November 2013

  
<u>Table of Contents</u>

  
[[1. What is OpenFlow Protocol Library?. 3]]

 
[[2. Project structure. 4]]

 
[[2.1 Openflow-protocol-impl structure. 5]]

 
[[3. Architecture. 5]]

 
[[4. Threads. 11]]

 
[[5. Generation of sources. 11]]

 
[[6. Extensibility. 12]]

 
[[7. Message specifications. 12]]

 
[[7.1 OF 1.0 and OF 1.3 same messages handling. 12]]

 
[[7.2 OF 1.0 and OF 1.3 message differences. 13]]

 
[[7.3 OF 1.0 Vendor and Stats messages DTOs. 13]]

 
[[7.4 Using supertypes (higher types) 14]]

 
[[7.5 Signed int to unsigned long conversion and vice versa. 14]]

 
[[7.6 Augmentation tables. 14]]

 
[[7.7 Table-miss flow entry. 17]]

 
[[8. Glossary. 17]]

             
= 1.   What is OpenFlow Protocol Library? =
  
'''Introduction'''

 
OpenFlow
Protocol Library is component in OpenDaylight, that mediates communication
between OpenDaylight controller and hardware devices supporting OpenFlow
protocol.

 
OpenFlow
Protocol Library’s primary goal is to provide user (or upper layers of
OpenDaylight) communication channel, that can be used for managing network
hardware devices. This is achieved with:

 
'''Key objectives:'''

 
- 
Simultaneous support of
multiple versions of wire-protocol

 
- 
Extensibility to support
later OpenFlow versions

 
- 
Immutable transfer objects
generation

 
- 
Scalable non-blocking
implementation

 
- 
Pipeline processing

 
- 
Scatter buffer

 
- 
TLS support

  
'''Simultaneous support of multiple versions of
wire-protocol'''

 
Currently,
the OpenFlow Protocol Library has implemented translators for OpenFlow v1.0 and
OpenFlow v1.3 messages.

 
'''Extensibility to support later OpenFlow versions'''

 
Codec
part of the OpenFlow Protocol Library is designed as Map. After implementing
new translators supporting later versions of wire-protocol, it is enough to add
these new translators into map and let them decode messages to DTOs.

 
'''Immutable transfer objects generation'''

 
OpenFlow
Protocol Library shares DTOs with OpenFlow Plugin. These transfer objects are
generated, immutable and separated from serialization and deserialization
logic.

 
'''Scalable non-blocking
implementation'''

 
We
implemented communication with hardware devices by using Netty.io, which is an
asynchronous event-driven network application framework for rapid development
of maintainable high performance protocol servers &amp; clients.

 
'''Pipeline processing'''

 
The
OpenFlow Protocol Library takes advantage of Netty’s highly scalable protocol
handlers and possibility to engage them into a processing pipeline. This
mechanism provides the library with modular approach for incoming messages.
Another advantage is that the library’s pipeline can be dynamically changed if
needed.

 
'''TLS support'''

 
Library
supports TLS encryption, which is needed by OpenFlow.

   
= 2.   Project structure =
  
OpenFlow Protocol Library project name is openflowjava.
Openflowjava is also the name of parent project, which consists of these subprojects:

  
- 
Openflow-protocol-api

 
- 
Openflow-protocol-impl

 
- 
Openflow-protocol-it

 
- 
Openflow-protocol-spi

 
- 
Simple-client

  
Api contains yang files used for generating needed sources and
generated sources itself. Impl is current implementation of OpenFlow Protocol
Library. IT stands for integration test. Spi contains classes for providing
library’s functionality to other bundles. Simple client contains lightweight switch
simulator for testing purposes.

  
To
be able to use library, it is required to add following dependencies to
pom.xml:

 
&lt;dependency&gt;

 
&lt;groupId&gt;org.opendaylight.openflowjava&lt;/groupId&gt;

 
&lt;artifactId&gt;<u>openflow</u>-protocol-api&lt;/artifactId&gt;

 
&lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;

 
&lt;/dependency&gt;

  
&lt;dependency&gt;

 
&lt;groupId&gt;org.opendaylight.openflowjava&lt;/groupId&gt;

 
&lt;artifactId&gt;<u>openflow</u>-protocol-spi&lt;/artifactId&gt;

 
&lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;

 
&lt;/dependency&gt;

  
Other subprojects can be included also:

  
&lt;dependency&gt;

 
&lt;groupId&gt;org.opendaylight.openflowjava&lt;/groupId&gt;

 
&lt;artifactId&gt;<u>openflow</u>-protocol-impl&lt;/artifactId&gt;

 
&lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;

 
&lt;/dependency&gt;

  
&lt;dependency&gt;

 
&lt;groupId&gt;org.opendaylight.openflowjava&lt;/groupId&gt;

 
&lt;artifactId&gt;<u>simple-client</u>&lt;/artifactId&gt;

 
&lt;version&gt;0.1-SNAPSHOT&lt;/version&gt;

 
&lt;/dependency&gt;

  
== 2.1   Openflow-protocol-impl structure ==
  
This project consists of following packages:

 
- 
'''src/main/java'''

 
- 
'''connection''' (classes and
interfaces for communication with OFPlugin + bundle activator)

 
- 
'''core''' (tcp server and
pipeline processing handlers)

 
- 
'''deserialization''' (structures for
choosing correct decoder)

 
- 
factories
(message deserialization classes)

 
- 
'''serialization''' (structures for
choosing correct encoder)

 
- 
factories
(message serialization classes)

 
- 
'''util''' (classes for
translation common structures and work with ByteBuf)

 
- 
'''src/main/resources'''

 
- 
'''key.bin''' &amp; '''key.raw''' (bogus key for testing
purposes)

 
- 
'''log4j.xml''' (logging
settings)

 
- 
'''src/test/java''' (unit tests)

  
= 3.   Architecture =
  
As
mentioned above, OpenFlow Protocol Library uses pipeline processing, which allows
modular implementations. In the current implementation the library uses
following handlers:

 
[[Image:image006.png]]

 
OpenFlow
Protocol Library architecture

 
'''Switch Connection Provider'''

 
Connection
point for other projects. Library exposes its functionality through this class.

 
First
step is to configure desired servers. Configuration is done with a collection
of ConnectionConfiguration interfaces. Each item in this collection configures
new server. Currently there is only TCP server implemented.

 
'''Server configurable settings:'''

 
- 
Startup address
(InetAddress)

 
- 
Listening port (int)

 
- 
Transport protocol (String
“TCP” / “UDP”)

 
- 
TLS support (enum
FEATURE_SUPPORT)

 
- 
Security key provider
(object yet to be provided)

 
- 
Switch idle timeout (long)

 
TLS
support expresses the desire to use TLS encryption in message. There are three
values specified: NOT_SUPPORTED, SUPPORTED, REQUIRED.

 
- 
NOT_SUPPORTED – TLS
encryption won’t be used

 
- 
SUPPORTED – TLS encryption
will be used in case TLS has been detected, otherwise not

 
- 
REQUIRED – TLS encryption
will be used in all cases

 
NOTE:

 
In case of TLS encrypted communication with
FEATURE_SUPPORT.NOT_SUPPORTED server no messages will be translated correctly
and connection will be closed.

 
In
case of plain communication with FEATURE_SUPPORT.REQUIRED server an exception
will be thrown (inside the library) and connection will be closed.

 
Switch
idle timeout specifies the amount of time that has to elapse, after which a
SwitchIdleEvent message is sent upstream – notifying OpenFlow Plugin about
idleness of a switch. Timeout is defined in milliseconds.

 
Next step is to set
Switch Connection Handler with ''setSwitchConnectionHandler(SwitchConnectionHandler)''
method. Switch Connection Handler’s accept method decides whether the OpenFlow
Protocol Library should accept or reject incoming connection. Handler also
receives onSwitchConnected(ConnectionAdapter) notification with corresponding
Connection Adapter when a new network device connects to server.

 
Final
step is to start configured servers with startup() method.

 
Library
can be easily shutdown by calling shutdown() method.

  
[[Image:image008.png]]

 
OpenFlow
Protocol Library lifecycle

 
'''TCP Handler '''

 
Represents
single server that is handling incoming connections over TCP protocol. TCP
Handler creates a single instance of Publishing Channel Initializer that will
initialize channels. After that it binds to configured InetAddress and port. When
a new device connects, TCP Handler registers its channel and passes control to
Publishing Channel Initializer.

 
'''Publishing Channel Initializer'''

 
This
class is used for channel initialization and passing arguments. After a new
channel has been registered it calls Switch Connection Handler’s accept method
to decide if the library should keep the newly registered channel or if the
channel should be closed. If the channel has been accepted, Publishing Channel
Initializer creates ConnectionAdapter instance. This instance communicates
directly with upper layers (OpenFlow Plugin). Finally the Publishing Channel
Initializer creates the whole pipeline with needed handlers and notifies Switch
Connection Handler with onConnectionReady notification. OpenFlow Plugin can now
start sending messages downstream.

 
'''Idle State Handler'''

 
This
handler receives switch idle timeout as a parameter from
ConnectionConfiguration settings. Idle State Handler is inactive while there
are messages received within the set switch idle timeout. If there are no
messages received for more than timeout specified, handler creates
SwitchIdleEvent message and sends it upstream.

 
'''TLS Detector'''

 
Detector
is used for detecting message encryption. Encryption detection occurs only once
– on the first message received. In case messages are encrypted, TLS Detector
engages TLS Handler into pipeline, otherwise not.

 
NOTE:

 
Engaging
TLS Detector into pipeline is matter of ConnectionConfiguration (FEATURE_SUPPORT)
set in SwitchConnectionProvider before server startup.

 
'''TLS Handler'''

 
TLS
Handler is represented as a Netty’s SslHandler, which supports TLS encryption.
It encrypts and decrypts messages with configured protocol.

 
'''OF Frame Decoder'''

 
Performs
framing - decodes received byte message into message with correct length based
on OpenFlow header. If received message is shorter than minimal length of
OpenFlow message (which is OpenFlow header - 8 bytes), OF Frame Decoder waits
for more data. After receiving at least 8 bytes the decoder checks length in
OpenFlow header. If there are still some bytes missing, the decoder waits for
them. Else the OF Frame Decoder sends correct length message to next handler in
pipeline.

 
'''OF Version Detector'''

 
Detects
version of used OpenFlow Protocol and discards unsupported version messages. If
the detected version is supported, OF Version Detector creates
VersionMessageWrapper object containing version detected and byte message and
sends this object upstream.

 
'''OF Decoder'''

 
OF
Decoder receives VersionMessageWrapper object and passes it to
DeserializationFactory which will return translated DTO. DeserializationFactory
creates MessageTypeCodeKey object with version and type of received message
set. This object is used as key when searching for appropriate decoder in
DecoderTable. DecoderTable is basically a map storing decoders. Found decoder
translates received message into DTO (DataTransferObject). If there was no
decoder found, null is returned. After returning translated DTO back to OF
Decoder, the decoder checks if it is null or not. When the DTO is null, the decoder
logs this state. Else it passes the DTO further upstream. Finally, the OF
Decoder releases ByteBuf containing received and decoded byte message.

 
'''OF Encoder'''

 
OF
Encoder does the opposite than the OF Decoder using the same principle. OF
Encoder receives DTO, passes it for translation and if the result is not null,
it sends translated DTO downstream as a ByteBuf. Searching for appropriate
encoder is done via MessageTypeKey, based on version and class of received DTO.

 
'''Delegating Inbound Handler'''

 
This
handler delegates received DTO’s to Connection Adapter. It also reacts on
channelInactive and channelUnregistered events. Upon one of these events is triggered,
DelegatingInboundHandler creates DisconnectEvent message and sends it upstream,
notifying upper layers about switch disconnection.

 
'''Connection Adapter'''

 
ConnectionAdapterImpl
basically implements three interfaces (unified in one superinterface
ConnectionFacade):

 
- 
ConnectionAdapter

 
- 
MessageConsumer

 
- 
OpenflowProtocolService

  
ConnectionAdapter
interface has methods for setting up listeners (message, system and connection
ready listener), method to check if all listeners are set, checking if the
channel is alive and disconnect method. Disconnect method clears responseCache([[7]])
and disables consuming of new messages.

 
MessageConsumer
interface holds only one method: consume(). Consume() method is called from
DelegatingInboundHandler. This method processes received DTO’s based on their
type. There are three types of received objects:

 
- 
System notifications

 
- 
OpenFlow asynchronous
messages (from switch)

 
- 
OpenFlow symmetric messages
(replies to requests)

 
System
notifications invoke system notifications in OpenFlow Plugin (systemListener
set). In case of DisconnectEvent message, the Connection Adapter clears
response cache and disables consume() method processing.

 
OpenFlow
asynchronous messages invoke corresponding notifications in OpenFlow Plugin.

  
[[Image:image010.png]]

 
[[Image:image012.png]]

 
Processing
of asynchronous messages

  
OpenFlow
synchronous messages (replies to requests) create RpcResponseKey([[7]]) with
XID([[7]])
and DTO’s class set. This RpcResponseKey is then used to find corresponding
future object in responseCache. Future object is set with success flag,
received message and errors (if any occurred). In case no corresponding future
was found in responseCache, Connection Adapter logs warning and discards the
message. Connection Adapter also logs warning when an unknown DTO is received.

 
OpenflowProtocolService
interface contains all rpc-methods for sending messages from upper layers
(OpenFlow Plugin) downstream and responding. Request messages return Future
filled with expected reply message, otherwise the expected Future is of type Void.

  
[[Image:image014.png]]

 
Processing
of messages with response

 
NOTE:

 
MultipartRequest message is the only
exception. Basically it is request – reply Message type, but it wouldn’t be
able to process more following MultipartReply messages if this was implemented
as rpc (only one Future). This is why MultipartReply is implemented as
notification. OpenFlow Plugin takes care of correct message processing.

  
= 4.   Threads =
  
Library uses Netty’s threads provided by
EventLoop for processing received messages. One thread per channel. Threads are
used even for further processing until they are released. The sooner the input
/ output thread is released, the sooner the library starts to process new
message.

  
= 5.   Generation of sources =
  
The OpenFlow Protocol Library uses YANG
modeling language for generation of immutable objects. Yang processing classes
are provided by yangtools project (see pom.xml in openflow-protocol-api
project). Objects are generated from yang files located in ‘src/main/yang’
folder. To generate sources it is enough to run ‘mvn clean compile’. Generated
files will be placed into ‘target/generated-sources/sal’ folder (this is
current setup). You can see the structure and description of used yang files
below.

 
[[Image:image015.png]]

 
YANG
files under openflow-protocol-api project

  
Files:

 
- 
openflow-action – defines
base OpenFlow actions

 
- 
openflow-augments – contains
all used augmentations

 
- 
openflow-extensible-match – defines
OpenFlow OXM match

 
- 
openflow-instruction –
defines base OpenFlow instructions

 
- 
openflow-protocol – defines
OpenFlow Protocol messages

 
- 
openflow-types – defines
common OpenFlow specific types

 
- 
system-notifications – defines library’s system notifications

 
Augments are used in following structures:

 
- 
MatchEntries

 
- 
Action

 
- 
TableFeatureProperties

 
- 
Instructions

 
- 
QueueProperty

 
Example usage of augmentation (for
ofp_instruction in OpenFlow v1.3):

 
InstructionBuilder
instructionBuilder = new InstructionBuilder(); instructionBuilder.setType(GotoTable.'''class''');

 
TableIdInstructionBuilder tableBuilder = '''new'''
TableIdInstructionBuilder();

 
tableBuilder.setTableId(value);

 
builder.addAugmentation(TableIdInstruction.'''class''',
tableBuilder.build()); instructionBuilder.addAugmentation(augmentationType,
augmentation);

  
= 6.   Extensibility =
  
== 6.1   Extending the Openflow Library ==
  
Entry point for the extensibility is SwitchConnectionProvider.
SwitchConnectionProvider contains methods for (de)serializer registration. To
register deserializer it is needed to use .registerCustomDeserializer(key, impl).
To register serializer one must use .registerCustomSerializer(key, impl).
Registration can occur either during configuration or at runtime.

 
Impl is (de)serializer implementation and
must implement OFGeneralDeserializer / OFGeneralSerializer interface. These
interfaces are only empty unifying interfaces. Therefore it is needed to use their descendants that contain appropriate
methods.

  
=== 6.1.1    Deserializers ===
 
<u>OFGeneralDeserializer:</u>

 
- 
'''OFDeserializer&lt;E
extends DataObject&gt;'''

 
- 
''deserialize(ByteBuf)''
– deserializes given ByteBuf

 
- 
'''HeaderDeserializer&lt;E
extends DataObject&gt;'''

 
- 
''deserializeHeaders(ByteBuf)''
– deserializes only E headers (used in Multipart TableFeatures messages)

 
'''DeserializerRegistryInjector'''
– ''injectDeserializerRegistry(DeserializerRegistry)''
– injects deserializer registry into deserializer. Useful when custom
deserializer needs access to other deserializers.

 
DeserializerRegistryInjector is not OFGeneralDeserializer
descendand.

 
There are three vendor specific extensions in
Openflow v1.0. These shall be identified by MessageCodeKey with version, value
and object class from the table below:

 
<div  align="center">                          
{| border="1"
|-
| 
'''Message
type'''

 
| 
'''version'''

 
| 
'''value'''

 
| 
'''Object
class'''

 
|-
| 
vendor message

 
| 
1

 
| 
4

 
| 
ExperimenterMessage.class

 
|-
| 
vendor action

 
| 
1

 
| 
0xFFFF

 
| 
ExperimenterAction.class

 
|-
| 
stats message (OFPST_VENDOR)

 
| 
TBD

 
| 
TBD

 
| 
TBD

 
|} 
</div>  
There are nine experimenter
specific extensions in Openflow v1.3. Below you can find list of these
extensions and keys to be used for registration:

 
<div  align="center">                                                                        
{| border="1"
|-
| 
'''Experimenter'''

 
| 
'''version'''

 
| 
'''value'''

 
| 
'''value2'''

 
| 
'''Object
class'''

 
|-
| 
message

 
| 
4

 
| 
4

 
| 
-

 
| 
ExperimenterMessage.class

 
|-
| 
match entry

 
| 
4

 
| 
oxm_class

 
| 
oxm_field

 
| 
MatchEntries.class

 
|-
| 
action

 
| 
4

 
| 
0xFFFF

 
| 
-

 
| 
ExperimenterAction.class

 
|-
| 
instruction

 
| 
4

 
| 
0xFFFF

 
| 
-

 
| 
ExperimenterInstruction.class

 
|-
| 
multipart

 
| 
TBD

 
|  
|  
|  
|-
| 
Multipart -table features

 
| 
TBD

 
|  
|  
|  
|-
| 
meter band type

 
| 
TBD

 
|  
|  
|  
|-
| 
queue property

 
| 
TBD

 
|  
|  
|  
|-
| 
error

 
| 
TBD

 
|  
|  
|  
|} 
</div>  
In case when more
distinguishers are needed, use EnhancedMessageCodeKey instead of
MessageCodeKey.

  
=== 6.1.2    Serializers ===
 
= 7.   OFGeneralSerializer: =
 
- 
'''OFSerializer&lt;E
extends DataObject&gt;'''

 
- 
''serialize(E,
ByteBuf)'' – serializes E into given ByteBuf

 
- 
'''HeaderSerializer&lt;E
extends DataObject&gt;'''

 
- 
''serializeHeaders(E,
ByteBuf)'' – serializes E headers (used in Multipart
TableFeatures messages)

 
'''SerializerRegistryInjector'''
– ''injectSerializerRegistry(SerializerRegistry)''
– injects serializer registry into serializer. Useful when custom serializer
needs access to other serializers.

 
SerializerRegistryInjector
is not OFGeneralSerializer descendand.

 
There are three vendor specific extensions in
Openflow v1.0. These shall be identified by MessageTypeKey with version and
msgType class from the table below:

  
<div  align="center">                      
{| border="1"
|-
| 
'''Message
type'''

 
| 
'''version'''

 
| 
'''msgType
(DTO class)'''

 
|-
| 
vendor message

 
| 
1

 
| 
ExperimenterMessage.class

 
|-
| 
vendor action

 
| 
1

 
| 
ExperimenterAction.class

 
|-
| 
stats message (OFPST_VENDOR)

 
| 
TBD

 
| 
TBD

 
|} 
</div>  
There are nine experimenter
specific extensions in Openflow v1.3. Below you can find list of these
extensions and keys to be used for registration:

                                                              
{| border="1"
|-
| 
'''Experimenter'''

 
| 
'''version'''

 
| 
'''msgType'''

 
| 
'''msgType2'''

 
|-
| 
message

 
| 
4

 
| 
ExperimenterMessage.class

 
| 
-

 
|-
| 
match entry

 
| 
4

 
| 
$OXM_CLASS.class

 
| 
$OXM_FIELD.class

 
|-
| 
action

 
| 
4

 
| 
ExperimenterAction.class

 
| 
-

 
|-
| 
instruction

 
| 
4

 
| 
ExperimenterInstruction.class

 
| 
-

 
|-
| 
multipart

 
| 
TBD

 
|  
|  
|-
| 
Multipart -table features

 
| 
TBD

 
|  
|  
|-
| 
meter band type

 
| 
TBD

 
|  
|  
|-
| 
queue property

 
| 
TBD

 
|  
|  
|-
| 
error

 
| 
TBD

 
|  
|  
|}  
In case when more
distinguishers are needed, use EnhancedMessageTypeKey instead of MessageTypeKey.

  
== 7.1   Detailed description ==
  
=== 7.1.1    SwitchConnectionProvider ===
 
SwitchConnectionProvider constructs and
initializes both deserializer and serializer registries with default
(de)serializers. It also injects the DeserializerRegistry into the
DeserializationFactory, the SerializerRegistry into the SerializationFactory.

 
When call to register custom (de)serializer
is made, SwitchConnectionProvider calls register method on appropriate registry.

 
=== 7.1.2    DeserializerRegistry / SerializerRegistry ===
 
Both registries contain init() method to
initialize default (de)serializers.

 
Registration checks if key or (de)serializer
implementation are not null. If at least one of the is null,
NullPointerException is thrown. Else the (de)serializer implementation is
checked if it is (De)SerializerRegistryInjector instance. If it is an instance
of this interface, the registry is injected into this (de)serializer
implementation.

 
GetSerializer(key) or GetDeserializer(key)
performs registry lookup. Because there are two separate interfaces that might
be put into the registry, the registry uses their unifying super interface.
Get(De)Serializer(key) method casts the super interface to desired type. There
is also a null check for the (de)serializer received from the registry. If the
deserializer wasn’t found, NullPointerException with key description is thrown.

 
=== 7.1.3    MessageTypeKey and EnhancedMessageTypeKey ===
 
These keys are used as for serializer
lookup in SerializerRegistry. MessageTypeKey should be used in general, when it
is enough to identify corresponding serializer by only its DTO class. MessageTypeKey
has these fields:

 
- 
short version – Openflow wire
version number

 
- 
Class&lt;E&gt; msgType – DTO
class

 
EnhancedMessageTypeKey
extends MessageTypeKey and has one more field:

 
- 
msgType2 – specific class of
msgType

 
Enhanced

 
= 8.   Message specifications =
  
== 8.1   OF 1.0 and OF 1.3 message differencesfsdfgf ==
 
There
are differences between OF 1.0 and OF 1.3 messages (for example the ofp_match
structure is completely different). These differences are handled by using
additional fields in generated DTOs.

 
For
example:

 
Packet-in
message in OF 1.0 (see structure below) would have in_port field set and
table_id, cookie, match fields empty (null). The packet-in message in OF 1.3
would be the opposite.

  
[[Image:image016.png]]

 
Packet-in
message in OF 1.0

  
[[Image:image017.png]]

 
Packet-in
message in OF 1.3

  
== 8.2   OF 1.0 Vendor and Stats messages DTOs ==
 
Vendor messages are represented as
ExperimenterMessage/ExperimenterInput objects (as the messages were renamed in
the OF 1.3 version). Similarly Stats messages use
MultipartReplyMessage/MultipartRequestInput objects.

 
== 8.3   Using supertypes (higher types) ==
 
Values
used for communication with switch are represented as unsigned values. Java
uses signed values - which can store only a half of unsigned (positive) values.
To ensure that correct values are (de)serialized, the values are set into
supertypes (higher types). For example uint32 is represented as Long, uint16 as
Integer and so on.

  
== 8.4   Signed int to unsigned long conversion and vice versa ==
 
There
are cases when we need to convert signed integer into unsigned long. For
example the ofp_port_no (special port values in OF 1.3). Yang generates enums
with .getIntValue() method. Special values (like 0xffffffff) would be
represented as negative integers. For this purpose it is needed to use
BinContent class. It is located in openflow-protocol-api project, under
src/main/java/*.util package. This class does the translation into unsigned
value. BinContent also provides method for the opposite case.

  
== 8.5   Augmentation tables ==
 
Tables below show which augmentations are
used for match, instruction, action, table features and queue properties.

  
<div  align="center">                                                                                                                                                                      
{| border="1"
|-
| 
'''Match
field'''

 
| 
'''Augmentation'''

 
|-
| 
In_Port

 
| 
PortNumberMatchEntry

 
|-
| 
In_Phy_Port

 
| 
PortNumberMatchEntry

 
|-
| 
Metadata

 
| 
MetadataMatchEntry,
MaskMatchEntry

 
|-
| 
Eth_Dst

 
| 
MacAddressMatchEntry,
MaskMatchEntry

 
|-
| 
Eth_Src

 
| 
MacAddressMatchEntry,
MaskMatchEntry

 
|-
| 
Eth_Type

 
| 
EthTypeMatchEntry

 
|-
| 
Vlan_Vid

 
| 
VlanVidMatchEntry,
MaskMatchEntry

 
|-
| 
Vlan_Pcp

 
| 
VlanPcpMatchEntry

 
|-
| 
Ip_Dscp

 
| 
DscpMatchEntry

 
|-
| 
Ip_Ecn

 
| 
EcnMatchEntry

 
|-
| 
Ip_Proto

 
| 
PortNumberMatchEntry

 
|-
| 
Ipv4_Src

 
| 
Ipv4AddressMatchEntry,
MaskMatchEntry

 
|-
| 
Ipv4_Dst

 
| 
Ipv4AddressMatchEntry,
MaskMatchEntry

 
|-
| 
Tcp_Src

 
| 
PortMatchEntry

 
|-
| 
Tcp_Dst

 
| 
PortMatchEntry

 
|-
| 
Udp_Src

 
| 
PortMatchEntry

 
|-
| 
Udp_Dst

 
| 
PortMatchEntry

 
|-
| 
Sctp_Src

 
| 
PortMatchEntry

 
|-
| 
Sctp_Dst

 
| 
PortMatchEntry

 
|-
| 
Icmpv4_Type

 
| 
Icmpv4TypeMatchEntry

 
|-
| 
Icmpv4_Code

 
| 
Icmpv4CodeMatchEntry

 
|-
| 
Arp_Op

 
| 
OpCodeMatchEntry

 
|-
| 
Arp_Spa

 
| 
Ipv4AddressMatchEntry,
MaskMatchEntry

 
|-
| 
Arp_Tpa

 
| 
Ipv4AddressMatchEntry,
MaskMatchEntry

 
|-
| 
Arp_Sha

 
| 
MacAddressMatchEntry,
MaskMatchEntry

 
|-
| 
Arp_Tha

 
| 
MacAddressMatchEntry,
MaskMatchEntry

 
|-
| 
Ipv6_Src

 
| 
Ipv6AddressMatchEntry,
MaskMatchEntry

 
|-
| 
Ipv6_Dst

 
| 
Ipv6AddressMatchEntry,
MaskMatchEntry

 
|-
| 
Ipv6_Flabel

 
| 
Ipv6FlabelMatchEntry,
MaskMatchEntry

 
|-
| 
Icmpv6_Type

 
| 
Icmpv6TypeMatchEntry

 
|-
| 
Icmpv6_Code

 
| 
Icmpv6CodeMatchEntry

 
|-
| 
Ipv6_Nd_Target

 
| 
Ipv6AddressMatchEntry

 
|-
| 
Ipv6_Nd_Sll

 
| 
MacAddressMatchEntry

 
|-
| 
Ipv6_Nd_Tll

 
| 
MacAddressMatchEntry

 
|-
| 
Mpls_Label

 
| 
MplsLabelMatchEntry

 
|-
| 
Mpls_Tc

 
| 
TcMatchEntry

 
|-
| 
Mpls_Bos

 
| 
BosMatchEntry

 
|-
| 
Pbb_Isid

 
| 
IsidMatchEntry,
MaskMatchEntry

 
|-
| 
Tunnel_Id

 
| 
MetadataMatchEntry,
MaskMatchEntry

 
|-
| 
Ipv6_Exthdr

 
| 
PseudoFieldMatchEntry,
MaskMatchEntry

 
|} 
</div> 
MatchEntries
(oxm_fields) augmentations table (OF 1.3)

 
*MaskMatchEntry
is present only if the mask is provided and hasMask flag is true

  
<div  align="center">                              
{| border="1"
|-
| 
'''Instruction
type'''

 
| 
'''Augmentation'''

 
|-
| 
Goto_Table

 
| 
TableIdInstruction

 
|-
| 
Write_Metadata

 
| 
MetadataInstruction

 
|-
| 
Write_Actions

 
| 
ActionsInstruction

 
|-
| 
Apply_Actions

 
| 
ActionsInstruction

 
|-
| 
Clear_Actions

 
| 
ActionsInstruction

 
|-
| 
Meter

 
| 
MeterIdInstruction

 
|} 
</div> 
Instructions
augmentations table (OF 1.3)

  
<div  align="center">                                                      
{| border="1"
|-
| 
'''Action
type'''

 
| 
'''Augmentation'''

 
|-
| 
Output

 
| 
PortAction,
MaxLengthAction

 
|-
| 
Set_Vlan_Vid

 
| 
VlanVidAction

 
|-
| 
Set_Vlan_Pcp

 
| 
VlanPcpAction

 
|-
| 
Strip_Vlan

 
| 
-

 
|-
| 
Set_Dl_Src

 
| 
DlAddressAction

 
|-
| 
Set_Dl_Dst

 
| 
DlAddressAction

 
|-
| 
Set_Nw_Src

 
| 
IpAddressAction

 
|-
| 
Set_Nw_Dst

 
| 
IpAddressAction

 
|-
| 
Set_Nw_Tos

 
| 
NwTosAction

 
|-
| 
Set_Tp_Src

 
| 
PortAction

 
|-
| 
Set_Tp_Dst

 
| 
PortAction

 
|-
| 
Enqueue

 
| 
PortAction,
QueueIdAction

 
|} 
</div> 
Actions
augmentations table (OF 1.0)

    
<div  align="center">                                                                      
{| border="1"
|-
| 
'''Action
type'''

 
| 
'''Augmentation'''

 
|-
| 
Output

 
| 
PortAction,
MaxLengthAction

 
|-
| 
Copy_Ttl_Out

 
| 
-

 
|-
| 
Copy_Ttl_In

 
| 
-

 
|-
| 
Set_Mpls_Ttl

 
| 
MplsTtlAction

 
|-
| 
Dec_Mpls_Ttl

 
| 
-

 
|-
| 
Push_Vlan

 
| 
EthertypeAction

 
|-
| 
Pop_Vlan

 
| 
-

 
|-
| 
Push_Mpls

 
| 
EthertypeAction

 
|-
| 
Pop_Mpls

 
| 
EthertypeAction

 
|-
| 
Set_Queue

 
| 
QueueIdAction

 
|-
| 
Group

 
| 
GroupIdAction

 
|-
| 
Set_Nw_Ttl

 
| 
NwTtlAction

 
|-
| 
Dec_Nw_Ttl

 
| 
-

 
|-
| 
Set_Field

 
| 
OxmFieldsAction

 
|-
| 
Push_Pbb

 
| 
EthertypeAction

 
|-
| 
Pop_Pbb

 
| 
-

 
|} 
</div> 
Actions
augmentations table (OF 1.3)

  
<div  align="center">                                                              
{| border="1"
|-
| 
'''TableFeatureProperty
type'''

 
| 
'''Augmentation'''

 
|-
| 
Instructions

 
| 
InstructionRelatedTableFeatureProperty

 
|-
| 
Instructions_Miss

 
| 
InstructionRelatedTableFeatureProperty

 
|-
| 
Next_Tables

 
| 
NextTableRelatedTableFeatureProperty

 
|-
| 
Next_Tables_Miss

 
| 
NextTableRelatedTableFeatureProperty

 
|-
| 
Write_Actions

 
| 
ActionRelatedTableFeatureProperty

 
|-
| 
Write_Actions_Miss

 
| 
ActionRelatedTableFeatureProperty

 
|-
| 
Apply_Actions

 
| 
ActionRelatedTableFeatureProperty

 
|-
| 
Apply_Actions_Miss

 
| 
ActionRelatedTableFeatureProperty

 
|-
| 
Match

 
| 
OxmRelatedTableFeatureProperty

 
|-
| 
Wildcards

 
| 
OxmRelatedTableFeatureProperty

 
|-
| 
Write_Setfield

 
| 
OxmRelatedTableFeatureProperty

 
|-
| 
Write_Setfield_Miss

 
| 
OxmRelatedTableFeatureProperty

 
|-
| 
Apply_Setfield

 
| 
OxmRelatedTableFeatureProperty

 
|-
| 
Apply_Setfield_Miss

 
| 
OxmRelatedTableFeatureProperty

 
|} 
</div> 
TableFeatureProperties
augmentation table (OF 1.3)

  
<div  align="center">              
{| border="1"
|-
| 
'''QueueProperty
type'''

 
| 
'''Augmentation'''

 
|-
| 
Min_Rate

 
| 
RateQueueProperty

 
|-
| 
Max_Rate

 
| 
RateQueueProperty

 
|} 
</div> 
QueueProperties
augmentation table (OF 1.3)

  
== 8.6   Table-miss flow entry ==
 
To
set up a table-miss flow entry in switch table it is needed to create FlowMod
message with desired flow properties and an empty match. Match is considered
empty when it has only type specified (no oxm_fields are present).

    
= 9.   Glossary =
  
DTO – Data Transfer Object

 
XID – transaction ID in OpenFlow message
(header)

 
ResponseCache – expiring cache for future rpc
responses. Default rpc response expiration time is set to one minute. Entry
that has been in cache longer than one minute will be automatically removed.
Cache uses removal listener, which checks the reason of removal. If the reason
was expiration time, entry is cancelled.

 
RpcResponseKey – this class is used as a key
in responseCache. It contains XID and received DTO’s class fields, which are
used for lookup in responseCache.

   
= 10.                 Useful links =
  
https://wiki.opendaylight.org/view/Openflow_Protocol_Library:Main

 
</div>
