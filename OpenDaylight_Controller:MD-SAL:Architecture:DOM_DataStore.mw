
== Problem statement ==
Original MD-SAL DataStore used data structures defined in yang-data-api, which more resembles XML structures \
then well-defined data structures defined by YANG and used in the MD-SAL, Java DTOs generated by YangTools \
and so on, and it is hard to implement optimized datastore on top of them.

Also data contracts of MD-SAL does not provide enough capabilities to more closely specify intent of the \
applications and could not perform optimizations (e.g. not deserializing unnecessary data,  \
computing only necessary change sets) to clients.

Current implementation of datastore also does not allow for atomic updates on subtrees, which needs to be \
addressed to improve reliability and performance of MD-SAL.


=== Requirements ===

* Transactions
** Consistent view during data transaction - one which returns view with all already proposed modification applied.  

=== Necessary actions ===

* ''yang-data-api'' needs to be extended to provide tree structures which more closely match data structures defined by YANG Schema.
** Data structures need to be closely alligned to Instance Identifier and should provide support for atomic operations.
* ''sal-common-api, sal-core-api'' and ''sal-binding-api'' needs to be extended to better specify user intent.
* separate operational data store and configuration data store

== Normalized Data Tree Model ==

New normalized model for data is not based on serialization format (as defined in YANG specification and used by ''sal-broker-impl 1.0'')
but rather to represent actual concepts behind YANG Specification

* '''NormalizedNode''' - Base type representing node in tree structure, all nodes are derived from it, it contains a leaf identifier and value.
** '''DataContainerNode''' - Node which contains a multiple leafs. Does not have direct representation in YANG syntax.
*** '''ContainerNode''' - Node, which represents a leaf which could occur only once per parent node. Contains multiple child leaves. Maps to ''container'' statement in YANG.
*** '''MapEntryNode''' - Node which represents a leaf, which could occur multiple times, leaves are uniquely identified by their key. Contains multiple child leaves. Maps to the instance of ''list'' in YANG.
*** '''ChoiceNode''' - Node which represents a leaf, which occurs mostly once per parent node, but possible values could have different types. Maps to ''choice'' statement. Types maps to the ''case'' statements for that ''choice''.
*** '''AugmentationNode''' - Node which represents a leaf, which occurs mostly once per parent node.
** '''LeafNode''' - Node which represents a leaf, which occurs mostly once per parent node. Contains simple value.
** '''LeafSetEntryNode''' - Node which represents a leaf, which typeÂ could occurs multiple times per parent node. Maps to to the instances of ''leaf-list'' in YANG.
** '''LeafSetNode''' - Special node, which could occurs only once per parent node, and it's leaves are LeafSetEntryNode of specified type. Maps to the ''leaf-list'' in YANG. 
** '''MapNode''' - Special node, which could occurs only once per parent node, and it's leaves are MapEntryNode nodes.

Original model also did not provide tie-in between InstanceIdentifier and Data Store which is fixed in this proposal by defining relationship between path arguments in InstanceIdentifier
and data tree nodes.
 
The grammar for data objects structure is:

  InstanceIdentifier = PathArgument*
  PathArgument = NodeIdentifier|NodeIdentifierWithPredicates|NodeIdentifierWithValue|AugmentationIdentifier
  
  TreeRoot = DataContainerNode
  DataContainerNode = (LeafNode|ChoiceNode|AugmentationNode|MapNode|LeafSetNode)*
  ContainerDataNode = NodeIdentifier DataContainerNode
 
  LeafNode = NodeIdentifier SimpleValue
  AugmentationNode = AugmentationIdentifier DataContainerNode
  MapNode = MapEntryNode*
  MapEntryNode = NodeIdentifierWithPredicates DataContainerNode
  
  /* Special nodes */
  LeafSetNode = LeafSetEntryNode*
  ChoiceNode = NodeIdentifier DataContainerNode
  LeafSetEntryNode = NodeIdentifierWithValue SimpleValue


The resulting organization of tree is:

* (DataContainerNode)
** (0..n) LeafNode
** (0..n) LeafSetNode
*** (0..n) LeafSetEntryNode
** (0..n) ContainerNode
*** (Same as DataContainerNode)
** (0..n) ContainerNode
*** (Same as DataContainerNode)
** (0..n) MapNode
*** (0..n) MapEntryNode
**** (Same as DataContainerNode)
** (0..n) AugmentationNode
*** (Same as DataContainerNode)


The proposal of APIs is in: http://git.opendaylight.org/gerrit/5441

== In-memory MD-SAL data store ==

In-memory data store will be implemented using Normalized Data Tree Model, and will represents it structures (except additional metadata storage) as immutable tree
which de-facto is consistent snapshot of actual state. 

There are two in-memory data stores, when one represents configuration tree, the other one operational.

Nodes in Normalized Data Tree Model are extended to contain following information:

* node version - captures the version of the node
* modification timestamp - timestamp for last revision
* list of affected data change listeners - set data change listeners, which registered themselves to notify for the changes of that node and subtree rooted at that node.

=== Atomic operations === 

* Insertion of leaf (subtree)
* Removal of leaf (subtree)
* Replace of leaf (subtree)
* Set of additions, removals, replacements of leaves of same node

Atomic operations could not be invoked outside transaction.

=== Data Modification Transactions ===


Data Store is participant in two-phase commit (as commit handler).

==== Request commit phase ====

Changes are processed by applying requested changes starting from deepest nodes in the data tree structure and propagating changes to the parent node.

# Reference to initial state is captured
# Data store creates new subtree by applying specified operations affecting that node
# Data store captures set of affected data change listeners with initial state (reference to old-subtree) and new state (reference to new subtree)
# Data store propagates new subtree to the parent node and applies atomic operations on parent node (1.) until root node of data store is replaced.

==== Finish phase ====

# Data store replaces reference to root element to newly created root element.
# Data store finishes transaction.
# All captured affected listeners are notified with initial state and new state.

==== Rollback ====

Noop, since the reference to consistent (and public snapshot) is changed only in finish phase. Data Store is only required to not reference newly created tree.
