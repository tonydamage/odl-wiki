
== Problem Statement ==
The original MD-SAL DataStore used data structures defined in the 'yang-data-ap'i, which bear more resemblance to XML structures than to well-defined data structures defined by YANG, which are used in the MD-SAL, Java DTOs generated by YangTools and so on. It is hard to implement an optimized datastore on top of them.

Also, the MD-SAL data contracts do not provide enough capabilities to specify more accurately the applications' intent and to perform optimizations to clients, such as not to deserialize unnecessary data or to compute only necessary change sets.

The current datastore implementation also does not allow for atomic updates on subtrees, which needs to be addressed to improve reliability and performance of MD-SAL.

=== Requirements ===
* Transactions
** Consistent view during data transaction - one which returns view with all already proposed modification applied.  

=== Necessary Actions ===
* ''yang-data-api'' needs to be extended to provide tree structures which more closely match data structures defined by YANG Schemas.
** Data structures need to be closely aligned to Instance Identifier and should provide support for atomic operations.
* ''sal-common-api, sal-core-api'' and ''sal-binding-api'' need to be extended to better specify user intent.
* Separate operational data store and configuration data store


== Normalized Data Tree Model ==

The new normalized model for data will not be based on the serialization format (as defined in the YANG specification and used by ''sal-broker-impl 1.0''), but will rather represent the actual concepts behind the YANG Specification.

* '''NormalizedNode''' - Base type representing a node in a tree structure; all nodes are derived from it, it contains a leaf identifier and a value.
** '''DataContainerNode''' - Node which contains multiple leafs; it does not have a direct representation in the YANG syntax.
*** '''ContainerNode''' - Node, which represents a leaf which can occur only once per parent node; it contains multiple child leaves and maps to the ''container'' statement in YANG.
*** '''MapEntryNode''' - Node which represents a leaf, which can occur multiple times; a leave is uniquely identified by the value of its key. A MapEntryNode may contain multiple child leaves. MapEntryNode maps to the instance of ''list'' in YANG.
*** '''ChoiceNode''' - Node which represents a leaf, which occurs mostly once per parent node, but possible values could have different types. Maps to ''choice'' statement. Types maps to the ''case'' statements for that ''choice''.
*** '''AugmentationNode''' - Node which represents a leaf, which occurs mostly once per parent node.
** '''LeafNode''' - Node which represents a leaf, which occurs mostly once per parent node. Contains simple value.
** '''LeafSetEntryNode''' - Node which represents a leaf, which typeÂ could occurs multiple times per parent node. Maps to to the instances of ''leaf-list'' in YANG.
** '''LeafSetNode''' - Special node, which can occur only once per parent node; its leaves are LeafSetEntryNode nodes of specified type. Maps into the ''leaf-list'' in YANG. 
** '''MapNode''' - Special node, which can occur only once per parent node; its leaves are MapEntryNode nodes.

The original model also did not provide a tie-in between the InstanceIdentifier and the Data Store. This omission has been fixed in this proposal by defining a relationship between path arguments in InstanceIdentifier
and data tree nodes.
 
The grammar for the data objects structure is as follows:

  InstanceIdentifier = PathArgument*
  PathArgument = NodeIdentifier|NodeIdentifierWithPredicates|NodeIdentifierWithValue|AugmentationIdentifier
  
  TreeRoot = DataContainerNode
  DataContainerNode = (LeafNode|ChoiceNode|AugmentationNode|MapNode|LeafSetNode)*
  ContainerDataNode = NodeIdentifier DataContainerNode
 
  LeafNode = NodeIdentifier SimpleValue
  AugmentationNode = AugmentationIdentifier DataContainerNode
  MapNode = MapEntryNode*
  MapEntryNode = NodeIdentifierWithPredicates DataContainerNode
  
  /* Special nodes */
  LeafSetNode = LeafSetEntryNode*
  ChoiceNode = NodeIdentifier DataContainerNode
  LeafSetEntryNode = NodeIdentifierWithValue SimpleValue


The resulting organization of the data tree is:

* (DataContainerNode)
** (0..n) LeafNode
** (0..n) LeafSetNode
*** (0..n) LeafSetEntryNode
** (0..n) ContainerNode
*** (Same as DataContainerNode)
** (0..n) ContainerNode
*** (Same as DataContainerNode)
** (0..n) MapNode
*** (0..n) MapEntryNode
**** (Same as DataContainerNode)
** (0..n) AugmentationNode
*** (Same as DataContainerNode)


Code for the proposed APIs is in: http://git.opendaylight.org/gerrit/5441

== The In-Memory MD-SAL Data Store ==

In-memory data store will be implemented using Normalized Data Tree Model, and will represents it structures (except additional metadata storage) as immutable tree
which de-facto is consistent snapshot of actual state. 

There are two in-memory data stores, when one represents configuration tree, the other one operational.

Nodes in Normalized Data Tree Model are extended to contain following information:

* node version - captures the version of the node
* modification timestamp - timestamp for last revision
* list of affected data change listeners - set data change listeners, which registered themselves to notify for the changes of that node and subtree rooted at that node.

=== Atomic operations === 

* Insertion of leaf (subtree)
* Removal of leaf (subtree)
* Replace of leaf (subtree)
* Set of additions, removals, replacements of leaves of same node

Atomic operations could not be invoked outside transaction.

=== Data Modification Transactions ===


Data Store is participant in two-phase commit (as commit handler).

==== Request commit phase ====

Changes are processed by applying requested changes starting from deepest nodes in the data tree structure and propagating changes to the parent node.

# Reference to initial state is captured
# Data store creates new subtree by applying specified operations affecting that node
# Data store captures set of affected data change listeners with initial state (reference to old-subtree) and new state (reference to new subtree)
# Data store propagates new subtree to the parent node and applies atomic operations on parent node (1.) until root node of data store is replaced.

==== Finish phase ====

# Data store replaces reference to root element to newly created root element.
# Data store finishes transaction.
# All captured affected listeners are notified with initial state and new state.

==== Rollback ====

Noop, since the reference to consistent (and public snapshot) is changed only in finish phase. Data Store is only required to not reference newly created tree.
