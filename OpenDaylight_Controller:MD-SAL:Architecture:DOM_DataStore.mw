
== Problem Statement ==
The original MD-SAL DataStore used data structures defined in the ''yang-data-api'', which bear more resemblance to XML structures than to well-defined data structures defined by YANG, which are used in the MD-SAL, Java DTOs generated by YangTools and so on. It is hard to implement an optimized datastore on top of them.

Also, the MD-SAL data contracts do not provide enough capabilities to specify more accurately the applications' intent and to perform optimizations to clients, such as not to deserialize unnecessary data or to compute only necessary change sets.

The current datastore implementation also does not allow for atomic updates on subtrees, which needs to be addressed to improve reliability and performance of MD-SAL.

=== Requirements ===
* Transactions
** Consistent view during data transaction - one which returns view with all already proposed modification applied.  

=== Necessary Actions ===
* ''yang-data-api'' needs to be extended to provide tree structures which more closely match data structures defined by YANG Schemas.
** Data structures need to be closely aligned to Instance Identifier and should provide support for atomic operations.
* ''sal-common-api, sal-core-api'' and ''sal-binding-api'' need to be extended to better specify user intent.
* Separate operational data store and configuration data store

== Normalized Data Tree Model ==

The new normalized model for data will not be based on the serialization format (as defined in the YANG specification and used by ''sal-broker-impl 1.0''), but will rather represent the actual concepts behind the YANG Specification.

* '''NormalizedNode''' - Base type representing a node in a tree structure; all nodes are derived from it, it contains a leaf identifier and a value.
** '''DataContainerNode''' - Node which contains multiple leafs; it does not have a direct representation in the YANG syntax.
*** '''ContainerNode''' - Node, which represents a leaf which can occur only once per parent node; it contains multiple child leaves and maps to the ''container'' statement in YANG.
*** '''MapEntryNode''' - Node which represents a leaf, which can occur multiple times; a leave is uniquely identified by the value of its key. A MapEntryNode may contain multiple child leaves. MapEntryNode maps to the instance of ''list'' in YANG.
*** '''ChoiceNode''' - Node which represents a leaf, which occurs mostly once per parent node, but possible values could have different types. Maps to ''choice'' statement. Types maps to the ''case'' statements for that ''choice''.
*** '''AugmentationNode''' - Node which represents a leaf, which occurs mostly once per parent node.
** '''LeafNode''' - Node which represents a leaf, which occurs mostly once per parent node. Contains simple value.
** '''LeafSetEntryNode''' - Node which represents a leaf, which typeÂ could occurs multiple times per parent node. Maps to to the instances of ''leaf-list'' in YANG.
** '''LeafSetNode''' - Special node, which can occur only once per parent node; its leaves are LeafSetEntryNode nodes of specified type. Maps into the ''leaf-list'' in YANG. 
** '''MapNode''' - Special node, which can occur only once per parent node; its leaves are MapEntryNode nodes.

The original model also did not provide a tie-in between the InstanceIdentifier and the Data Store. This omission has been fixed in this proposal by defining a relationship between path arguments in InstanceIdentifier
and data tree nodes.
 
The grammar for the data objects structure is as follows:

  InstanceIdentifier = PathArgument*
  PathArgument = NodeIdentifier|NodeIdentifierWithPredicates|NodeIdentifierWithValue|AugmentationIdentifier
  
  TreeRoot = DataContainerNode
  DataContainerNode = (LeafNode|ChoiceNode|AugmentationNode|MapNode|LeafSetNode)*
  ContainerDataNode = NodeIdentifier DataContainerNode
 
  LeafNode = NodeIdentifier SimpleValue
  AugmentationNode = AugmentationIdentifier DataContainerNode
  MapNode = MapEntryNode*
  MapEntryNode = NodeIdentifierWithPredicates DataContainerNode
  
  /* Special nodes */
  LeafSetNode = LeafSetEntryNode*
  ChoiceNode = NodeIdentifier DataContainerNode
  LeafSetEntryNode = NodeIdentifierWithValue SimpleValue


The resulting organization of the data tree is:

* (DataContainerNode)
** (0..n) LeafNode
** (0..n) LeafSetNode
*** (0..n) LeafSetEntryNode
** (0..n) ContainerNode
*** (Same as DataContainerNode)
** (0..n) ContainerNode
*** (Same as DataContainerNode)
** (0..n) MapNode
*** (0..n) MapEntryNode
**** (Same as DataContainerNode)
** (0..n) AugmentationNode
*** (Same as DataContainerNode)


Code for the proposed APIs is in: http://git.opendaylight.org/gerrit/5441

=== Affected components ===

Currently in the code base there are currently 3 existing components which performs schema aware data normalization and two components
which will benefit from normalization


* Yangtools
** '''yang-data-impl - XmlDocumentUtils''' - set of utilities and codecs which is used by Netconf tooling to normalize input XML into yang-data-api based on provided Schema
** '''binding-generator-impl - LazyGeneratedCodecRegistry''' - runtime generated codec from Java DTOs to yang-data-api
* Controller
** '''sal-rest-connector RestconfContext''' - translates input json/xml into intermediate form, which is normalized using schema context
** '''sal-*''' DataBroker - unification of concepts between Java DTOs and yang-data-api, well defined normalized form will improve code reusability, readability and performance of Data Broker
** '''DataStore''' - data store implementation will benefit from unified data normalized model, which could lead to more effective implementations

== MD-SAL Data Broker contract ==

Data Brokers were designed without assumption of intelligent in-memory cache with tree like structures capable of tracking 
dependencies, calculating change sets and maintaining relationship between commit handlers, notification listeners and actual
data, which lead to less effective implementation of two-phase commit, where all state tracking is done by data broker during two-phase commit
as followed:

# Calculate affected subtrees
# Filter commit handlers by affected subtrees
# Filter data change listeners by affected subtrees
# Capture initial state for data change listeners (one read per data change listener set)
# Start Request Commit of all affected commit handlers
# Finish Commit on all affected commit handlers
# Capture final state for data change listeners (one read per data change listener set)
# Publish Data Change events to affected data change listeners.

The state which is kept and maintained by Data Brokers is:

* Mapping of subtree paths to registered commit handlers
* Mapping of subtree paths to registered data change listeners
* Mapping of subtree paths to registered data readers 

Additional to this state keeping responsibilities of Data Brokers are:

* Read request routing for data readers
* Two phase commit coordination
* Publishing Data Change Events
** Capturing Before and After state 


=== Asynchronous read ===

Most of the MD-SAL APIs we're defined to be asynchronous - one omission was ''read*Data'' operation, which 
confused people to be immediate, fast. With introduction of  additional use cases such as
lazy codec generation, remote systems providing read operations (Netconf), support for multiple readers, clustering, this proved
not to be true.

The proposed change is to make also DataReader contract asynchronous, which allows chaining of reads, not blocking caller thread
durring the read, which will result in more cleaner concurrency models.

Proposed change: https://git.opendaylight.org/gerrit/#/c/5143/2 


=== In-memory Datastore / cache ===

Data Broker contract and deployment model will assume presence of  in-memory datastore (cache) which could offload 
Data Brokers from following responsibilities:

* Mapping of subtreee paths to registered data change listeners
* Publishing Data Change Events
** Capturing Before and After state

=== Data Modification Transaction ===

Semantic of Data Modification did not explicitly specified memory and consistency model of transaction during transaction
lifecycle.

Transaction tracks original state of data tree and set of proposed changes (atomic operations) on data tree, which should
be applied when transaction succeeds. 

Transaction is:
* Self-consistent snapshot of overall data tree (reference to data tree snapshots from creation time)
* Set of atomic operations which should be apply to the tree.

==== Transaction sub-operations ====

* read - reads a subtree with all proposed changes (in scope of this transaction and original snapshot) applied.
* Data Changes - modifies a data tree
** put - insert or replace, actual operation depends on original state. Submits an Insert or Replace change to the transaction backlog.
** remove - removes subtree from data tree. Submits an Remove change to the transaction backlog.

The changes and order in which they are applied is sorted by:

# Remove operations in order of decreasing depth
# Insert / Replace operations in order of decreasing depth
Effectively this means that removals always take precedence before insertions and replaces, so it is not possible to remove data in same
transaction in which they we're inserted.

This in effect means that all subsequent reads on transaction will result in consistent view of data, which we're present at the time 
of transaction start, with all changes proposed by the consumers (in this transaction) applied.

==== Change Tracking ====

Transaction tracks changes in tree structure separate to the original state snapshot (which is immutable), structurally organized same
way as snapshot data tree, but limited only to nodes affected by changes and their parent nodes. 
There are two distinct node types:
* '''Explicitly changed node''' - Explicitly changed node is a node with associated data changes submitted by the consumers of transaction. During transaction lifecycle explicitly changed node
''never changes'' it's type  to ''implicitly changed node''.
This node tracks:
** original version of node as of time of transaction creation.
** change set which should be applied to this node (e.g. replacement of child, insertion of child) and other explicitly changed nodes.
* '''Implicitly changed node''' - this node tracks nodes which are not directly changed, but indirectly because of child change. 
Implicitly changed node could be change it's state to ''explicitly changed''  if a change is proposed to that node.
Implicitly changed node may carry original version of that node from snapshot for ease of debugging.

==== Chained Transactions ====

MD-SAL APIs needs to be extended to allow support for explicit transaction chaining using core Data Broker APIs and implicit chaining
using utility adapters.

Transaction chaining allows to create prerequisite chains between transactions - one transaction is based on the successful results of the other 
one.

There are two types of chained transaction:

* '''Join Transaction''' - transaction does not contains any data changes, but could have multiple parent transactions as prerequisites. This transaction
represents a data tree state, where are prerequisites (ancestors) are successfully applied.
* '''Data Modification Transaction''' - transaction could have parent transaction which is prerequisite and represents a initial state for this transaction. Transaction may 
contains proposed Data Changes.

=== Data Change Listeners ===

Data Change Listener registration proved to very generic, which does not allow consumers to
more concretely specify criteria on which they are notified, and thus could not allow
for some optimizations.

Data Change Publisher contract needs to be extended to allow following new types of subscription:

* '''Operational Data change only''' - Listener is notified if and only if subtree changed in operational data store.
* '''Configuration Data change only''' - Listener is notified if and only if subtree changed in operational data store.
* '''Operational and Configuration data store changed''' - (current behaviour)

Data Change Publisher contract needs also to allow define scope of triggering event

* '''Base''' - listener is notified if node changed
* '''One''' - listener is notified if direct child of node changed
* '''Subtree''' - listener is notified if node or it's subtree changed (current behaviour)

== The In-Memory MD-SAL Data Store ==

The in-memory data store will be implemented using the Normalized Data Tree Model. It represent its structures (except for additional metadata storage) as an immutable tree, which de-facto is a consistent snapshot of the actual state. 

There are two in-memory data stores: one that represents the configuration tree, and one that represents the operational tree.

Nodes in the Normalized Data Tree Model are extended to contain following information:

* node version - captures the version of the node
* modification timestamp - timestamp for last revision
* list of affected data change listeners - set data change listeners, which registered themselves to notify for the changes of that node and subtree rooted at that node.

=== Atomic Operations === 

* Insertion of leaf (subtree)
* Removal of leaf (subtree)
* Replace of leaf (subtree)
* Set of additions, removals, replacements of leaves of same node

Atomic operations could not be invoked outside transaction.

=== Data Modification Transactions ===

Data Store is a participant in the two-phase commit (as commit handler).

==== Request Commit Phase ====

Changes are processed by applying requested changes starting from deepest nodes in the data tree structure and propagating changes to the parent node.

# Reference to initial state is captured
# Data store creates a new subtree by applying specified operations that affect that node
# Data store captures the set of affected data change listeners with the initial state (reference to the old-subtree) and the new state (reference to the new subtree)
# Data store propagates the new subtree to the parent node and applies atomic operations on the parent node (1.) until the root node of the data store is replaced.

==== Finish Phase ====

# Data store replaces the reference to the root element to newly created root element.
# Data store finishes the transaction.
# All captured affected listeners are notified with both the initial state and the new state.

==== Rollback ====

Noop, since the reference to consistent (and public snapshot) is changed only in finish phase. Data Store is only required to not reference newly created tree.
