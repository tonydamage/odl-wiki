
<big>This page is under construction pending yet to be committed code changes :
https://git.opendaylight.org/gerrit/#/c/7904/
https://git.opendaylight.org/gerrit/#/c/8195/
</big>

=== Overview ===

A secure controller network will require that both the switches & controllers authenticate to avoid a rogue switch on the controller or a rogue controller driving a switch.

Achieving secure connections between ODL controller and Openflow switches requires management of a PKI ( Private Key Infrastructure ).  Openssl provides the tools for this.  If you are planning a production deployment and don't have expertise in TLS PKI, here is a great tutorial which takes you from basic to advanced PKI management: [https://media.readthedocs.org/pdf/pki-tutorial/latest/pki-tutorial.pdf pki-tutorial.pdf]

To get started hacking today with mininet, here we setup a basic PKI and create the necessary certificates to test the controller's openflow plugin with ovs mininet.  Note that I based this on the following link: [https://github.com/mininet/mininet/wiki/SSL-on-Open-vSwitch-and-ovs-controller SSL-on-Open-vSwitch-and-ovs-controller].

=== Create & Sign private/public key certificates ===

A self-signed "root" CA is created easily with existing mininet tools which leverage openssl, and so will be the starting point for this process.  To be secure, the private keys must be protected, while the public key can be freely shared.  Because we're using the mininet host also as the CA signing host, the controllers private key exists there, but in production, the key generation for the controller would be isolated from the switches, and only the public controller key would be shared with the switches.

On the mininet host, verify that it's PKI is initialized:
<pre>
ls /var/lib/openvswitch/pki/controllerca/cacert.pem
</pre>

If not found, "ovs-pki init" will need to be run as per man pages.

Now run the ovs-pki to create both sets of keys, a controller set and switch set.
<pre>
cd /etc/openvswitch
sudo ovs-pki req+sign sc switch
sudo ovs-pki req+sign ctl controller
</pre>

This should have generated six ".pem" files, of which we'll use four.  A private key for each side, signed by the unofficial root certificate in /var/lib/openvswitch/pki/.  A public certificate for each side.  There are also the two request certificates sc-req.pem & ctl-req.pem which were used to generate the signed certificates.

<pre>
$ ls /etc/openvswitch
conf.db ctl-cert.pem ctl-privkey.pem ctl-req.pem sc-cert.pem sc-privkey.pem sc-req.pem
system-id.conf
</pre>

=== PKCS12 controller keystore ===

Next we'll use openssl to create a keystore in PKCS12 format containing the controller's private and public keys.   We'll then import into a JKS format keystore for the ODL controller.  Note that it may be possible to use the PKCS12 keystore directly, but I haven't yet tested this.

<pre>
sudo openssl pkcs12 -export -in ctl-cert.pem -inkey ctl-privkey.pem \
-out ctl.p12 -name odlserver \
-CAfile /var/lib/openvswitch/pki/controllerca/cacert.pem -caname root -chain

You'll be prompted for a password, use "opendaylight"

Enter Export Password:
Verifying - Enter Export Password:
</pre>

=== Create Controller keystore ( ctl.jks ) from ctl.p12 ===

Copy two files, ctl.p12 & sc-cert.pem from the mininet host to the ODL host in any work directory.
Import the PKCS12 format store into the JKS store consumable by ODL:

<pre>
sftp mininet@mininetipaddress
mininet
sftp get ctl.p12 sc-cert.pem
quit
</pre>

Find keytool in a jdk bin directory and add it to your path for convenience in the future steps.  Mine happens to be at /usr/java/jdk1.7.0_51/bin/keytool.

<pre>
keytool -importkeystore \
        -deststorepass opendaylight -destkeypass opendaylight -destkeystore ctl.jks \
        -srckeystore ctl.p12 -srcstoretype PKCS12 -srcstorepass opendaylight \
        -alias odlserver
</pre>

=== Store the switch's public key in a "truststore" ( truststore.jks) ===

<pre>
keytool -importcert -file sc-cert.pem -keystore truststore.jks -storepass opendaylight

# when prompted "Trust this certificate? [no]:" enter  "yes"
# Certificate was added to keystore
</pre>

Finally copy these two keystores to the ssl configuration directory.

<pre>
mkdir ODLINSTALL/configuration/ssl
cp ctl.jks truststore.jks ODLINSTALL/configuration/ssl
</pre>

=== Configure ODL's openflow plugin ===
<pre>
cd configuration/initial
vi configuration/initial/42-openflow-protocol-impl.xml

          <tls>
            <supported>true</supported>
            <keystore>/ctl.jks</keystore>
            <keystore-type>JKS</keystore-type>
            <truststore>/truststore.jks</truststore>
            <truststore-type>JKS</truststore-type>
          </tls>
</pre>

=== Configure openvswitch SSL ===
<pre>
sudo ovs-vsctl set-ssl \
    /etc/openvswitch/sc-privkey.pem \
    /etc/openvswitch/sc-cert.pem \
    /var/lib/openvswitch/pki/controllerca/cacert.pem
</pre>

=== Start a mininet with SSL connections to the ODL controller ===

open a file "<tt>ssl_switch_tests.py</tt>"

<pre>
#!/usr/bin/python
from mininet.net import Mininet
from mininet.node import Controller, RemoteController
from mininet.cli import CLI
from mininet.log import setLogLevel, info

def emptyNet():
    net = Mininet( controller=RemoteController )
    net.addController( 'c0' )
    h1 = net.addHost( 'h1' )
    h2 = net.addHost( 'h2' )
    s1 = net.addSwitch( 's1' )
    net.addLink( h1, s1 )
    net.addLink( h2, s1 )

    net.start()
    s1.cmd('ovs-vsctl set-controller s1 ssl:YOURODLCONTROLLERIPADDRESS:6633')

    CLI( net )
    net.stop()

if __name__ == '__main__':
    setLogLevel( 'info' )
    emptyNet()
</pre>

Start mininet :
<pre>
chmod +x ssl_switch_test.py
sudo ./ssl_switch_test.py
</pre>

=== Debugging ===
==== mininet debugging ====
You'll see connection entries in the ovswitchd log file:
<pre>
sudo tail /var/log/openvswitch/ovs-vswitchd.log
</pre>
==== ODL controller debugging ====
<pre>
./run.sh -Djavax.net.debug=ssl,handshake
</pre>
