==Public API (openflow-protocol-api)==
Set of interfaces and builders for immutable data transfer
objects representing Openflow Protocol structures.
  
Transfer objects and service APIs are infered from several 
YANG models using code generator to reduce verbosity of 
definition and repeatibility of code. 

The following YANG modules are defined:
* openflow-types - defines common Openflow specific types
* openflow-instruction - defines base Openflow instructions
* openflow-action - defines base Openflow actions
* openflow-augments - defines object augmentations
* openflow-extensible-match - defines Openflow OXM match
* openflow-protocol - defines Openflow Protocol messages
* system-notifications - defines system notification objects
 
This modules also reuse types from following YANG modules:
* ietf-inet-types - IP adresses, IP prefixes, IP-protocol related types
* ietf-yang-types - Mac Address, etc. 
 
The use of predefined types is to make APIs contracts more 
safe, better readable and documented (e.g using MacAddress instead 
of byte array...)

==Channel pipeline (openflow-protocol-impl)==

Creates channel processing pipeline based on configuration and 
support.

=== Switch Connection Provider ===
Implementation of connection point for other projects. Library exposes its functionality through this class. <br />
Library can be configured, started and shutdowned here. There are also methods for custom (de)serializer registration.

=== TCP Handler ===
Represents single server that is handling incoming connections over TCP protocol. <br />
TCP Handler creates a single instance of Publishing Channel Initializer that will
initialize channels. After that it binds to configured InetAddress and port. When
a new device connects, TCP Handler registers its channel and passes control to
Publishing Channel Initializer.

[[File:ChannelPipeline.png|500px|right|Channel pipeline]]

=== Publishing Channel Initializer ===
This class is used for channel initialization / rejection and passing arguments. <br />
After a new channel has been registered it calls Switch Connection Handler’s (OF Plugin) accept method
to decide if the library should keep the newly registered channel or if the
channel should be closed. If the channel has been accepted, Publishing Channel
Initializer creates ConnectionAdapter instance. Finally the Publishing Channel
Initializer creates the whole pipeline with needed handlers and notifies Switch
Connection Handler with onConnectionReady notification. OpenFlow Plugin can now
start sending messages downstream.

=== Idle State Handler ===
If there are no messages received for more than time specified, this handler triggers idle state notification. <br />
The switch idle timeout is received as a parameter from
ConnectionConfiguration settings. Idle State Handler is inactive while there
are messages received within the switch idle timeout. If there are no
messages received for more than timeout specified, handler creates
SwitchIdleEvent message and sends it upstream.

=== TLS Detector ===
Detector is used for detecting message encryption. <br />
The detection occurs only once for each connection – only on the first message received.
In case messages are encrypted, TLS Detector
engages TLS Handler into pipeline, otherwise not. <br />
'''NOTE:''' <br />
Engaging TLS Detector into pipeline is matter of ConnectionConfiguration (FEATURE_SUPPORT)
set in SwitchConnectionProvider before server startup.

=== TLS Handler ===
It encrypts and decrypts messages with configured protocol. <br />
TLS Handler is represented as a Netty’s SslHandler.

=== OF Frame Decoder ===
Parses input stream into message frames for further processing. <br />
Framing is based on Openflow header length. If received message is shorter than minimal length of
OpenFlow message (8 bytes), OF Frame Decoder waits
for more data. After receiving at least 8 bytes the decoder checks length in
OpenFlow header. If there are still some bytes missing, the decoder waits for
them. Else the OF Frame Decoder sends correct length message to next handler in the channel
pipeline.

=== OF Version Detector ===
Detects version of used OpenFlow Protocol and discards unsupported version messages. <br />
If the detected version is supported, OF Version Detector creates
VersionMessageWrapper object containing the detected version and byte message and
sends this object upstream.

=== OF Decoder ===
Chooses correct deserilization factory (based on message type) and deserializes messages into generated DTOs. <br />
OF Decoder receives VersionMessageWrapper object and passes it to
DeserializationFactory which will return translated DTO. DeserializationFactory
creates MessageCodeKey object with version and type of received message and 
Class of object that will be the received message deserialized into.
This object is used as key when searching for appropriate decoder in
DecoderTable. DecoderTable is basically a map storing decoders. Found decoder
translates received message into DTO (DataTransferObject). If there was no
decoder found, null is returned. After returning translated DTO back to OF
Decoder, the decoder checks if it is null or not. When the DTO is null, the decoder
logs this state and throws an Exception. Else it passes the DTO further upstream. Finally, the OF
Decoder releases ByteBuf containing received and decoded byte message.

=== OF Encoder ===
Chooses correct serialization factory (based on type of DTO) and serializes DTOs into byte messages. <br />
OF Encoder does the opposite than the OF Decoder using the same principle. OF
Encoder receives DTO, passes it for translation and if the result is not null,
it sends translated DTO downstream as a ByteBuf. Searching for appropriate
encoder is done via MessageTypeKey, based on version and class of received DTO.

=== Delegating Inbound Handler ===
Delegates received DTOs to Connection Adapter. <br />
It also reacts on channelInactive and channelUnregistered events.
Upon one of these events is triggered,
DelegatingInboundHandler creates DisconnectEvent message and sends it upstream,
notifying upper layers about switch disconnection.

=== Connection Adapter ===
Provides a facade on top of pipeline, which hides netty.io specifics. Provides a set of methods
to register for incoming messages and to send messages to particular channel / session. <br />
ConnectionAdapterImpl basically implements three interfaces (unified in one superinterface
ConnectionFacade):
* ConnectionAdapter
* MessageConsumer
* OpenflowProtocolService


'''ConnectionAdapter'''
interface has methods for setting up listeners (message, system and connection
ready listener), method to check if all listeners are set, checking if the
channel is alive and disconnect method. Disconnect method clears responseCache
and disables consuming of new messages.

'''MessageConsumer'''
interface holds only one method: consume(). Consume() method is called from
DelegatingInboundHandler. This method processes received DTO’s based on their
type. There are three types of received objects:
* ''System notifications'' - invoke system notifications in OpenFlow Plugin (systemListener set). In case of DisconnectEvent message, the Connection Adapter clears response cache and disables consume() method processing,
* ''OpenFlow asynchronous messages (from switch)'' - invoke corresponding notifications in OpenFlow Plugin,
* ''OpenFlow symmetric messages (replies to requests)'' - create RpcResponseKey with XID and DTO’s class set. This RpcResponseKey is then used to find corresponding future object in responseCache. Future object is set with success flag, received message and errors (if any occurred). In case no corresponding future was found in responseCache, Connection Adapter logs warning and discards the message. Connection Adapter also logs warning when an unknown DTO is received.

For message processing description and diagrams visit [[Openflow Protocol Library:Openflow Protocol Library's message processing]]

'''OpenflowProtocolService'''
interface contains all rpc-methods for sending messages from upper layers
(OpenFlow Plugin) downstream and responding. Request messages return Future
filled with expected reply message, otherwise the expected Future is of type Void.

'''NOTE:''' <br />
MultipartRequest message is the only
exception. Basically it is request – reply Message type, but it wouldn’t be
able to process more following MultipartReply messages if this was implemented
as rpc (only one Future). This is why MultipartReply is implemented as
notification. OpenFlow Plugin takes care of correct message processing.

== SPI (openflow-protocol-spi)==
Defines interface for library's connection point for other projects. Library exposes its functionality through this interface.

== Integration test (openflow-protocol-it)==
Testing communication with simple client. 

== Simple client(simple-client)==
Lightweight switch simulator - programmable with desired scenarios.

=Openflow Protocol Library:Main page=
* [[Openflow Protocol Library:Main]]
