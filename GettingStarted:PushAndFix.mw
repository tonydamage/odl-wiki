= Push and fix scenario =

Clone, hack and push steps are well explained in [[GettingStarted:Pulling,_Hacking,_and_Pushing_All_the_Code_from_the_CLI]]. 

The next phase is review in gerrit. Here suggestions or comments might be added to pushed code. 

Finally the code might be:
* merged
* rebased + merged
* abandoned

Now back to case where code needs to be fixed or changed - we can use '''patch-set''' feature of gerrit + '''amend''' feature in git.

= Create patch-set to change the original push =
== The easiest scenario ==
After push you made some additional changes (inspired by review comments). Now to make the '''local commit''' run:
 git commit --amend
Optionally the commit message can be extended by some comments. But important is that at the end (near signoff line) of message there must be the change-id line added. 
This line can be generated automatically if the hook script for message has been installed or can be retrieved from gerrit change-page.

[[File:gerrit-changeId.png|gerrit - change id]]

Resulting commit message will look like this:
 this is message title
 
 message body containing changes details
 
 Signed-off-by: first name <email@address.com>\
 Change-Id: If517c0e31123b5609511dc3ed90b44d8427b08d6

Next step is to push changes to gerrit using:
 git push origin HEAD:refs/for/master 

Now gerrit will assign this push as next patch-set to the last push (with the same change-id).

== Another scenario ==
It might happen, that there are already some more local commits made on the branch. In case these commits are intended as next independent push it is easier to checkout the pushed state:
 git fetch https://git.opendaylight.org/gerrit/controller refs/changes/.../2 && git checkout -b topicAgain FETCH_HEAD
And here make the fix and replay the easy scenario.

= Best practices =
To avoid complications, please consider these:
* do not code on local master, use topic-branch instead (to create branch based on current state: <tt>git checkout -b myTopic</tt>)
*: if you have local changes already, use <tt>git stash</tt> to store them and <tt>git stash pop</tt> to apply them in the new branch
* try to avoid work depending on pushed but not yed merged code (the code might get changed or even abandoned)
* if you have to use work in progress as base for you code (even your own), use new branch (based on the last patch-set) and in case that the base commit changes, rebase your branch accordingly
*: <tt>git fetch https://git.opendaylight.org/gerrit/controller refs/changes/.../1</tt>
*: <tt>git checkout -b myTopicBranch FETCH_HEAD</tt>
*: And rebase (while myTopicBranch active):
*: <tt>git fetch https://git.opendaylight.org/gerrit/controller refs/changes/.../2</tt>
*: <tt>git rebase -i FETCH_HEAD</tt>
* in case it is too late, you can always recreate local branch reflecting the base commit and see local changes with respect to this branch
*: <tt>git fetch https://git.opendaylight.org/gerrit/controller refs/changes/.../3</tt>
*: <tt>git diff FETCH_HEAD</tt>
