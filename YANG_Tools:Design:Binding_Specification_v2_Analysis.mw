Binding Specification v2 builds on experience we gathered with YANG code
generation and building applications using YANG modeled entities, and
is to address issues in design of Binding Specification v1 and improve
usability of YANG Tools.

== Simple types mapping ==

=== Base YANG Types ===

Existing mapping of base YANG types does not have intuitive mapping to Java for unsigned types
and uses byte[] for binary type (which is mutable).

In order to fix this we propose change of mapping for following items:

{| class="wikitable"
|-
! YANG Type !! v1 Type !! v2 Type !! Comment
|-
| uint8 || java.lang.Short || (TBD) since guava does not have UnsignedByte || Original type did not capture unsigned semantics correctly, code was harder to read
|-
| uint16 || java.lang.Integer || (TBD) since guava does not have UnsignedInteger || Original type did not capture unsigned semantics correctly, code was harder to read
|-
| uint32 || java.lang.Long || com.google.common.primitives.UnsignedInteger|| Original type did not capture unsigned semantics correctly, code was harder to read

|-
| uint64|| java.lang.BigDecimal || com.google.common.primitives.UnsignedLong || Original type did not capture unsigned semantics correctly, code was harder to read

|-
| binary || byte[] || TBD. Probably ByteBuf from io.netty.buffer || byte[] is by virtue mutable, which breaks immutability contract and it itself does not implement hashcode and equals based on value, but on identity of object
|}

==== Affected code ====

Any code which use YANG models using unsigned types or binary, such as BGP-PCEP, Openflow


=== Static factory methods for derived simple types ===

Types derived from simple YANG types are still immutable value objects, which will tend to be used in the system,
it does not make sense to have multiple instances of logically equals Value objects.

New value objects will be constructed via static factory methods, which may be backed by Object cache in order
to decrease number of same objects.


==== Affected code ====

All code constructing YANG modeled entities. Change could be backwards compatible by still providing existing
constructors, but this constructors may be marked deprecated.

== Binding-Specification specific methods and fields conflict with YANG modeled entities ==

Binding-specific methods currently uses same pattern for getters and setters generated for YANG modeled structures, which makes
impossible to provide getters and setters for this YANG modeled structures.

Properties currently defined by YANG Binding:

* key, getKey() - higher possibility of collision by YANG models
* implementedInterface, getImplementedInterface() - low possibility of collision

=== Proposed solution ===

Solution is to not use get prefix for properties defined by Binding Specification,
and leave it only for YANG modeled properties.

=== Affected Existing Code ===

* Protocol libraries using getImplementedInterface() - simple rename of call of method to implementedInterface().
* getKey(), setKey() - most of the existing code, creating YANG modeled entities, this would require change in lot of code. Changes could be minimized by still generating deprecated getKey(),setKey() for YANG entities where there is no conflict.

== Conflict between grouping, identities, type definitions and data objects with same name ==

YANG defines several separate namespaces for:

* grouping
* identities
* type definition
* data object

Original Binding Specification unfortunately
used one namespace which prevented possibility to
define grouping and data container of same name.

=== Proposed solution ===

Use separate Java namespaces for grouping, identities,
type definition, data object.

=== Affected code ===

Any code using YANG modeled entities, simple
reimport of Java interfaces will fix the change, estimated update is 1MD per application.
