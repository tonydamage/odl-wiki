
<DRAFT>



==Rpc Routing==

# Broker asks 0mq router to invoke rpc on remote vm
# 0mq router looks up routing table to find location of service
# If a remote location is NOT found, send exception (or RpcResult) back to broker
# If remote location is found, create a callable task and give it to the executor pool.
## The callable tasks needs to establish a connection with the remote location and send the rpc request. 
### Optimization - Maintain a socket connection pool, 1 connection per host. The trick with this optimization is thread-safety. 0mq sockets are not thread-safe. Sockets should only be used in the thread that created it. Check how to connect one client (REQ) socket to multiple servers (REP) sockets. Or use ROUTER sockets instead.
## The callable task will block the thread and wait for the response to come back.
### Optimization - Invoke RPC in a non-blocking way.
## The callable task will deserialize the response and create a RpcResult object
## The callable task will handle zmq errors and create a RpcResult object
## The callable task will return a Future<RpcResult>.
## Handle thread-kill situations and create a RpcResult object
# Return a Future<RpcResult> back to broker

=== Rpc Routing Flow ===
[[File:Rpc.jpg|center]]

==Notifications==

=== Announcement Flow ===
''This flow is deprecated. We will be externalizing the routing table state in external store (eg: Infinispan)''
[[File:Announce.jpg|center|Announcement Flow]]

==Serialization==

==Security==
TBD
Refer to http://rfc.zeromq.org/spec:23
