== Introduction ==
Continuous System Integration Test (CSIT) area has been created to develop automated system test.

== Test Plans ==
* [[CrossProject:Integration_Group:CSIT_Test_Plan_Base|Base Edition]]
* [[CrossProject:Integration_Group:CSIT_Test_Plan_Virtualization|Virtualization Edition]]
* [[CrossProject:Integration_Group:CSIT_Test_Plan_Service_Provider|Service Provider Edition]]

== Implementation ==

CSIT runs at [[CrossProject:Integration_Group:ODL_Test_Lab|OpenDaylight Lab]]. This test bed is part of the OpenDaylight infrastructure maintained by Linux Foundation.<br/> 

CSIT is implemented through the following jobs in [https://jenkins.opendaylight.org/integration Integration Jenkins]:

* '''integration-deploy-controller-latest-base-edition''' (BUNDLEVERSION, JOBNAME, BUILDNUMBER). This job will:
** Update the controller VM with the base edition artifacts generated by the Jenkins job {JOBNAME }#${BUILDNUMBER} for the release version ${BUNDLEVERSION}
** Start the controller with the new SW

* '''integration-csit''' (BUNDLEVERSION, JOBNAME, BUILDNUMBER, PUSH). This job will perform the system test with the following steps:
** Update controller base edition (integration-deploy-controller-latest-base-edition) according to BUNDLEVERSION, JOBNAME, BUILDNUMBER described above
** Run Robot system test for base edition using Integration test code available at /test/csit/suites/base
** In case system test is passed and ${PUSH}=TRUE, upload release artifacts to Nexus

* '''integration-<project>-integration'''. This job polls the <project> merge builds. When a merge happens this job will:
** Build the OpenDaylight editions (Base, Service Provider, Virtualization)
** Extract the BUNDLEVERSION from the build
** Perform system test (integration-csit) with ${BUNDLEVERSION}=version from previous step, ${JOBNAME}=current jobname, ${BUILDNUMBER}=current build #, ${PUSH)=TRUE

== Code Development ==

System test code is part of our Integration repo, it is stored under /test folder. Here is how to [[CrossProject:Integration_Group:Hack_Code| download and hack the code]].

We also follow the same [[OpenDaylight_Controller:Development_Infrastructure_Overview|flow]] as any other OpenDaylight project, with some difference in the verify and merge jobs:

* '''integration-verify-test'''. This job will trigger on patch creation under /test folder and will:
** Update controller base edition (integration-deploy-controller-latest-base-edition) using last succesful base edition artifacts
** Run Robot system test for base edition using GERRIT patch test code

* '''integration-merge-test'''.  This job will trigger on patch merge under /test folder and will:
** Update controller base edition (integration-deploy-controller-latest-base-edition) using last succesful base edition artifacts
** Run Robot system test for base edition using merged test code

== Writting Test Code ==

System test cases are written in Robot framework. We recommend to follow these simple rules when writting test cases:

=== Test case organization ===

* We have 3 test suites as defined by Robot, they are stored in 3 separate folders under /test/csit/suites and they match the 3 system tests we envision for 3 different distributions: base, service provider and virtualization.

* The test suite folder (like /test/csit/suites/base) can contain a set of test files named “module.txt” (like “topology_manager.txt”).  Every file is in charge of testing one particular component or feature in Opendaylight like Topology Manager, Switch Manager, Container Mgr, etc…

* Every test file can have several test cases needed to test the entire module/feature. Every individual test case is recognized because it pushes one or more actions (like add a flow), gets a response and then makes a match condition to determine whether the action or actions are successful or not.

* The test files should be self-sufficient so that they can run independently no matter which order we execute the files. This means these files should add any configuration needed for the module test and then remove it to start the next file clean.

=== Name convention ===

* Names for the test files should match the feature we want to test: “topology_manager.txt”, “forwarding_rule_manager.txt”, “container_manager.txt”, etc… are good examples

* We also need to name the test cases within the files to describe the action being tested: “add flow”, “remove flow”, “get topology”, etc…

=== Test case order ===

* Test case order makes sense as it would be good to start testing from bottom to top, or base module/features to advanced module/features.

* Test case order is implemented by adding "XXX__" at the beginning of the filename like: “005__topology_manager.txt”, “010__forwarding_rule_manager.txt”, “015__container_manager.txt”, etc... The tag will be used for test execution and will be neglected for anything else like reporting.

=== Test Pre-conditions ===

Overall test pre-conditions (and post-conditions) are written in the "__init__.txt" file in the test suite folder (i.e. /test/csit/suites/base for base edition system test) 

So far the only pre-condition is every system test mininet VM is started with topology=tree,2 which generates  3 OF Switches:

* SW1 (00:...:01) has 2 ports: 1,2 that connects to SW2 and SW3
* SW2 (00:...:02) has 3 ports: 1 to host1 (10.0.0.1), 2 to host2 (10.0.0.2) and 3 to SW1
* SW3 (00:...:03) has 3 ports: 1 to host3 (10.0.0.3), 2 to host4 (10.0.0.4) and 3 to SW1

=== Reserved Variables ===

System test is invoked using a command like: pybot -v CONTROLLER:${CONTROLLER} -v MININET:${MININET} -v MININET_USER:${MININET_USER} -v USER_HOME:${USER_HOME} ${WORKSPACE}/test/csit/suites/base

This means the following variables are reserved:

* ${CONTROLLER}= Controller IP
* ${MININET}= Mininet IP
* ${MININET_USER}= Mininet Username
* ${USER_HOME}= Home path for Robot user

=== How to write a test file ===

Developers will be normally in charge of writing one or more test files. 

Before writing the Robot Test file:

* Make sure there is test plan written for your test case otherwise write the test plan first (link above on this wiki)
* Check [http://robotframework.googlecode.com/hg/doc/userguide/RobotFrameworkUserGuide.html?r=2.8.1 Robot user guide] if you are not familiar with Robot
* Check existing [[CrossProject:Integration_Group:CSIT_Test_Tools:_Robot_Based|robot libraries]] to see if you can reuse any keyword or variable. You can also add your own library if needed.
* Check some TC examples in the repo like the one in the next section. 
* Register the task in [https://trello.com/#b/ACYMpTVD/opendaylight-integration-group Trello] so that we do not duplicate efforts.
* Ask any question to integration-dev list.

=== Robot test file sample ===

<pre>
*** Settings ***
Documentation     Test suite for the forwarding manager module.
Suite Teardown    Delete All Sessions
Library           Collections
Library           ../../libraries/RequestsLibrary.py
Library           ../../libraries/Common.py
Variables         ../../variables/Variables.py

*** Variables ***
${name}           test_route1
${key}            staticRoute
${REST_CONTEXT}    /controller/nb/v2/staticroute

*** Test Cases ***
Add a static route
    [Documentation]    Add a static route, list to validate the result.
    [Tags]    add
    ${body}    Create Dictionary    name    ${name}    prefix    192.168.1.0/24    nextHop
    ...    10.0.0.2
    ${headers}    Create Dictionary    Content-Type    application/json
    Create Session    session    http://${CONTROLLER}:8080    headers=${headers}    auth=${auth}
    ${resp}    Put    session    ${REST_CONTEXT}/${CONTAINER}/route/${name}    data=${body}
    Should Be Equal As Strings    ${resp.status_code}    201    Response status code error
    ${resp}    Get    session    ${REST_CONTEXT}/${CONTAINER}/routes
    Should Be Equal As Strings    ${resp.status_code}    200    Response status code error
    ${result}    To JSON    ${resp.content}
    ${content}    Get From Dictionary    ${result}    ${key}
    List Should Contain Value    ${content}    ${body}

Remove a static route
    [Documentation]    Remove a static route, list to validate the result.
    [Tags]    remove
    ${body}    Create Dictionary    name    ${name}    prefix    192.168.1.0/24    nextHop
    ...    10.0.0.2
    ${headers}    Create Dictionary    Content-Type    application/json
    Create Session    session    http://${CONTROLLER}:8080    headers=${headers}    auth=${auth}
    ${resp}    Delete    session    ${REST_CONTEXT}/${CONTAINER}/route/${name}
    Should Be Equal As Strings    ${resp.status_code}    204    Response status code error
    ${resp}    Get    session    ${REST_CONTEXT}/${CONTAINER}/routes
    Should Be Equal As Strings    ${resp.status_code}    200    Response status code error
    ${result}    To JSON    ${resp.content}
    ${content}    Get From Dictionary    ${result}    ${key}
    List Should Not Contain Value    ${content}    ${body}
</pre>

=== How to control Mininet ===

Mininet shell (mininet>) is available for system test. Use Write and Read keywords from SSHLibrary like in the example below to control Mininet VM. Please do not forget to clear any mininet configuration and also clear output buffer (use Read) for next test file to run clean.

<pre>
*** Settings ***
Library     SSHLibrary

*** Keywords ***
My test case  
    Write    h1 ifconfig
    Sleep    2
    ${buffer}=     Read
</pre>

== Open Test Lab ==

Open Lab at Ericsson can be booked to debug system test code. Click [[CrossProject:Integration_Group:Test_Lab|here]]. <br/>

We are also working on offering Open Lab VMs for local system test debugging. <br/>

[[Category:Integration Group]]
