= Introduction =
Entry point for the extensibility is SwitchConnectionProvider.
SwitchConnectionProvider contains methods for (de)serializer registration. To
register deserializer it is needed to use .registerCustomDeserializer(key, impl).
To register serializer one must use .registerCustomSerializer(key, impl).
Registration can occur either during configuration or at runtime.

Impl is (de)serializer implementation and
must implement OFGeneralDeserializer / OFGeneralSerializer interface. These
interfaces are only empty unifying interfaces. Therefore it is needed to use their descendants that contain appropriate
methods.

= Basic principle & example (for users) =
In order to use extensions it is needed to augment existing model and register new (de)serializers.

'''Augmenting the model:''' <br />
1. Create new augmentation (you can check how do the existing ones look like in openflow-augments.yang) <br />

'''Register (de)serializers:''' <br />
1. Create your (de)serializer <br />
2. Let it implement OFDeserializer<> / OFSerializer<> <br />
- in case the structure you are (de)serializing needs to be used in Multipart TableFeatures messages, let it implement HeaderDeserializer<> / HeaderSerializer <br />
3. Implement prescribed methods <br />
4. Register your class under MessageCodeKey / EnhancedMessageCodeKey when registering deserializer <br />
5. Register your class under MessageTypeKey / EnhancedMessageTypeKey when registering serializer <br />
6. Done, test the change <br />

'''NOTE:''' There is also an exemplary bundle called openflow-protocol-ext (in the openflowjava project). One can inspire how to register custom (de)serializers based on the implementation of this bundle. 

=== Example ===
Let's say we have vendor / experimenter action represented by this structure:

 struct foo_action {
     uint16_t type;
     uint16_t length;
     uint32_t experimenter;
     uint16_t first;
     uint16_t second;
     uint8_t  pad[4];
 }

First, we have to augment existing model. We create new module, which imports "openflow-types.yang" (don't forget to update your pom.xml with api dependency). Now we create foo action identity:

 identity foo {
     description "Foo action description";
     base oft:action-base;
 }

This will be used as type in our structure.
Now we must augment existing action structure, so that we will have the desired fields first and second. In order to create new augmentation, our module has to import "openflow-action.yang". The augment should look like this:
 augment "/ofaction:actions-container/ofaction:action" {
     ext:augment-identifier "foo-action";
         leaf experimenter {
             type uint32;
         }
         leaf first {
             type uint16;
         }
         leaf second {
             type uint16;
         }
     }
We are finished with model changes. Run mvn clean compile to generate sources.
After generation is done, we need to implement our (de)serializer.  

Deserializer:
 public class FooActionDeserializer extends OFDeserializer<Action> {
    @Override
    public Action deserialize(ByteBuf input) {
        ActionBuilder builder = new ActionBuilder();
        input.skipBytes(SIZE_OF_SHORT_IN_BYTES); // we know the type of action
        builder.setType(Foo.class);
        input.skipBytes(SIZE_OF_SHORT_IN_BYTES); // we don't need length
        FooActionBuilder fooBuilder = new FooActionBuilder();
        fooBuilder.setExperimenter(input.readUnsignedInt());
        fooBuilder.setFirst(input.readUnsignedShort());
        fooBuilder.setSecond(input.readUnsignedShort());
        builder.addAugmentation(FooAction.class, fooBuilder.build());
        input.skipBytes(4); // padding
        return builder.build();
    }
 }

Serializer:
 public class FooActionSerializer extends OFSerializer<Action> {
    @Override
    public void serialize(Action action, ByteBuf outBuffer) {
        outBuffer.writeShort(FOO_CODE);
        outBuffer.writeShort(16);
        FooAction foo = action.getAugmentation(FooAction.class);
        outBuffer.writeInt(foo.getExperimenter());
        outBuffer.writeShort(foo.getFirst());
        outBuffer.writeShort(foo.getSecond());
        for (int i = 0; i < 4; i++) {
            outBuffer.writeByte(0); //write padding
        }
    }
 }

Register both deserializer and serializer:
SwitchConnectionProvider.registerDeserializer(new MessageCodeKey(0x04, 0xFFFF, Action.class), new FooActionDeserializer());
SwitchConnectionProvider.registerSerializer(new EnhancedMessageTypeKey<>(0x04, Action.class, Experimenter.class)), new FooActionSerializer());

Now we are ready to test our implementation.

= Detailed walkthrough (for developers) =
== Deserialization extensibility ==
=== External interface & class description ===
<u>'''OFGeneralDeserializer:'''</u>
* '''OFDeserializer<E extends DataObject>'''
** ''deserialize(ByteBuf)'' – deserializes given ByteBuf
* '''HeaderDeserializer<E extends DataObject>'''
** ''deserializeHeaders(ByteBuf)'' - deserializes only E headers (used in Multipart TableFeatures messages)


'''DeserializerRegistryInjector'''
* ''injectDeserializerRegistry(DeserializerRegistry)'' – injects deserializer registry into deserializer. Useful when custom deserializer needs access to other deserializers.

'''NOTE:''' DeserializerRegistryInjector is not OFGeneralDeserializer descendand. It is a standalone interface.


'''MessageCodeKey and EnhancedMessageCodeKey''' <br />
These keys are used as for deserializer lookup in DeserializerRegistry. <br />
MessageCodeKey should be used in general, when it is enough to identify corresponding deserializer by its value and Object class. EnhancedMessageCodeKey should be used in cases, when one value for Object class is not enough.

MessageCodeKey has these fields:
* ''short version'' – Openflow wire version number
* ''int value'' – value read from byte message
* ''Class<?> clazz - class of object being creating

EnhancedMessageCodeKey extends MessageCodeKey and has one more field:
* ''int value2'' – more specific distinguisher (usually specific type of ''value'')


=== Scenario walkthrough ===
[1] The scenario starts in a custom bundle which wants to extend library's functionality. The custom bundle creates deserializers which implement exposed OFDeserializer / HeaderDeserializer interfaces (wrapped under OFGeneralDeserializer unifying super interface).

[2] Created deserializers are paired with '''MessageCodeKey'''-s, which are used for deserializer lookup. <br />
In special cases, it might not be enough to have only one distinguishing value. Oxm match fields are such case. One needs to know oxm_class and also oxm_field to be able to determine which match entry it is. In this case, it is needed to use '''EnhancedMessageCodeKey'''.<br />

[3] Paired deserializers are passed to the OF Library via '''SwitchConnectionProvider'''''.registerCustomDeserializer(key, impl)''. Library registers the deserializer.
* While registering, Library checks if the deserializer is an instance of '''DeserializerRegistryInjector''' interface. If yes, the DeserializerRegistry (which stores all deserializer references) is injected into the deserializer.
This is particularly useful when the deserializer needs access to other deserializers. For example IntructionsDeserializer needs access to ActionsDeserializer in order to be able to process OFPIT_WRITE_ACTIONS/OFPIT_APPLY_ACTIONS instructions.
<br />


[[File:Extensibility.png | center | 800px | Deserialization extensibility]]

=== Possible openflow extensions and their keys ===
There are three vendor specific extensions in
Openflow v1.0 and nine in Openflow v1.3. These shall be identified by MessageCodeKey with version, value
and object class from the table below:
 
<div  align="left">
{|
|-
|                          
{| class="wikitable"
|-
! Vendor !! version !! value !! Object class
|-
| message || 1 || 4 || ExperimenterMessage.class
|-
| action || 1 || 0xFFFF || ExperimenterAction.class
|-
| stats message || TBD || TBD || TBD 
|}
|
{| class="wikitable"
|-
! Experimenter !! version !! value !! value2 !! Object class
|-
| message || 4 || 4 || - || ExperimenterMessage.class
|-
| match entry || 4 || oxm_class || oxm_field || MatchEntries.class
|-
| action || 4 || 0xFFFF || - || ExperimenterAction.class
|-
| instruction || 4 || 0xFFFF || - || ExperimenterInstruction.class
|-
| multipart || TBD || || ||  
|-
| multipart - table features || TBD || || ||  
|-
| meter band type || TBD || || ||  
|-
| queue property || TBD || || ||  
|}
|}
</div>
In case when more distinguishers are needed, use EnhancedMessageCodeKey instead of MessageCodeKey.

== Serialization extensibility ==
=== External interface & class description ===
<u>'''OFGeneralSerializer:'''</u>
* '''OFSerializer<E extends DataObject>'''
** ''serialize(E,ByteBuf)'' – serializes E into given ByteBuf
* '''HeaderSerializer<E extends DataObject>'''
** ''serializeHeaders(E,ByteBuf)'' – serializes E headers (used in Multipart TableFeatures messages)


'''SerializerRegistryInjector'''
* ''injectSerializerRegistry(SerializerRegistry)'' – injects serializer registry into serializer. Useful when custom serializer needs access to other serializers.

'''NOTE:''' SerializerRegistryInjector is not OFGeneralSerializer descendand.


'''MessageTypeKey and EnhancedMessageTypeKey''' <br />
These keys are used as for serializer lookup in SerializerRegistry. <br />
MessageTypeKey should be used in general, when it is enough to identify corresponding serializer by its DTO class. EnhancedMessageTypeKey should be used in cases, when one DTO class is not enough.

MessageTypeKey has these fields:
* ''short version'' – Openflow wire version number
* ''Class<E> msgType'' – DTO class

EnhancedMessageTypeKey extends MessageTypeKey and has one more field:
* ''Class<E> msgType2'' – more specific distinguisher (usually specific type of msgType)


=== Scenario walkthrough === 
[1] Serialization extensbility principles are similar to the deserialization principles. The scenario starts in a custom bundle. The custom bundle creates serializers which implement exposed OFSerializer / HeaderSerializer interfaces (wrapped under OFGeneralSerializer unifying super interface).

[2] Created serializers are paired with '''MessageTypeKey'''-s, which are used for serializer lookup. <br />
In special cases, it might not be enough to have only one distinguishing type. Oxm match fields are such case. One needs to know oxm_class and also oxm_field to be able to determine which match entry it is. In this case, one can use '''EnhancedMessageTypeKey'''.<br />

[3] Paired serializers are passed to the OF Library via '''SwitchConnectionProvider'''''.registerCustomSerializer(key, impl)''. Library registers the serializer.
* While registering, Library checks if the serializer is an instance of '''SerializerRegistryInjector''' interface. If yes, the SerializerRegistry (which stores all serializer references) is injected into the serializer.
This is particularly useful when the serializer needs access to other deserializers. For example IntructionsSerializer needs access to ActionsSerializer in order to be able to process OFPIT_WRITE_ACTIONS/OFPIT_APPLY_ACTIONS instructions.
<br />


[[File:Extensibility2.png | center | 800px | Serialization extensibility]]


=== Possible openflow extensions and their keys ===
There are three vendor specific extensions in
Openflow v1.0 and seven Openflow v1.3. These shall be identified by MessageTypeKey with version and
msgType class from the table below:

  
<div  align="left">
{|
|-
|                      
{| class="wikitable"
|-
! Message type !! version !! msgType(DTO class)
|-
| Vendor message || 1 || ExperimenterInput.class
|-
| Vendor action || 1 || ExperimenterAction.class
|-
| Stats message || 1 || MultipartRequestExperimenter.class
|}
|
{| class="wikitable"
|-
! Experimenter !! version !! msgType !! msgType2
|-
| message || 4 || ExperimenterInput.class || -
|-
| match entry || 4 || $OXM_CLASS.class || $OXM_FIELD.class
|-
| action || 4 || ExperimenterAction.class || -
|-
| instruction || 4 || ExperimenterInstruction.class || -
|-
| multipart || 4 || MultipartRequestExperimenter.class || -  
|-
| multipart - table features || 4 || TableFeatureProperties.class || -
|-
| meter band type || 4 || MeterBandExperimenter.class || -  
|}
|}
</div>  
 
In case when more
distinguishers are needed, use EnhancedMessageTypeKey instead of MessageTypeKey.

== Internal description ==
==== SwitchConnectionProvider ====
SwitchConnectionProvider constructs and
initializes both deserializer and serializer registries with default
(de)serializers. It also injects the DeserializerRegistry into the
DeserializationFactory, the SerializerRegistry into the SerializationFactory. <br />
When call to register custom (de)serializer
is made, SwitchConnectionProvider calls register method on appropriate registry.

==== DeserializerRegistry / SerializerRegistry ====
Both registries contain init() method to initialize default (de)serializers. <br />
Registration checks if key or (de)serializer
implementation are not null. If at least one of the is null,
NullPointerException is thrown. Else the (de)serializer implementation is
checked if it is (De)SerializerRegistryInjector instance. If it is an instance
of this interface, the registry is injected into this (de)serializer
implementation.
 
GetSerializer(key) or GetDeserializer(key)
performs registry lookup. Because there are two separate interfaces that might
be put into the registry, the registry uses their unifying super interface.
Get(De)Serializer(key) method casts the super interface to desired type. There
is also a null check for the (de)serializer received from the registry. If the
deserializer wasn’t found, NullPointerException with key description is thrown.
