== Deserialization extensibility ==
[1] The scenario starts in a custom bundle which wants to extend library's functionality. The custom bundle creates deserializers which implement exposed OFDeserializer / HeaderDeserializer interfaces (wrapped under OFGeneralDeserializer unifying super interface).
* '''OFDeserializer''' is the main deserialization interface - provides deserialize(),
* '''HeaderDeserializer''' provides deserializeHeader() - which is used in Multipart messages (OFPMP_TABLE_FEATURES type),
* '''DeserializerRegistryInjector''' provides injectDeserializerRegistry() method. Its purpose is described in [3].
[2] Created deserializers are paired with '''MessageCodeKey'''-s, which are used for deserializer lookup. MessageCodeKey contains information about:
* '''msgVersion''' (Openflow protocol wire version),
* '''value''' (value read from byte message - used as a distinguisher),
* '''clazz''' (class of object that is being created by the deserializer).
In special cases, it might not be enough to have only one distinguishing value. Oxm match fields are such case. One needs to know oxm_class and also oxm_field to be able to determine which match entry it is. In this case, one can use '''EnhancedMessageCodeKey'''.<br />

[3] Paired deserializers are passed to the OF Library via '''SwitchConnectionProvider'''''.registerCustomDeserializer(key, impl)''. Library registers the deserializer.
* While registering, Library checks if the deserializer is an instance of '''DeserializerRegistryInjector''' interface. If yes, the DeserializerRegistry (which stores all deserializer references) is injected into the deserializer.
This is particularly useful when the deserializer needs access to other deserializers. For example IntructionsDeserializer needs access to ActionsDeserializer in order to be able to process OFPIT_WRITE_ACTIONS/OFPIT_APPLY_ACTIONS instructions.
<br />


[[File:Extensibility2.png | center | 800px | Proposed extensibility]]


== Serialization extensibility ==
* [1] Serialization extensbility principles are similar to the deserialization principles. The scenario starts in a custom bundle. The custom bundle creates serializers which implement exposed OFSerializer / HeaderSerializer interfaces (wrapped under OFGeneralSerializer unifying super interface).
* '''OFSerializer''' is the main serialization interface - provides serialize(),
* '''HeaderSerializer''' provides serializeHeader() - which is used in Multipart messages (OFPMP_TABLE_FEATURES type),
* '''SerializerRegistryInjector''' provides injectSerializerRegistry() method. Its purpose is described in [3].
** There are some cases that need specific methods. For this purpose one can create interfaces that extend OpenflowDeserializer / OpenflowSerializer and use those.
[2] Created serializers are paired with '''MessageTypeKey'''-s, which are used for serializer lookup. MessageTypeKey contains information about:
* '''msgVersion''' (Openflow protocol wire version),
* '''msgType''' (DataObject/message type - used as a distinguisher).
In special cases, it might not be enough to have only one distinguishing type. Oxm match fields are such case. One needs to know oxm_class and also oxm_field to be able to determine which match entry it is. In this case, one can use '''EnhancedMessageTypeKey'''.<br />

[3] Paired serializers are passed to the OF Library via '''SwitchConnectionProvider'''''.registerCustomSerializer(key, impl)''. Library registers the serializer.
* While registering, Library checks if the serializer is an instance of '''SerializerRegistryInjector''' interface. If yes, the SerializerRegistry (which stores all serializer references) is injected into the serializer.
This is particularly useful when the serializer needs access to other deserializers. For example IntructionsSerializer needs access to ActionsSerializer in order to be able to process OFPIT_WRITE_ACTIONS/OFPIT_APPLY_ACTIONS instructions.
<br />
