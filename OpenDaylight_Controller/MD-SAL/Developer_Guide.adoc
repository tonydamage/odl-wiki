Model-Driven SAL (MD-SAL) is set of infrastructure services aimed for
providing common and generic support to application and plugin
developers.

MD-SAL currently provides infrastructure services for:

* Data Services
* RPC / Service routing
* Notification subscription and publish services

This common model-driven infrastructure allows developers of
applications and plugins to develop against an API type of their choice
(Java generated APIs, DOM APIs, REST APIs) and have other API types
provided automatically by the infrastructure.

The modelling language of choice for MD-SAL is YANG, which is IETF
standard for modelling network element configuration. Support for YANG
is provided by YANGTools project and their development tools.

[[api-types]]
== API Types

MD-SAL provides three API types:

* Java generated APIs - these are for consumers and producers
* DOM APIs - these are mostly used by infrastucture components and are
usuful for XML-driven plugin and application types
* REST APIs - OpenDaylight Controller:MD-SAL:Restconf[Restconf] - these
APIs are available to consumer type applications and provides access to
RPC and data stores.

[[base-yang-concepts-and-their-rendition-in-apis]]
== Base YANG Concepts and their rendition in APIs

The most basic concepts in YANG modeling are:

* RPCs - remote procedure call - in MD-SAL this are used for any call /
invocation which crosses plugin/module boundatories, is triggered by
consumer and usually have return value
* Notifications - asynchronous events, published by components for
listeners
* Configuration and Operational Data tree - Well-defined (by model) tree
structure which represents operational state of components and system.
** Instance Identifier - path, which uniquelly identifies subtree in
configuration / operational space. Most addressing of data is done by
Instance Identifier.

[[rpc]]
=== RPC

In YANG, RPCs (Remote Procedure Calls) are used to model any procedure
call implemented by a Provider (Server), which exposes functionality to
Consumers (Clients).

In the MD-SAL terminology, the term 'RPC' is used to define the input
and output for a procedure (function), which is to be provided by a
Provider and adapted by the MD-SAL.

In context of the MD-SAL, there are three types of RPCs (RPC services):

* OpenDaylight Controller:MD-SAL:Service Types#Global_Service[Global] -
one service instance (implementation) per controller container / mount
point
* OpenDaylight Controller:MD-SAL:Service Types#Routed_Service[Routed] -
multiple service instances (implementations) per controller container /
mount point

RPCs in various API types:

* Java Generated APIs - For each model there is *Service interface, see
YANG_Tools:YANG_to_Java_Mapping#Rpc how YANG statements maps to Service
interface.
** providers exposes their implementation of *Service by registering
their implementation to RpcProviderRegistry.
** consumers gets the *Service implementation from RpcConsumerRegistry.
If the implementator uses different API type, MD-SAL does automatic
transalation of data in background.
* DOM APIs - RPCs are identified by QName
** providers exposes their implementation of RPC idetified by QName
registering their RpcImplementation to RpcProvisionRegistry.
** consumers gets the *Service implementation from RpcConsumerRegistry.
If the implementator uses different API type, MD-SAL does automatic
transalation of data in background.
* REST APIs - RPCs are identified by model name and their name
* consumers invokes RPCs by invoking POST operation to
/restconf/operations/model-name:rpc-name.

[[notification]]
=== Notification

In YANG Notifications represent asynchronous events, published by
providers for listeners.

RPCs in various API types:

* Java Generated APIs - For each model there is *Listener interface, and
transfer object for each notification. see
YANG_Tools:YANG_to_Java_Mapping#Notification how YANG statements maps to
Notifications interface.
** providers publishes notifications by invoking publish method on
NotificationPublishService.
** To receive notifications consumers registers their implementation of
*Listener to NotificationBrokerService. If the notification publisher
uses different API type, MD-SAL does automatic translation of data in
background.
* DOM APIs - Notifications are represented only by XML Payload.
** providers publishes notifications by invoking publish method on
NotificationPublishService.
** To receive notifications consumers registers their implementation of
*Listener to NotificationBrokerService. If the notification publisher
uses different API type, MD-SAL does automatic translation of data in
background.
* REST APIs - Notifications are not currently supported.

[[instance-identifier]]
=== Instance Identifier

The Instance Identifier is a unique identifier of an element (location)
in the yang data tree; basically it is the *path* to the node that
uniquely identifies all the node's parent nodes. For unique
identification of list elements it is required to specify key values as
well.

MD-SAL currently provides three different APIs to access data in the
common data store:

* Binding APIs (Java generated DTOs)
* DOM APIs
* OpenDaylight_Controller:MD-SAL:Restconf[HTTP Restconf APIs]

[[example]]
==== Example

Consider the following simple YANG model for inventory:

-----------------------------------------------------
module inventory {
    namespace &quot;urn:opendaylight:inventory&quot;;
    prefix inv;
    revision &quot;2013-06-07&quot;;
    container nodes {
        list node {
            key &quot;id&quot;;
            leaf &quot;id&quot; {
                type &quot;string&quot;;
            }
        }
    }
}
-----------------------------------------------------

And having one instance of node with name _foo_;

Lets asume we want to create instance identifier for node foo, in
following bindings/ formats:

* YANG / XML / XPath version
+
---------------------------------------
/inv:nodes/inv:node[id=&quot;foo&quot;]
---------------------------------------
* Binding-Aware version (generated APIs)
+
------------------------------------------------------------------------------------------------------------------------------------------------
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.Nodes;
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.nodes.Node;
import org.opendaylight.yang.gen.urn.opendaylight.inventory.rev130607.nodes.NodeKey;

import org.opendaylight.yangtools.yang.binding.InstanceIdentifier;

InstanceIdentifier&lt;Node&gt; identifier = InstanceIdentifier.builder(Nodes.class).child(Node.class,new NodeKey(&quot;foo&quot;)).toInstance();
------------------------------------------------------------------------------------------------------------------------------------------------
+
*Note:* Last call _toInstance()_ does not return an instance of node,
but Java version of Instance identifier of Instance identifier which
uniquely identifies node "foo";
* *HTTP Restconf APIs*

--------------------------------------------------------------
http://localhost:8080/restconf/config/inventory:nodes/node/foo
--------------------------------------------------------------

*Note:* We assume that HTTP APIs are exposed on localhost, port 8080

Binding Independent version (yang-data-api)

------------------------------------------------------------------------------------------------------------
import org.opendaylight.yang.common.QName;
import org.opendaylight.yang.data.api.InstanceIdentifier;

QName nodes = QName.create(&quot;urn:opendaylight:inventory&quot;,&quot;2013-06-07&quot;,&quot;nodes&quot;);
QName node = QName.create(nodes,&quot;nodes&quot;);
QName idName = QName.create(nodes,&quot;id&quot;);
InstanceIdentifier = InstanceIdentifier.builder()
    .node(nodes)
    .nodeWithKey(node,idName,&quot;foo&quot;)
    .toInstance();
------------------------------------------------------------------------------------------------------------

*Note:* Last call _toInstance()_ does not return an instance of node,
but Java version of Instance identifier which uniquely identifies node
"foo";

[[plugin-types]]
=== Plugin Types

* OpenDaylight Controller:MD-SAL:Plugin Types[Plugin Types]
*
OpenDaylight Controller:MD-SAL:Southbound Plugin Development Guide[Southbound
Plugin Development Guide]
* OpenDaylight_Controller:MD-SAL:FAQ[ Model-Driven SAL FAQ]
* OpenDaylight_Controller:Config:Main[ Controller Configuration
Subsystem]
* OpenDaylight_Controller:Config:Model Reference[ OpenDaylight Model
Reference]

