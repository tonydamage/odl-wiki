[[configuration-and-transaction]]
= Configuration and Transaction

The *Configuration* operation has three stages. First, a *Proposed*
configuration is created; its target is to replace the old
configuration. Second, the Proposed configuration must be validated
before it can be committed. If it passes validation successfully, the
Proposed configuration's state will be changed to *Validated*. Finally,
a Validated configuration can be *Committed* and the affected modules
can be reconfigured.

In fact, each configuration operation is wrapped in a *transaction*.
Once a transaction is created, it can be *configured*, i.e. a user can
*abort* the transaction during this stage. After the transaction
configuration is done, it is committed to the *validation* stage. In
this stage the validation procedures are invoked. If one or more
validations fail, the transaction can be reconfigured. On success, the
*second phase commit* is invoked. If this commit is successful, the
transaction enters the last stage - *committed*. After that, the desired
modules are reconfigured. If the second phase commit fails, it means
that the transaction is *unhealthy* - basically, a new configuration
instance creation failed, and the application can be in an inconsistent
state.

File:Configuration.jpg|Configuration states
File:Transaction.jpg|Transaction states

[[validation]]
== Validation

To secure consistency and safety of new configuration and to avoid
conflicts, the configuration validation process is necessary. Usually,
validation checks input parameters of a new configuration and mostly
verifies module-specific relationships. The validation procedure results
in a decision whether the proposed configuration is healthy.

[[dependency-resolver]]
== Dependency Resolver

Since there can be dependencies between modules, a change of a module's
configuration can affect the state of other modules. Therefore, we need
to verify whether dependencies on other modules can be resolved. The
Dependency Resolver acts similar to dependency injectors - basically, a
dependency tree is built.

[[apis-and-spis]]
== APIs and SPIs

In this section configuration system APIs and SPIs will be briefly
described.

[[spis]]
=== SPIs

*Module* org.opendaylight.controller.config.spi.Module is common
interface for all modules - each module must implement it. Module is
designated to hold configuration attributes, validate them and create
instance of service based on the attributes. This instance must
implement AutoCloseable interface, due to resources clean up. If module
was created from already running instance, it contains and old instance
of module. Module can implement multiple services. if module depends on
other modules, setters need to be annotated with @RequireInterface.

*Module creation* Firstly, module needs to be *configured* - set all
required attributes. Thereafter module is moved to *commit* stage, where
validation is performed. If fails - module's attributes can be
reconfigured, otherwise new instance is *created* or old instance is
reconfigured. Module instance is identified by *ModuleIdentifier* -
consists of factory name and instance name.

*ModuleFactory* org.opendaylight.controller.config.spi.ModuleFactory
interface must be implemented by each module factory. Module factory can
create new module instance in two ways - from existing module instance
or pure new instance. Also can return default modules - useful for
populating registry with already existing configuration. Module factory
implementation must have globally unique name.

[[apis]]
=== APIs

*ConfigRegistry* +
represents functionality provided by configuration transaction (create,
destroy module, validate, abort transaction).

*ConfigTransactionController* +
represents functionality for manipulating with configuration
transactions (begin, commit config ).

*RuntimeBeanRegistratorAwareConfiBean* +
module implementing this interface will recieve RuntimeBeanRegistrator
before getInstance is invoked.

[[runtime-apis]]
=== Runtime APIs

*RuntimeBean* +
common interface for all runtime beans.

*RootRuntimeBeanRegistrator* +
represents functionality for root runtime bean registration, which
subsequently allows hierarchical registrations.

*HierarchicalRuntimeBeanRegistration* +
represents functionality for runtime bean registration and
unreregistration from hierarchy.

[[jmx-apis]]
=== JMX APIs

JMX API is purposed as a transition between Client API and JMX platform.

*ConfigTransactionControllerMXBean* +
extends ConfigTransactionController, executed by Jolokia clients on
configuration transaction.

*ConfigRegistryMXBean* +
represents entry point of configuration management for MXBeans.

[[object-names]]
=== Object names

Object Name is pattern used in JMX to locate JMX beans. It consists of
domain and key properties (at least one key-value pair). Domain is
defined as "org.opendaylight.controller". The only mandatory property is
"type".

[[use-case-scenarios]]
== Use case scenarios

Few samples of successful and unsuccessful transactions scenarios.

[[successful-commit-scenario]]
=== Successful commit scenario

1.  User create transaction calling creteTransaction() method on
ConfigRegistry.
2.  ConfigRegisty create transaction controller and registers the
transaction as new bean.
3.  Runtime configurations are copied to the transaction. User can
create modules and set their attributes.
4.  Configuration transaction is to be committed.
5.  Validation process is performed.
6.  After successful validation, second phase commit begins.
7.  Modules proposed to be destroyed are destroyed - their service
instances are closed.
8.  Runtime beans are set to registrator
9.  Transaction controller invoke method getInstance on each module
10. Transaction is committed and resources are closed or released.

[[validation-failure-scenario]]
=== Validation failure scenario

Transaction is same as previous case until validation process.

1.  If validation fails (i.e. illegal input attributes values or
dependency resolver failure), ValidationException is thrown and exposed
to user.
2.  User can decide to reconfigure transaction and commit again or abort
current transaction.
3.  On aborted transaction, TransactionController and JMXRegistrator are
properly closed.
4.  Unregistration event is send to ConfigRegistry.

[[default-module-instances]]
== Default Module Instances

Configuration subsystem provides a way for modules to create default
instances. Default instance is an instance of a module, that is created
at module's bundle startup (module becomes visible for configuration
subsystem e.g. its bundle is activated in OSGi environment). By default,
no default instances are produced.

The default instance does not differ from instances created later in
module's lifecycle. The only difference is that the configuration for
default instance cannot be provided by the configuration subsystem.
Module has to acquire the configuration for these instances on its own
and it can be acquired from e.g. environment variables. After the
creation of a default instance, it acts as a regular instance and fully
participates in the configuration subsystem (it can be reconfigured or
deleted in following transactions).

[[configuration-persister]]
= Configuration Persister

As a part of the configuration subsystem, purpose of the persister is to
save and load a permanent copy of a configuration. The *Persister*
interface represents basic operations over a storage - persist
configuration and load last config, configuration snapshot is
represented as string and set of it's capabilities. *StorageAdapter*
represents an adapter interface to the *ConfigProvider* - subset of
BundleContext, allowing access to the OSGi framework system properties.

[[persister-implementation]]
== Persister Implementation

Configuration persister implementation is part of the Controller
Netconf. *PersisterAggregator* class is implemenataion of Presister
interface. Functionality is delegated to the storage adapters. Storage
adapters are low level persisters that do the heavy lifting for this
class. Instances of storage adapters can be injected directly via
constructor or instantiated from a full name of its class provided in a
properties file. There can be many persisters configured and various
number of them can be used.

Example of presisters configuration :

`netconf.config.persister.active=2,3` +
`# read startup configuration` +
`netconf.config.persister.1.storageAdapterClass=org.opendaylight.controller.config.persist.storage.directory.xml.XmlDirectoryStorageAdapter` +
`netconf.config.persister.1.properties.fileStorage=configuration/initial/`

`netconf.config.persister.2.storageAdapterClass=org.opendaylight.controller.config.persist.storage.file.FileStorageAdapter` +
`netconf.config.persister.2.readonly=true` +
`netconf.config.persister.2.properties.fileStorage=configuration/current/controller.config.1.txt`

`netconf.config.persister.3.storageAdapterClass=org.opendaylight.controller.config.persist.storage.file.FileStorageAdapter` +
`netconf.config.persister.3.properties.fileStorage=configuration/current/controller.config.2.txt` +
`netconf.config.persister.3.properties.numberOfBackups=3`

During server startup ConfigPersisterNotificationHandler requests last
snapshot from underlying storages. Each storage can respond by giving
snapshot or absent response.The PersisterAggregator#loadLastConfigs()
will search for first non-absent response from storages ordered
backwards as user specified (first '3', then '2'). When a commit
notification is received, '2' will be omitted because readonly flag is
set to true, so only '3' will have a chance to persist new
configuration. If readonly was false or not specified, both storage
adapters would be called in order specified by
'netconf.config.persister' property.

[[persister-notification-handler]]
== Persister Notification Handler

*ConfigPersisterNotificationHandler* class is responsible for listening
for netconf notifications containing latest committed configuration. The
listener can handle incoming notifications, delegates configuration
saving/loading to the persister.

[[storage-adapter-implementations]]
== Storage Adapter Implementations

[[file-storage]]
=== File Storage

*FileStorageAdapter* implements StorageAdapter, provides file based
configuration persisting. File path and name is stored as a property and
a number of stored backups, expressing count of last configurations to
be persisted, too. The implementation can handle persisting input
configuration and load last configuration.

[[directory-storage]]
=== Directory Storage

*DirectoryStorageAdapter* retrieves initial configuration from a
directory. If multiple files are present, snapshot and required
capabilities will be merged together. Writing to this persister is not
supported.

[[xml-file-storage]]
=== XML File Storage

*XmlFileStorageAdapter* implementation stores configuration in an xml
file.

[[xml-directory-storage]]
=== XML Directory Storage

*XmlDirectoryStorageAdapter* retrieves initial configuration from a
directory. If multiple files are present, snapshot and required
capabilities will be merged together. Writing to this persister is not
supported.

[[no-operation-storage]]
=== No-Operation Storage

*NoOpStorageAdapter* serves as dummy implementation of the storage
adapter.
