This page contains ideas for work items that need to be done post-Hydrogen. It's just an unprioritized list right now.

=All Projects=
* Improve unit test coverage
* Add integration & regression tests
* Add system tests & stress tests
* Create/improve troubleshooting tools for protocol plugins - statistics, message traces, etc.

== Housekeeping ==

* Get so we can reliably do weekly releases (see [[CrossProject:HouseKeeping_Best_Practices_Group:Versioning:Automated_Weekly_Releases|]
** Clean up pom files so that maven versions plugin and release plugin work reliably (work with other projects on this)
** Look into using pom import to manage cross project dependencies
** Work on setting up cross project weekly releases (returning to snapshots after each week)
* Bringing whitespace check style to the masses
* Figure out something better than pax exam for integration tests ( or figure out how to make pax exam not incredible fragile)


=Yang Models (in General)=
* Cleanup yang module naming:
** odl-$MODULE.yang for the base model
** odl-$MODULE-cfg.yang for the config model
* Add descriptions to yang models so that it can show up in autogenerated documentation
* Applications need to support more user-friendly models
* Cleanup Flow and Inventory yang models


=Yang Tools =
* Programming language bindings
** Java
*** Skeleton service providers and consumers
*** Parameter checking (ranges implemented, what more?)
*** Improve error messages
*** Create binding specification version 2:
**** Use guave unsigned types
**** Get rid of byte[]
**** Redesign choice/case mapping
**** Integrate object reference caching
**** Logging of what is created at module level
*** Define model artifact versioning cycle
**** Models' revision changes, what happens?
**** Binding spec revision changes, what happens?
**** Bugfix to implementation occurs, what happens?
*** Inter-revision compatibility model
** Python
*** Define YANG->Python binding specification
*** Implement YANG->Python binding specification as a pyang plugin
*** Python MD-SAL agent library
** Scala
*** Define YANG->Scala binding specification
** JavaScript
*** Run-time model->binding generation
* Foreign modeling languages
** XSD
*** Define YANG->XSD mapping
*** Implement YANG->XSD generator
*** Define XSD->YANG mapping
*** Implement XSD->YANG generator
** WADL
* Documentation generation
** REST documentation generation
** Javadoc
*** Document range restrictions and exceptions thrown


=Controller= 
* Add documentation generator from yang tools into the controller runtime. When the controller finds a new model, it can auto-generate documentation for it as well. Make the documentation available in the controller's web server.
* Fix configuration packaging; right now, config models for all projects need to be included in the config subsystem, which is in the controller
** Use Case: Packet Decode.  If someone is listening for DHCPDecode... then DHCP decode registers to listen for UDPDecode.  When the last listener deregisters from DHCPDecode, it stops listening for UDPDecode
* Move component wiring configuration from the Config Subsystem to something simpler
** Writing configuration in the 'raw' module/service XML is tedious
** Does that mean we have an internal and external format?
** The internal persistence should bypass netconf sessions if at all possible
* Fix component initialization/loading order and add model dependencies to component loading & initialization.
* Move OpenFlow related functionality form the Controller into its own project (e.g. openflow models, OF NSFs, etc.) The controller should be just the container and infrastructure (configuration, SAL, etc.)
* Memory footprint optimizations
* Make bundle startup order deterministic
* Move clustering into its own project

==MD-SAL==
* Move MD-SAL to its own project
* Improve data store read performance
* Notifying plugins when the first listener for a notification registers and the last unregisters.
* Create/improve troubleshooting tools for MD-SAL 
* Memory profile MD-SAL and try to get down its memory footprint
* Look into lazy loading of items further down the tree (currently we only load children so far, and this can be counter intuitive in Java)
* Auto generating docs, WADL, RAML from models (both statically and at runtime)
* Auto generating bindings (both statically and at runtime) for
** Python
** Ruby
** Javascript
==MD Controller Applications ==
* MD Hosttracker
* MD L2 Switch with STP

==Netconf Client==
* Implement automatic reconnect after connection to the server has been lost
** This needs revision of state tracking in SessionListener and use of AbstractDispatcher.createReconnectingClient(). In general, the entire Netconf project needs to be reorganized to unify server and client.
* Asynchronous APIs for RPCs - sendMessage() will return a future with response, and will not block caller's thread.


=BGP-LS Plugin=
* Enable listening to BGP port so that remote peers can initiate the session
* Support for route dissemination
* Reorganize code/config to support [http://tools.ietf.org/html/draft-zhdankin-netmod-bgp-cfg draft-zhdankin-netmod-bgp-cfg] or similar
* Split out BGP/LS types into their respective technologies (ISO, OSPF, RSVP/TE, etc.)
* BGP Monitoring Protocol support
* Update for LSP dissemination
* Update for Segment Routing dissemination

=OpenFlow Plugin=
* Migrate onto the Configuration Subsystem
* Do proper MarK & Sweep state sync between controller & switch on switch reconnect
* Plugin internal stats - add more, make stats accessible through the config subsystem
* Urgent: Fix adapters to not have race condition
* Handle reserve ports as actual named things (and fix adapters around that) (note: OF10 and OF13 have different port numbers for the same logical reserve ports... adapters should also be fixed to handle)
* Check for and sort out any lingering OF10 issues in OFplugin
* Make topology initially aggressive then very calm
* Spread out stats polling
