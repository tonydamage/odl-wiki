=Overview=

This is MD-SAL based implementation of a learning switch with optimizations in how packet is forwarded. 

When a packet comes in, '''L2Switch''' learns about the source's mac address.  If it knows about the destination, it ''teleports'' the packet to destination.  Otherwise, it sends a broadcast message on all ''external'' ports in the network. <br>
:Teleporting means that the packet is sent to the destination without flooding.
:Internal ports consist of switch-to-switch ports and switch-to-controller ports.  External ports are all the remaining ports, which are potentially connected to hosts.
<br>
''Teleporting'' and using only ''external'' ports for broadcasting is an optimization over "flooding" which a typical learning switch would do.

=Switch actions=

Switch only deals with *non lldp* ethernet packets. 

{| class="wikitable"
|-
! Source Mac !! Target Mac !! L2 Switch Action !! Comments
|-
| Unknown || Unknown || Learn source, Broadcast packet on all external port minus ingress ||
|-
| Unknown || Known || Learn source, Unicast packet to the target || L2 Switch is essentially ''teleporting'' the packet to the ''node'' where the target is ''attached''. Attachment point is where the target is physically attached.
|-
| Known || Unknown || Broadcast packet on all external ports minus ingress || L2 Switch doesnt need to learn as it already knows the source. There could be case, however, where a host has moved from one node to another node in the network. In the current implementation, we dont update the attachment point. 
|-
| Known || Known || Unicast the packet to the target, find the shortest path between source and destination and install mac-to-mac flows on all the nodes in that path||
|}

=Implementation Details=

==Components==
[[File:Sample_L2Switch_Using_MD-SAL.png]] 
<br>
'''PacketHandler''' examines Ethernet packets to find information about Mac-Port pairings.<br>
:informs '''AddressTracker''' about new Mac-Port pairings.<br>
:informs '''FlowWriterService''' about new flows, when the source & destination of a packet are known.<br>
:uses '''InventoryService''' to determine ''external'' ports and only send packets to those ports when flooding packets in the network.<br>
'''AddressTracker''' stores the Mac-Port pairings in the MD-SAL data tree.<br>
'''InventoryService''' provides information about the nodes and node connectors in the network.<br>
'''FlowWriterService''' adds packet forwarding (mac-to-mac) flows to the MD-SAL data tree.<br>
:uses '''NetworkGraphDijkstra''' to determine all the intermediate nodes along a path.<br>
'''TopologyLinkDataChangeHandler''' listens to topology updates and informs '''NetworkGraphDijkstra''' of these updates.<br>
'''NetworkGraphDijkstra''' maintains the network graph and computes the shortest path between each node.<br>

==Determining the external ports in the network==

Definition of External Ports -- ports that potentially point to a host.  All the ports that are NOT connected to another switch or the controller.  <br>
To determine external ports: <br>
# Find the list of all node-to-node (switch-to-switch) internal ports.  This is done by looking at all the links from the Topology data.
# Find the list of all ports in the network.  This is done by looking at the Inventory data.
# The difference between List#1 and List#2 is a list of external ports and switch-to-controller (internal) ports.
# Switch-to-controller ports have special properties and can be easily removed from List#3.  This gives us the list of external ports.
<br>
Topology can change at any given time. Its possible that by the time we calculated the external ports, one of them became internal! In such scenario what will happen is when we send a broadcast message on this port, that message will bounce back to controller. Based on this message, it would appear to the controller that the host is connected to switch that bounced the message which is incorrect. Our current implementation would just ignore this packet as explained in the section [[OpenDaylight Controller:MD-SAL:L2 Switch#Why_we_dont_update_attachment_point|Why we dont update attachment point]].

==Finding the shortest path between 2 nodes==
<TBD>
Consult with Amit and add details

==Why we dont update attachment point==
==Why we do not update attachment point==
The L2 Switch maintains '''mac-port''' mapping for all mac addresses in the network -- this mapping is a canonical view of the network and not per switch. The ''port'' for a ''mac'' is the ''port'' where the ''mac'' is physically connected (not accounting for a repeater or an external switch scenario but it shouldn't matter there too). <br>
<br>
In order for the mac-port mapping to remain correct, the controller must not receive '''duplicate packets from 2 different switches'''. <br>
<br>
'''Why will receive duplicate packets from 2 different switches cause incorrect mac-port mappings?''' <br>
Host is connected to node1 on port1. <br>
Host sends out an ARP request, which the switch sends to the controller (because it doesn't know destination mac).  The controller will map this host's mac to '''node1:port1'''.  This is correct! <br>
The problem occurs when the controller forwards the original host's ARP request to node2 using port1 (so node2:port1 connects controller to node2).  If node2 doesn't contain the destination mac, it will pass the ARP request back to controller.  The packet that comes to controller would be from host but the ingress would be ''node2:port1''' and this is incorrect! <br>
<br>
'''The question is:  Should we update mac-port mapping?''' and change the host location from '''node1-port1''' to '''node2-port1'''.<br>
:If '''no''', since host is '''not''' really connected at this port, we miss the case when a host genuinely moves to a new location.
:If '''yes''', then there will be cases when our mac-port mapping gets corrupted.  We won't be able to optimally find shortest path between 2 hosts and hence not program flows appropriately.

=Assumptions=

#Assumes that hosts don't move i.e a mac address associated with a port on a node does'nt move to another port.
#Assumes LLDP packets are handled by Openflow Plugin. This switch ignores LLDP packets
#Assumes that for non LLDP packets, L2 Switch is the only forwarder of packet. If not, duplicate packets may be forwarded.
#All nodes in the network are openflow capable controlled by the controller.

=Limitation=

# Flow expiration is not handled
# Flow is not updated when host moves (see   [[OpenDaylight Controller:MD-SAL:L2 Switch#Assumptions|Assumptions]] section)
# Flows are not reprogrammed when topology changes

=How to run L2Switch=

* Setup mininet
* Copy model and impl jars to plugins directory
* Start opendaylight
* Stop ARPHandler and SimpleForwardingManager
* Start mininet with a topology of your choice. For eg:
:<source>
sudo mn --controller=remote,ip=<controller_ip> --topo linear,2 --switch ovsk,protocols=OpenFlow13
</source>
* Do pingall in mininet console. This should generate network traffic between hosts. Pings should work.
* All learn map-port mapping can be accessed at
:<source>http://localhost:8080/restconf/operational/l2-address-tracker:l2-addresses/</source>

=Items for discussion=

# Currently there is no mechanism to allow only 1 packet forwarder in controller. Their can be more than one module forwarding the packets resulting in duplicate packets in network and in some cases even stepping on each other.
# Modeling of ethernet packet based on yang needs to be done.
# Our assumption has been that the deployment would be with an out-of-band controller that connects to all the switches/NEs using a management network (separate than data network). How do we handle in-band controller deployment scenario?
# We had started off building AD-SAL like ''Hosttracker'' functionality. AD-SAL hosttracker stores IP for every host and keeps the information current by ARP probing hosts. After consultation with Ed and Colin, we decided to adhere strictly to L2 layer and store only mac-port mapping. Do we need to have a notion of host/device? If so, what would be its definition and what would identify it uniquely?
