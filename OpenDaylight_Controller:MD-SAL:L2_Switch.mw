=Overview=

This is MD-SAL based implementation of a learning switch with optimizations in how packet is forwarded. 

When a packet comes in, '''L2Switch''' learns about the source's mac address if it doesnt already know about. It then checks if it knows where the target is. If it knows about the target, it ''teleports'' the packet to target. If it doesnt know about the target, it sends a broadcast message on all ''external'' ports in the network.
''Teleporting'' and using '''only''' ''external'' ports for broadcasting is an optimization over "flooding" which a typical learning switch would do.

=Switch actions=

Switch only deals with *non lldp* ethernet packets. 

{| class="wikitable"
|-
! Source Mac !! Target Mac !! L2 Switch Action !! Comments
|-
| Unknown || Unknown || Learn source, Broadcast packet on all external port minus ingress ||
|-
| Unknown || Known || Learn source, Unicast packet to the target || L2 Switch is essentially ''teleporting'' the packet to the ''node'' where the target is ''attached''. Attachment point is where the target is physically attached.
|-
| Known || Unknown || Broadcast packet on all external ports minus ingress || L2 Switch doesnt need to learn as it already knows the source. There could be case, however, where a host has moved from one node to another node in the network. In the current implementation, we dont update the attachment point. 
|-
| Known || Known || Unicast the packet to the target, find the shortest path between source and destination and install mac-to-mac flows on all the nodes in that path||
|}

=Implementation Details=


==How do we determine external ports in the network==

External ports are ports that don't point to another switch in the network. In other words, they are potentially pointing to a host. 
To determine those, we find all the links from topology data. These give us all the ports where one node (switch) connects to another - internal ports. We also get a list of all available ports on all nodes using inventory data - internal + external ports.
The difference of the 2 lists give us external ports.

Now topology can change. Its possible that by the time we calculated the external ports, one of them became internal! In such scenario what will happen is when we send a broadcast message on this port, that message will bounce back to controller. Based on this message, it would appear to the controller that the host is connected to switch that bounced the message which is incorrect. Our current implementation would just ignore this packet as explained in the section [[OpenDaylight Controller:MD-SAL:L2 Switch#Why_we_dont_update_attachment_point|Why we dont update attachment point]].

==How do we find shortest path between 2 nodes==

==Why we dont update attachment point==
The L2 Switch maintains '''mac-port''' mapping for all mac addresses it learns about. This mapping is a canonical view of the network and not per switch. The ''port'' for a ''mac'' is the ''port'' where the ''mac'' is physically connected (not accounting for a repeater or an external switch scenario but it shouldn't matter there too).
To keep this mapping true, the controller must not receive duplicate packet-in from 2 different switch. 

'''Why?'''
Lets say, ARP Request arrives from a host on '''node 1''' at '''port 1'''. The switch doesnt identify the target, so it punts the message to the controller. The controller learns about host and maps it to ''node1:port1''.
Then controller broadcasts the packet on all its ports (minus ingress). Say one of these ports were an ''internal'' port connected to '''port 1''' on '''node 2'''. '''node 2''' will get the packet and say it also doesnt know about the target, it will punt the same message back to controller. Now this time controller will get the message with same source but ingress port as *node2:port1*.

'''The question is, should we update mac-port mapping?'''
And change the host location from '''node1-port1''' to '''node2-port1'''.
If '''no''', since host is '''not''' really connected at this port, we miss the case when a host genuinely moves to a new location.
If '''yes''', then we wont be able to optimally find shortest path between 2 hosts and hence not program flows appropriately.


=Assumptions=

#Assumes that hosts don't move i.e a mac address associated with a port on a node does'nt move to another port.
#Assumes LLDP packets are handled by Openflow Plugin. This switch ignores LLDP packets
#Assumes that for non LLDP packets, L2 Switch is the only forwarder of packet. If not, duplicate packets may be forwarded.
#All nodes in the network are openflow capable controlled by the controller.

=Limitation=

# Flow expiration is not handled
# Flow is not updated when host moves (see   [[OpenDaylight Controller:MD-SAL:L2 Switch#Assumptions|Assumptions]] section)
# Flows are not reprogrammed when topology changes

=How to run L2Switch=

* Setup mininet
* Copy model and impl jars to plugins directory
* Start opendaylight
* Stop ARPHandler and SimpleForwardingManager
* Start mininet with a topology of your choice. For eg:
:<source>
sudo mn --controller=remote,ip=<controller_ip> --topo linear,2 --switch ovsk,protocols=OpenFlow13
</source>
* Do pingall in mininet console. This should generate network traffic between hosts. Pings should work.
* All learn map-port mapping can be accessed at
:<source>http://localhost:8080/restconf/operational/host-tracker:hosts</source>
